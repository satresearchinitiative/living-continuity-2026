(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/three-stdlib/types/helpers.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getWithKey",
    ()=>getWithKey
]);
var getWithKey = function(obj, key) {
    return obj[key];
};
;
 //# sourceMappingURL=helpers.js.map
}),
"[project]/node_modules/three-stdlib/utils/BufferGeometryUtils.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "computeMorphedAttributes",
    ()=>computeMorphedAttributes,
    "estimateBytesUsed",
    ()=>estimateBytesUsed,
    "interleaveAttributes",
    ()=>interleaveAttributes,
    "mergeBufferAttributes",
    ()=>mergeBufferAttributes,
    "mergeBufferGeometries",
    ()=>mergeBufferGeometries,
    "mergeVertices",
    ()=>mergeVertices,
    "toCreasedNormals",
    ()=>toCreasedNormals,
    "toTrianglesDrawMode",
    ()=>toTrianglesDrawMode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$types$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three-stdlib/types/helpers.js [app-client] (ecmascript)");
;
;
var mergeBufferGeometries = function(geometries, useGroups) {
    var isIndexed = geometries[0].index !== null;
    var attributesUsed = new Set(Object.keys(geometries[0].attributes));
    var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
    var attributes = {};
    var morphAttributes = {};
    var morphTargetsRelative = geometries[0].morphTargetsRelative;
    var mergedGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
    var offset = 0;
    geometries.forEach(function(geom, i) {
        var attributesCount = 0;
        if (isIndexed !== (geom.index !== null)) {
            console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
            return null;
        }
        for(var name in geom.attributes){
            if (!attributesUsed.has(name)) {
                console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
                return null;
            }
            if (attributes[name] === void 0) {
                attributes[name] = [];
            }
            attributes[name].push(geom.attributes[name]);
            attributesCount++;
        }
        if (attributesCount !== attributesUsed.size) {
            console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes.");
            return null;
        }
        if (morphTargetsRelative !== geom.morphTargetsRelative) {
            console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries.");
            return null;
        }
        for(var name1 in geom.morphAttributes){
            if (!morphAttributesUsed.has(name1)) {
                console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries.");
                return null;
            }
            if (morphAttributes[name1] === void 0) morphAttributes[name1] = [];
            morphAttributes[name1].push(geom.morphAttributes[name1]);
        }
        mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];
        mergedGeometry.userData.mergedUserData.push(geom.userData);
        if (useGroups) {
            var count;
            if (geom.index) {
                count = geom.index.count;
            } else if (geom.attributes.position !== void 0) {
                count = geom.attributes.position.count;
            } else {
                console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute");
                return null;
            }
            mergedGeometry.addGroup(offset, count, i);
            offset += count;
        }
    });
    if (isIndexed) {
        var indexOffset = 0;
        var mergedIndex = [];
        geometries.forEach(function(geom) {
            var index = geom.index;
            for(var j = 0; j < index.count; ++j){
                mergedIndex.push(index.getX(j) + indexOffset);
            }
            indexOffset += geom.attributes.position.count;
        });
        mergedGeometry.setIndex(mergedIndex);
    }
    for(var name in attributes){
        var mergedAttribute = mergeBufferAttributes(attributes[name]);
        if (!mergedAttribute) {
            console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + name + " attribute.");
            return null;
        }
        mergedGeometry.setAttribute(name, mergedAttribute);
    }
    for(var name1 in morphAttributes){
        var numMorphTargets = morphAttributes[name1][0].length;
        if (numMorphTargets === 0) break;
        mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
        mergedGeometry.morphAttributes[name1] = [];
        for(var i = 0; i < numMorphTargets; ++i){
            var morphAttributesToMerge = [];
            for(var j = 0; j < morphAttributes[name1].length; ++j){
                morphAttributesToMerge.push(morphAttributes[name1][j][i]);
            }
            var mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);
            if (!mergedMorphAttribute) {
                console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + name1 + " morphAttribute.");
                return null;
            }
            mergedGeometry.morphAttributes[name1].push(mergedMorphAttribute);
        }
    }
    return mergedGeometry;
};
var mergeBufferAttributes = function(attributes) {
    var TypedArray = void 0;
    var itemSize = void 0;
    var normalized = void 0;
    var arrayLength = 0;
    attributes.forEach(function(attr) {
        if (TypedArray === void 0) {
            TypedArray = attr.array.constructor;
        }
        if (TypedArray !== attr.array.constructor) {
            console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
            return null;
        }
        if (itemSize === void 0) itemSize = attr.itemSize;
        if (itemSize !== attr.itemSize) {
            console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
            return null;
        }
        if (normalized === void 0) normalized = attr.normalized;
        if (normalized !== attr.normalized) {
            console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
            return null;
        }
        arrayLength += attr.array.length;
    });
    if (TypedArray && itemSize) {
        var array = new TypedArray(arrayLength);
        var offset = 0;
        attributes.forEach(function(attr) {
            array.set(attr.array, offset);
            offset += attr.array.length;
        });
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](array, itemSize, normalized);
    }
};
var interleaveAttributes = function(attributes) {
    var TypedArray = void 0;
    var arrayLength = 0;
    var stride = 0;
    for(var i = 0, l = attributes.length; i < l; ++i){
        var attribute = attributes[i];
        if (TypedArray === void 0) TypedArray = attribute.array.constructor;
        if (TypedArray !== attribute.array.constructor) {
            console.error("AttributeBuffers of different types cannot be interleaved");
            return null;
        }
        arrayLength += attribute.array.length;
        stride += attribute.itemSize;
    }
    var interleavedBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBuffer"](new TypedArray(arrayLength), stride);
    var offset = 0;
    var res = [];
    var getters = [
        "getX",
        "getY",
        "getZ",
        "getW"
    ];
    var setters = [
        "setX",
        "setY",
        "setZ",
        "setW"
    ];
    for(var j = 0, l1 = attributes.length; j < l1; j++){
        var attribute1 = attributes[j];
        var itemSize = attribute1.itemSize;
        var count = attribute1.count;
        var iba = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBufferAttribute"](interleavedBuffer, itemSize, offset, attribute1.normalized);
        res.push(iba);
        offset += itemSize;
        for(var c = 0; c < count; c++){
            for(var k = 0; k < itemSize; k++){
                var set = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$types$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWithKey"])(iba, setters[k]);
                var get = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$types$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWithKey"])(attribute1, getters[k]);
                set(c, get(c));
            }
        }
    }
    return res;
};
function estimateBytesUsed(geometry) {
    var mem = 0;
    for(var name in geometry.attributes){
        var attr = geometry.getAttribute(name);
        mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;
    }
    var indices = geometry.getIndex();
    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
    return mem;
}
function mergeVertices(geometry) {
    var tolerance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e-4;
    tolerance = Math.max(tolerance, Number.EPSILON);
    var hashToIndex = {};
    var indices = geometry.getIndex();
    var positions = geometry.getAttribute("position");
    var vertexCount = indices ? indices.count : positions.count;
    var nextIndex = 0;
    var attributeNames = Object.keys(geometry.attributes);
    var attrArrays = {};
    var morphAttrsArrays = {};
    var newIndices = [];
    var getters = [
        "getX",
        "getY",
        "getZ",
        "getW"
    ];
    for(var i = 0, l = attributeNames.length; i < l; i++){
        var name = attributeNames[i];
        attrArrays[name] = [];
        var morphAttr = geometry.morphAttributes[name];
        if (morphAttr) {
            morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(function() {
                return [];
            });
        }
    }
    var decimalShift = Math.log10(1 / tolerance);
    var shiftMultiplier = Math.pow(10, decimalShift);
    for(var i1 = 0; i1 < vertexCount; i1++){
        var index = indices ? indices.getX(i1) : i1;
        var hash = "";
        for(var j = 0, l1 = attributeNames.length; j < l1; j++){
            var name1 = attributeNames[j];
            var attribute = geometry.getAttribute(name1);
            var itemSize = attribute.itemSize;
            for(var k = 0; k < itemSize; k++){
                hash += "".concat(~~(attribute[getters[k]](index) * shiftMultiplier), ",");
            }
        }
        if (hash in hashToIndex) {
            newIndices.push(hashToIndex[hash]);
        } else {
            for(var j1 = 0, l2 = attributeNames.length; j1 < l2; j1++){
                var name2 = attributeNames[j1];
                var attribute1 = geometry.getAttribute(name2);
                var morphAttr1 = geometry.morphAttributes[name2];
                var itemSize1 = attribute1.itemSize;
                var newarray = attrArrays[name2];
                var newMorphArrays = morphAttrsArrays[name2];
                for(var k1 = 0; k1 < itemSize1; k1++){
                    var getterFunc = getters[k1];
                    newarray.push(attribute1[getterFunc](index));
                    if (morphAttr1) {
                        for(var m = 0, ml = morphAttr1.length; m < ml; m++){
                            newMorphArrays[m].push(morphAttr1[m][getterFunc](index));
                        }
                    }
                }
            }
            hashToIndex[hash] = nextIndex;
            newIndices.push(nextIndex);
            nextIndex++;
        }
    }
    var result = geometry.clone();
    for(var i2 = 0, l3 = attributeNames.length; i2 < l3; i2++){
        var name3 = attributeNames[i2];
        var oldAttribute = geometry.getAttribute(name3);
        var buffer = new oldAttribute.array.constructor(attrArrays[name3]);
        var attribute2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](buffer, oldAttribute.itemSize, oldAttribute.normalized);
        result.setAttribute(name3, attribute2);
        if (name3 in morphAttrsArrays) {
            for(var j2 = 0; j2 < morphAttrsArrays[name3].length; j2++){
                var oldMorphAttribute = geometry.morphAttributes[name3][j2];
                var buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name3][j2]);
                var morphAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);
                result.morphAttributes[name3][j2] = morphAttribute;
            }
        }
    }
    result.setIndex(newIndices);
    return result;
}
function toTrianglesDrawMode(geometry, drawMode) {
    if (drawMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TrianglesDrawMode"]) {
        console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
        return geometry;
    }
    if (drawMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TriangleFanDrawMode"] || drawMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TriangleStripDrawMode"]) {
        var index = geometry.getIndex();
        if (index === null) {
            var indices = [];
            var position = geometry.getAttribute("position");
            if (position !== void 0) {
                for(var i = 0; i < position.count; i++){
                    indices.push(i);
                }
                geometry.setIndex(indices);
                index = geometry.getIndex();
            } else {
                console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
                return geometry;
            }
        }
        var numberOfTriangles = index.count - 2;
        var newIndices = [];
        if (index) {
            if (drawMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TriangleFanDrawMode"]) {
                for(var i1 = 1; i1 <= numberOfTriangles; i1++){
                    newIndices.push(index.getX(0));
                    newIndices.push(index.getX(i1));
                    newIndices.push(index.getX(i1 + 1));
                }
            } else {
                for(var i2 = 0; i2 < numberOfTriangles; i2++){
                    if (i2 % 2 === 0) {
                        newIndices.push(index.getX(i2));
                        newIndices.push(index.getX(i2 + 1));
                        newIndices.push(index.getX(i2 + 2));
                    } else {
                        newIndices.push(index.getX(i2 + 2));
                        newIndices.push(index.getX(i2 + 1));
                        newIndices.push(index.getX(i2));
                    }
                }
            }
        }
        if (newIndices.length / 3 !== numberOfTriangles) {
            console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        }
        var newGeometry = geometry.clone();
        newGeometry.setIndex(newIndices);
        newGeometry.clearGroups();
        return newGeometry;
    } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
        return geometry;
    }
}
function computeMorphedAttributes(object) {
    if (object.geometry.isBufferGeometry !== true) {
        console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.");
        return null;
    }
    var _vA = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    var _vB = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    var _vC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    var _tempA = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    var _tempB = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    var _tempC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    var _morphA = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    var _morphB = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    var _morphC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {
        _vA.fromBufferAttribute(attribute, a2);
        _vB.fromBufferAttribute(attribute, b2);
        _vC.fromBufferAttribute(attribute, c2);
        var morphInfluences = object2.morphTargetInfluences;
        if (// @ts-ignore
        material2.morphTargets && morphAttribute && morphInfluences) {
            _morphA.set(0, 0, 0);
            _morphB.set(0, 0, 0);
            _morphC.set(0, 0, 0);
            for(var i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++){
                var influence = morphInfluences[i2];
                var morph = morphAttribute[i2];
                if (influence === 0) continue;
                _tempA.fromBufferAttribute(morph, a2);
                _tempB.fromBufferAttribute(morph, b2);
                _tempC.fromBufferAttribute(morph, c2);
                if (morphTargetsRelative2) {
                    _morphA.addScaledVector(_tempA, influence);
                    _morphB.addScaledVector(_tempB, influence);
                    _morphC.addScaledVector(_tempC, influence);
                } else {
                    _morphA.addScaledVector(_tempA.sub(_vA), influence);
                    _morphB.addScaledVector(_tempB.sub(_vB), influence);
                    _morphC.addScaledVector(_tempC.sub(_vC), influence);
                }
            }
            _vA.add(_morphA);
            _vB.add(_morphB);
            _vC.add(_morphC);
        }
        if (object2.isSkinnedMesh) {
            object2.boneTransform(a2, _vA);
            object2.boneTransform(b2, _vB);
            object2.boneTransform(c2, _vC);
        }
        modifiedAttributeArray[a2 * 3 + 0] = _vA.x;
        modifiedAttributeArray[a2 * 3 + 1] = _vA.y;
        modifiedAttributeArray[a2 * 3 + 2] = _vA.z;
        modifiedAttributeArray[b2 * 3 + 0] = _vB.x;
        modifiedAttributeArray[b2 * 3 + 1] = _vB.y;
        modifiedAttributeArray[b2 * 3 + 2] = _vB.z;
        modifiedAttributeArray[c2 * 3 + 0] = _vC.x;
        modifiedAttributeArray[c2 * 3 + 1] = _vC.y;
        modifiedAttributeArray[c2 * 3 + 2] = _vC.z;
    }
    var geometry = object.geometry;
    var material = object.material;
    var a, b, c;
    var index = geometry.index;
    var positionAttribute = geometry.attributes.position;
    var morphPosition = geometry.morphAttributes.position;
    var morphTargetsRelative = geometry.morphTargetsRelative;
    var normalAttribute = geometry.attributes.normal;
    var morphNormal = geometry.morphAttributes.position;
    var groups = geometry.groups;
    var drawRange = geometry.drawRange;
    var i, j, il, jl;
    var group, groupMaterial;
    var start, end;
    var modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);
    var modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);
    if (index !== null) {
        if (Array.isArray(material)) {
            for(i = 0, il = groups.length; i < il; i++){
                group = groups[i];
                groupMaterial = material[group.materialIndex];
                start = Math.max(group.start, drawRange.start);
                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                for(j = start, jl = end; j < jl; j += 3){
                    a = index.getX(j);
                    b = index.getX(j + 1);
                    c = index.getX(j + 2);
                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
                }
            }
        } else {
            start = Math.max(0, drawRange.start);
            end = Math.min(index.count, drawRange.start + drawRange.count);
            for(i = start, il = end; i < il; i += 3){
                a = index.getX(i);
                b = index.getX(i + 1);
                c = index.getX(i + 2);
                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
            }
        }
    } else if (positionAttribute !== void 0) {
        if (Array.isArray(material)) {
            for(i = 0, il = groups.length; i < il; i++){
                group = groups[i];
                groupMaterial = material[group.materialIndex];
                start = Math.max(group.start, drawRange.start);
                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                for(j = start, jl = end; j < jl; j += 3){
                    a = j;
                    b = j + 1;
                    c = j + 2;
                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
                }
            }
        } else {
            start = Math.max(0, drawRange.start);
            end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
            for(i = start, il = end; i < il; i += 3){
                a = i;
                b = i + 1;
                c = i + 2;
                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
            }
        }
    }
    var morphedPositionAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](modifiedPosition, 3);
    var morphedNormalAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](modifiedNormal, 3);
    return {
        positionAttribute: positionAttribute,
        normalAttribute: normalAttribute,
        morphedPositionAttribute: morphedPositionAttribute,
        morphedNormalAttribute: morphedNormalAttribute
    };
}
function toCreasedNormals(geometry) {
    var creaseAngle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Math.PI / 3;
    var creaseDot = Math.cos(creaseAngle);
    var hashMultiplier = (1 + 1e-10) * 100;
    var verts = [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()
    ];
    var tempVec1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    var tempVec2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    var tempNorm = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    var tempNorm2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    function hashVertex(v) {
        var x = ~~(v.x * hashMultiplier);
        var y = ~~(v.y * hashMultiplier);
        var z = ~~(v.z * hashMultiplier);
        return "".concat(x, ",").concat(y, ",").concat(z);
    }
    var resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;
    var posAttr = resultGeometry.attributes.position;
    var vertexMap = {};
    for(var i = 0, l = posAttr.count / 3; i < l; i++){
        var i3 = 3 * i;
        var a = verts[0].fromBufferAttribute(posAttr, i3 + 0);
        var b = verts[1].fromBufferAttribute(posAttr, i3 + 1);
        var c = verts[2].fromBufferAttribute(posAttr, i3 + 2);
        tempVec1.subVectors(c, b);
        tempVec2.subVectors(a, b);
        var normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().crossVectors(tempVec1, tempVec2).normalize();
        for(var n = 0; n < 3; n++){
            var vert = verts[n];
            var hash = hashVertex(vert);
            if (!(hash in vertexMap)) {
                vertexMap[hash] = [];
            }
            vertexMap[hash].push(normal);
        }
    }
    var normalArray = new Float32Array(posAttr.count * 3);
    var normAttr = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](normalArray, 3, false);
    for(var i1 = 0, l1 = posAttr.count / 3; i1 < l1; i1++){
        var i31 = 3 * i1;
        var a1 = verts[0].fromBufferAttribute(posAttr, i31 + 0);
        var b1 = verts[1].fromBufferAttribute(posAttr, i31 + 1);
        var c1 = verts[2].fromBufferAttribute(posAttr, i31 + 2);
        tempVec1.subVectors(c1, b1);
        tempVec2.subVectors(a1, b1);
        tempNorm.crossVectors(tempVec1, tempVec2).normalize();
        for(var n1 = 0; n1 < 3; n1++){
            var vert1 = verts[n1];
            var hash1 = hashVertex(vert1);
            var otherNormals = vertexMap[hash1];
            tempNorm2.set(0, 0, 0);
            for(var k = 0, lk = otherNormals.length; k < lk; k++){
                var otherNorm = otherNormals[k];
                if (tempNorm.dot(otherNorm) > creaseDot) {
                    tempNorm2.add(otherNorm);
                }
            }
            tempNorm2.normalize();
            normAttr.setXYZ(i31 + n1, tempNorm2.x, tempNorm2.y, tempNorm2.z);
        }
    }
    resultGeometry.setAttribute("normal", normAttr);
    return resultGeometry;
}
;
 //# sourceMappingURL=BufferGeometryUtils.js.map
}),
"[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "version",
    ()=>version
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
var version = /* @__PURE__ */ function() {
    return parseInt(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["REVISION"].replace(/\D+/g, ""));
}();
;
 //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/three-stdlib/_polyfill/LoaderUtils.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decodeText",
    ()=>decodeText
]);
function decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
        return new TextDecoder().decode(array);
    }
    var s = "";
    for(var i = 0, il = array.length; i < il; i++){
        s += String.fromCharCode(array[i]);
    }
    try {
        return decodeURIComponent(escape(s));
    } catch (e) {
        return s;
    }
}
;
 //# sourceMappingURL=LoaderUtils.js.map
}),
"[project]/node_modules/three-stdlib/loaders/GLTFLoader.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GLTFLoader",
    ()=>GLTFLoader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_call_super.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_get.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_get_prototype_of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_inherits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_instanceof.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_object_spread.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread_props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_object_spread_props.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_sliced_to_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_to_consumable_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_type_of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$BufferGeometryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three-stdlib/utils/BufferGeometryUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three-stdlib/_polyfill/LoaderUtils.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
var SRGBColorSpace = "srgb";
var LinearSRGBColorSpace = "srgb-linear";
var sRGBEncoding = 3001;
var LinearEncoding = 3e3;
var GLTFLoader = /*#__PURE__*/ function(Loader) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFLoader, Loader);
    function GLTFLoader(manager) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFLoader);
        var _this;
        _this = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFLoader, [
            manager
        ]);
        _this.dracoLoader = null;
        _this.ktx2Loader = null;
        _this.meshoptDecoder = null;
        _this.pluginCallbacks = [];
        _this.register(function(parser) {
            return new GLTFMaterialsClearcoatExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFMaterialsDispersionExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFTextureBasisUExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFTextureWebPExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFTextureAVIFExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFMaterialsSheenExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFMaterialsTransmissionExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFMaterialsVolumeExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFMaterialsIorExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFMaterialsEmissiveStrengthExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFMaterialsSpecularExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFMaterialsIridescenceExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFMaterialsAnisotropyExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFMaterialsBumpExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFLightsExtension(parser);
        });
        _this.register(function(parser) {
            return new GLTFMeshoptCompression(parser);
        });
        _this.register(function(parser) {
            return new GLTFMeshGpuInstancing(parser);
        });
        return _this;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFLoader, [
        {
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
                var scope = this;
                var resourcePath;
                if (this.resourcePath !== "") {
                    resourcePath = this.resourcePath;
                } else if (this.path !== "") {
                    var relativeUrl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].extractUrlBase(url);
                    resourcePath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].resolveURL(relativeUrl, this.path);
                } else {
                    resourcePath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].extractUrlBase(url);
                }
                this.manager.itemStart(url);
                var _onError = function _onError(e) {
                    if (onError) {
                        onError(e);
                    } else {
                        console.error(e);
                    }
                    scope.manager.itemError(url);
                    scope.manager.itemEnd(url);
                };
                var loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
                loader.setPath(this.path);
                loader.setResponseType("arraybuffer");
                loader.setRequestHeader(this.requestHeader);
                loader.setWithCredentials(this.withCredentials);
                loader.load(url, function(data) {
                    try {
                        scope.parse(data, resourcePath, function(gltf) {
                            onLoad(gltf);
                            scope.manager.itemEnd(url);
                        }, _onError);
                    } catch (e) {
                        _onError(e);
                    }
                }, onProgress, _onError);
            }
        },
        {
            key: "setDRACOLoader",
            value: function setDRACOLoader(dracoLoader) {
                this.dracoLoader = dracoLoader;
                return this;
            }
        },
        {
            key: "setDDSLoader",
            value: function setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
            }
        },
        {
            key: "setKTX2Loader",
            value: function setKTX2Loader(ktx2Loader) {
                this.ktx2Loader = ktx2Loader;
                return this;
            }
        },
        {
            key: "setMeshoptDecoder",
            value: function setMeshoptDecoder(meshoptDecoder) {
                this.meshoptDecoder = meshoptDecoder;
                return this;
            }
        },
        {
            key: "register",
            value: function register(callback) {
                if (this.pluginCallbacks.indexOf(callback) === -1) {
                    this.pluginCallbacks.push(callback);
                }
                return this;
            }
        },
        {
            key: "unregister",
            value: function unregister(callback) {
                if (this.pluginCallbacks.indexOf(callback) !== -1) {
                    this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
                }
                return this;
            }
        },
        {
            key: "parse",
            value: function parse(data, path, onLoad, onError) {
                var json;
                var extensions = {};
                var plugins = {};
                if (typeof data === "string") {
                    json = JSON.parse(data);
                } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(data, ArrayBuffer)) {
                    var magic = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(new Uint8Array(data.slice(0, 4)));
                    if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
                        try {
                            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
                        } catch (error) {
                            if (onError) onError(error);
                            return;
                        }
                        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
                    } else {
                        json = JSON.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(new Uint8Array(data)));
                    }
                } else {
                    json = data;
                }
                if (json.asset === void 0 || json.asset.version[0] < 2) {
                    if (onError) onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                    return;
                }
                var parser = new GLTFParser(json, {
                    path: path || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                parser.fileLoader.setRequestHeader(this.requestHeader);
                for(var i = 0; i < this.pluginCallbacks.length; i++){
                    var plugin = this.pluginCallbacks[i](parser);
                    if (!plugin.name) console.error("THREE.GLTFLoader: Invalid plugin found: missing name");
                    plugins[plugin.name] = plugin;
                    extensions[plugin.name] = true;
                }
                if (json.extensionsUsed) {
                    for(var i1 = 0; i1 < json.extensionsUsed.length; ++i1){
                        var extensionName = json.extensionsUsed[i1];
                        var extensionsRequired = json.extensionsRequired || [];
                        switch(extensionName){
                            case EXTENSIONS.KHR_MATERIALS_UNLIT:
                                extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                                break;
                            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                                extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                                break;
                            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                                extensions[extensionName] = new GLTFTextureTransformExtension();
                                break;
                            case EXTENSIONS.KHR_MESH_QUANTIZATION:
                                extensions[extensionName] = new GLTFMeshQuantizationExtension();
                                break;
                            default:
                                if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
                                    console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
                                }
                        }
                    }
                }
                parser.setExtensions(extensions);
                parser.setPlugins(plugins);
                parser.parse(onLoad, onError);
            }
        },
        {
            key: "parseAsync",
            value: function parseAsync(data, path) {
                var scope = this;
                return new Promise(function(resolve, reject) {
                    scope.parse(data, path, resolve, reject);
                });
            }
        }
    ]);
    return GLTFLoader;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"]);
function GLTFRegistry() {
    var objects = {};
    return {
        get: function get(key) {
            return objects[key];
        },
        add: function add(key, object) {
            objects[key] = object;
        },
        remove: function remove(key) {
            delete objects[key];
        },
        removeAll: function removeAll() {
            objects = {};
        }
    };
}
var EXTENSIONS = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
var GLTFLightsExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFLightsExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFLightsExtension);
        this.parser = parser;
        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
        this.cache = {
            refs: {},
            uses: {}
        };
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFLightsExtension, [
        {
            key: "_markDefs",
            value: function _markDefs() {
                var parser = this.parser;
                var nodeDefs = this.parser.json.nodes || [];
                for(var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){
                    var nodeDef = nodeDefs[nodeIndex];
                    if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
                        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
                    }
                }
            }
        },
        {
            key: "_loadLight",
            value: function _loadLight(lightIndex) {
                var parser = this.parser;
                var cacheKey = "light:" + lightIndex;
                var dependency = parser.cache.get(cacheKey);
                if (dependency) return dependency;
                var json = parser.json;
                var extensions = json.extensions && json.extensions[this.name] || {};
                var lightDefs = extensions.lights || [];
                var lightDef = lightDefs[lightIndex];
                var lightNode;
                var color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](16777215);
                if (lightDef.color !== void 0) color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);
                var range = lightDef.range !== void 0 ? lightDef.range : 0;
                switch(lightDef.type){
                    case "directional":
                        lightNode = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DirectionalLight"](color);
                        lightNode.target.position.set(0, 0, -1);
                        lightNode.add(lightNode.target);
                        break;
                    case "point":
                        lightNode = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointLight"](color);
                        lightNode.distance = range;
                        break;
                    case "spot":
                        lightNode = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SpotLight"](color);
                        lightNode.distance = range;
                        lightDef.spot = lightDef.spot || {};
                        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
                        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
                        lightNode.angle = lightDef.spot.outerConeAngle;
                        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
                        lightNode.target.position.set(0, 0, -1);
                        lightNode.add(lightNode.target);
                        break;
                    default:
                        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
                }
                lightNode.position.set(0, 0, 0);
                lightNode.decay = 2;
                assignExtrasToUserData(lightNode, lightDef);
                if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;
                lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
                dependency = Promise.resolve(lightNode);
                parser.cache.add(cacheKey, dependency);
                return dependency;
            }
        },
        {
            key: "getDependency",
            value: function getDependency(type, index) {
                if (type !== "light") return;
                return this._loadLight(index);
            }
        },
        {
            key: "createNodeAttachment",
            value: function createNodeAttachment(nodeIndex) {
                var self2 = this;
                var parser = this.parser;
                var json = parser.json;
                var nodeDef = json.nodes[nodeIndex];
                var lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
                var lightIndex = lightDef.light;
                if (lightIndex === void 0) return null;
                return this._loadLight(lightIndex).then(function(light) {
                    return parser._getNodeRef(self2.cache, lightIndex, light);
                });
            }
        }
    ]);
    return GLTFLightsExtension;
}();
var GLTFMaterialsUnlitExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFMaterialsUnlitExtension() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMaterialsUnlitExtension);
        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFMaterialsUnlitExtension, [
        {
            key: "getMaterialType",
            value: function getMaterialType() {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"];
            }
        },
        {
            key: "extendParams",
            value: function extendParams(materialParams, materialDef, parser) {
                var pending = [];
                materialParams.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](1, 1, 1);
                materialParams.opacity = 1;
                var metallicRoughness = materialDef.pbrMetallicRoughness;
                if (metallicRoughness) {
                    if (Array.isArray(metallicRoughness.baseColorFactor)) {
                        var array = metallicRoughness.baseColorFactor;
                        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
                        materialParams.opacity = array[3];
                    }
                    if (metallicRoughness.baseColorTexture !== void 0) {
                        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
                    }
                }
                return Promise.all(pending);
            }
        }
    ]);
    return GLTFMaterialsUnlitExtension;
}();
var GLTFMaterialsEmissiveStrengthExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFMaterialsEmissiveStrengthExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMaterialsEmissiveStrengthExtension);
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFMaterialsEmissiveStrengthExtension, [
        {
            key: "extendMaterialParams",
            value: function extendMaterialParams(materialIndex, materialParams) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                    return Promise.resolve();
                }
                var emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
                if (emissiveStrength !== void 0) {
                    materialParams.emissiveIntensity = emissiveStrength;
                }
                return Promise.resolve();
            }
        }
    ]);
    return GLTFMaterialsEmissiveStrengthExtension;
}();
var GLTFMaterialsClearcoatExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFMaterialsClearcoatExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMaterialsClearcoatExtension);
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFMaterialsClearcoatExtension, [
        {
            key: "getMaterialType",
            value: function getMaterialType(materialIndex) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
            }
        },
        {
            key: "extendMaterialParams",
            value: function extendMaterialParams(materialIndex, materialParams) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                    return Promise.resolve();
                }
                var pending = [];
                var extension = materialDef.extensions[this.name];
                if (extension.clearcoatFactor !== void 0) {
                    materialParams.clearcoat = extension.clearcoatFactor;
                }
                if (extension.clearcoatTexture !== void 0) {
                    pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
                }
                if (extension.clearcoatRoughnessFactor !== void 0) {
                    materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
                }
                if (extension.clearcoatRoughnessTexture !== void 0) {
                    pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
                }
                if (extension.clearcoatNormalTexture !== void 0) {
                    pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
                    if (extension.clearcoatNormalTexture.scale !== void 0) {
                        var scale = extension.clearcoatNormalTexture.scale;
                        materialParams.clearcoatNormalScale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](scale, scale);
                    }
                }
                return Promise.all(pending);
            }
        }
    ]);
    return GLTFMaterialsClearcoatExtension;
}();
var GLTFMaterialsDispersionExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFMaterialsDispersionExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMaterialsDispersionExtension);
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFMaterialsDispersionExtension, [
        {
            key: "getMaterialType",
            value: function getMaterialType(materialIndex) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
            }
        },
        {
            key: "extendMaterialParams",
            value: function extendMaterialParams(materialIndex, materialParams) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                    return Promise.resolve();
                }
                var extension = materialDef.extensions[this.name];
                materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;
                return Promise.resolve();
            }
        }
    ]);
    return GLTFMaterialsDispersionExtension;
}();
var GLTFMaterialsIridescenceExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFMaterialsIridescenceExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMaterialsIridescenceExtension);
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFMaterialsIridescenceExtension, [
        {
            key: "getMaterialType",
            value: function getMaterialType(materialIndex) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
            }
        },
        {
            key: "extendMaterialParams",
            value: function extendMaterialParams(materialIndex, materialParams) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                    return Promise.resolve();
                }
                var pending = [];
                var extension = materialDef.extensions[this.name];
                if (extension.iridescenceFactor !== void 0) {
                    materialParams.iridescence = extension.iridescenceFactor;
                }
                if (extension.iridescenceTexture !== void 0) {
                    pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
                }
                if (extension.iridescenceIor !== void 0) {
                    materialParams.iridescenceIOR = extension.iridescenceIor;
                }
                if (materialParams.iridescenceThicknessRange === void 0) {
                    materialParams.iridescenceThicknessRange = [
                        100,
                        400
                    ];
                }
                if (extension.iridescenceThicknessMinimum !== void 0) {
                    materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
                }
                if (extension.iridescenceThicknessMaximum !== void 0) {
                    materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
                }
                if (extension.iridescenceThicknessTexture !== void 0) {
                    pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
                }
                return Promise.all(pending);
            }
        }
    ]);
    return GLTFMaterialsIridescenceExtension;
}();
var GLTFMaterialsSheenExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFMaterialsSheenExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMaterialsSheenExtension);
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFMaterialsSheenExtension, [
        {
            key: "getMaterialType",
            value: function getMaterialType(materialIndex) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
            }
        },
        {
            key: "extendMaterialParams",
            value: function extendMaterialParams(materialIndex, materialParams) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                    return Promise.resolve();
                }
                var pending = [];
                materialParams.sheenColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](0, 0, 0);
                materialParams.sheenRoughness = 0;
                materialParams.sheen = 1;
                var extension = materialDef.extensions[this.name];
                if (extension.sheenColorFactor !== void 0) {
                    var colorFactor = extension.sheenColorFactor;
                    materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);
                }
                if (extension.sheenRoughnessFactor !== void 0) {
                    materialParams.sheenRoughness = extension.sheenRoughnessFactor;
                }
                if (extension.sheenColorTexture !== void 0) {
                    pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace));
                }
                if (extension.sheenRoughnessTexture !== void 0) {
                    pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
                }
                return Promise.all(pending);
            }
        }
    ]);
    return GLTFMaterialsSheenExtension;
}();
var GLTFMaterialsTransmissionExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFMaterialsTransmissionExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMaterialsTransmissionExtension);
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFMaterialsTransmissionExtension, [
        {
            key: "getMaterialType",
            value: function getMaterialType(materialIndex) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
            }
        },
        {
            key: "extendMaterialParams",
            value: function extendMaterialParams(materialIndex, materialParams) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                    return Promise.resolve();
                }
                var pending = [];
                var extension = materialDef.extensions[this.name];
                if (extension.transmissionFactor !== void 0) {
                    materialParams.transmission = extension.transmissionFactor;
                }
                if (extension.transmissionTexture !== void 0) {
                    pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
                }
                return Promise.all(pending);
            }
        }
    ]);
    return GLTFMaterialsTransmissionExtension;
}();
var GLTFMaterialsVolumeExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFMaterialsVolumeExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMaterialsVolumeExtension);
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFMaterialsVolumeExtension, [
        {
            key: "getMaterialType",
            value: function getMaterialType(materialIndex) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
            }
        },
        {
            key: "extendMaterialParams",
            value: function extendMaterialParams(materialIndex, materialParams) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                    return Promise.resolve();
                }
                var pending = [];
                var extension = materialDef.extensions[this.name];
                materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
                if (extension.thicknessTexture !== void 0) {
                    pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
                }
                materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
                var colorArray = extension.attenuationColor || [
                    1,
                    1,
                    1
                ];
                materialParams.attenuationColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
                return Promise.all(pending);
            }
        }
    ]);
    return GLTFMaterialsVolumeExtension;
}();
var GLTFMaterialsIorExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFMaterialsIorExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMaterialsIorExtension);
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_IOR;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFMaterialsIorExtension, [
        {
            key: "getMaterialType",
            value: function getMaterialType(materialIndex) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
            }
        },
        {
            key: "extendMaterialParams",
            value: function extendMaterialParams(materialIndex, materialParams) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                    return Promise.resolve();
                }
                var extension = materialDef.extensions[this.name];
                materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
                return Promise.resolve();
            }
        }
    ]);
    return GLTFMaterialsIorExtension;
}();
var GLTFMaterialsSpecularExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFMaterialsSpecularExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMaterialsSpecularExtension);
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFMaterialsSpecularExtension, [
        {
            key: "getMaterialType",
            value: function getMaterialType(materialIndex) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
            }
        },
        {
            key: "extendMaterialParams",
            value: function extendMaterialParams(materialIndex, materialParams) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                    return Promise.resolve();
                }
                var pending = [];
                var extension = materialDef.extensions[this.name];
                materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
                if (extension.specularTexture !== void 0) {
                    pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
                }
                var colorArray = extension.specularColorFactor || [
                    1,
                    1,
                    1
                ];
                materialParams.specularColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
                if (extension.specularColorTexture !== void 0) {
                    pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace));
                }
                return Promise.all(pending);
            }
        }
    ]);
    return GLTFMaterialsSpecularExtension;
}();
var GLTFMaterialsBumpExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFMaterialsBumpExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMaterialsBumpExtension);
        this.parser = parser;
        this.name = EXTENSIONS.EXT_MATERIALS_BUMP;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFMaterialsBumpExtension, [
        {
            key: "getMaterialType",
            value: function getMaterialType(materialIndex) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
            }
        },
        {
            key: "extendMaterialParams",
            value: function extendMaterialParams(materialIndex, materialParams) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                    return Promise.resolve();
                }
                var pending = [];
                var extension = materialDef.extensions[this.name];
                materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;
                if (extension.bumpTexture !== void 0) {
                    pending.push(parser.assignTexture(materialParams, "bumpMap", extension.bumpTexture));
                }
                return Promise.all(pending);
            }
        }
    ]);
    return GLTFMaterialsBumpExtension;
}();
var GLTFMaterialsAnisotropyExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFMaterialsAnisotropyExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMaterialsAnisotropyExtension);
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFMaterialsAnisotropyExtension, [
        {
            key: "getMaterialType",
            value: function getMaterialType(materialIndex) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
            }
        },
        {
            key: "extendMaterialParams",
            value: function extendMaterialParams(materialIndex, materialParams) {
                var parser = this.parser;
                var materialDef = parser.json.materials[materialIndex];
                if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                    return Promise.resolve();
                }
                var pending = [];
                var extension = materialDef.extensions[this.name];
                if (extension.anisotropyStrength !== void 0) {
                    materialParams.anisotropy = extension.anisotropyStrength;
                }
                if (extension.anisotropyRotation !== void 0) {
                    materialParams.anisotropyRotation = extension.anisotropyRotation;
                }
                if (extension.anisotropyTexture !== void 0) {
                    pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture));
                }
                return Promise.all(pending);
            }
        }
    ]);
    return GLTFMaterialsAnisotropyExtension;
}();
var GLTFTextureBasisUExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFTextureBasisUExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFTextureBasisUExtension);
        this.parser = parser;
        this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFTextureBasisUExtension, [
        {
            key: "loadTexture",
            value: function loadTexture(textureIndex) {
                var parser = this.parser;
                var json = parser.json;
                var textureDef = json.textures[textureIndex];
                if (!textureDef.extensions || !textureDef.extensions[this.name]) {
                    return null;
                }
                var extension = textureDef.extensions[this.name];
                var loader = parser.options.ktx2Loader;
                if (!loader) {
                    if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
                        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    } else {
                        return null;
                    }
                }
                return parser.loadTextureImage(textureIndex, extension.source, loader);
            }
        }
    ]);
    return GLTFTextureBasisUExtension;
}();
var GLTFTextureWebPExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFTextureWebPExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFTextureWebPExtension);
        this.parser = parser;
        this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
        this.isSupported = null;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFTextureWebPExtension, [
        {
            key: "loadTexture",
            value: function loadTexture(textureIndex) {
                var name = this.name;
                var parser = this.parser;
                var json = parser.json;
                var textureDef = json.textures[textureIndex];
                if (!textureDef.extensions || !textureDef.extensions[name]) {
                    return null;
                }
                var extension = textureDef.extensions[name];
                var source = json.images[extension.source];
                var loader = parser.textureLoader;
                if (source.uri) {
                    var handler = parser.options.manager.getHandler(source.uri);
                    if (handler !== null) loader = handler;
                }
                return this.detectSupport().then(function(isSupported) {
                    if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
                    if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
                        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    }
                    return parser.loadTexture(textureIndex);
                });
            }
        },
        {
            key: "detectSupport",
            value: function detectSupport() {
                if (!this.isSupported) {
                    this.isSupported = new Promise(function(resolve) {
                        var image = new Image();
                        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
                        image.onload = image.onerror = function() {
                            resolve(image.height === 1);
                        };
                    });
                }
                return this.isSupported;
            }
        }
    ]);
    return GLTFTextureWebPExtension;
}();
var GLTFTextureAVIFExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFTextureAVIFExtension(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFTextureAVIFExtension);
        this.parser = parser;
        this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
        this.isSupported = null;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFTextureAVIFExtension, [
        {
            key: "loadTexture",
            value: function loadTexture(textureIndex) {
                var name = this.name;
                var parser = this.parser;
                var json = parser.json;
                var textureDef = json.textures[textureIndex];
                if (!textureDef.extensions || !textureDef.extensions[name]) {
                    return null;
                }
                var extension = textureDef.extensions[name];
                var source = json.images[extension.source];
                var loader = parser.textureLoader;
                if (source.uri) {
                    var handler = parser.options.manager.getHandler(source.uri);
                    if (handler !== null) loader = handler;
                }
                return this.detectSupport().then(function(isSupported) {
                    if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
                    if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
                        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                    }
                    return parser.loadTexture(textureIndex);
                });
            }
        },
        {
            key: "detectSupport",
            value: function detectSupport() {
                if (!this.isSupported) {
                    this.isSupported = new Promise(function(resolve) {
                        var image = new Image();
                        image.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
                        image.onload = image.onerror = function() {
                            resolve(image.height === 1);
                        };
                    });
                }
                return this.isSupported;
            }
        }
    ]);
    return GLTFTextureAVIFExtension;
}();
var GLTFMeshoptCompression = /*#__PURE__*/ function() {
    "use strict";
    function GLTFMeshoptCompression(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMeshoptCompression);
        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
        this.parser = parser;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFMeshoptCompression, [
        {
            key: "loadBufferView",
            value: function loadBufferView(index) {
                var json = this.parser.json;
                var bufferView = json.bufferViews[index];
                if (bufferView.extensions && bufferView.extensions[this.name]) {
                    var extensionDef = bufferView.extensions[this.name];
                    var buffer = this.parser.getDependency("buffer", extensionDef.buffer);
                    var decoder = this.parser.options.meshoptDecoder;
                    if (!decoder || !decoder.supported) {
                        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
                            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        } else {
                            return null;
                        }
                    }
                    return buffer.then(function(res) {
                        var byteOffset = extensionDef.byteOffset || 0;
                        var byteLength = extensionDef.byteLength || 0;
                        var count = extensionDef.count;
                        var stride = extensionDef.byteStride;
                        var source = new Uint8Array(res, byteOffset, byteLength);
                        if (decoder.decodeGltfBufferAsync) {
                            return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
                                return res2.buffer;
                            });
                        } else {
                            return decoder.ready.then(function() {
                                var result = new ArrayBuffer(count * stride);
                                decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
                                return result;
                            });
                        }
                    });
                } else {
                    return null;
                }
            }
        }
    ]);
    return GLTFMeshoptCompression;
}();
var GLTFMeshGpuInstancing = /*#__PURE__*/ function() {
    "use strict";
    function GLTFMeshGpuInstancing(parser) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMeshGpuInstancing);
        this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
        this.parser = parser;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFMeshGpuInstancing, [
        {
            key: "createNodeMesh",
            value: function createNodeMesh(nodeIndex) {
                var _this, _loop = function(key) {
                    pending.push(_this.parser.getDependency("accessor", attributesDef[key]).then(function(accessor) {
                        attributes[key] = accessor;
                        return attributes[key];
                    }));
                };
                var _this1 = this;
                var json = this.parser.json;
                var nodeDef = json.nodes[nodeIndex];
                if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
                    return null;
                }
                var meshDef = json.meshes[nodeDef.mesh];
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = meshDef.primitives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var primitive = _step.value;
                        if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
                            return null;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                            _iterator["return"]();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                var extensionDef = nodeDef.extensions[this.name];
                var attributesDef = extensionDef.attributes;
                var pending = [];
                var attributes = {};
                for(var key in attributesDef)_this = this, _loop(key);
                if (pending.length < 1) {
                    return null;
                }
                pending.push(this.parser.createNodeMesh(nodeIndex));
                return Promise.all(pending).then(function(results) {
                    var nodeObject = results.pop();
                    var meshes = nodeObject.isGroup ? nodeObject.children : [
                        nodeObject
                    ];
                    var count = results[0].count;
                    var instancedMeshes = [];
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = meshes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var mesh = _step.value;
                            var m = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
                            var p = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                            var q = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
                            var s = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](1, 1, 1);
                            var instancedMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstancedMesh"](mesh.geometry, mesh.material, count);
                            for(var i = 0; i < count; i++){
                                if (attributes.TRANSLATION) {
                                    p.fromBufferAttribute(attributes.TRANSLATION, i);
                                }
                                if (attributes.ROTATION) {
                                    q.fromBufferAttribute(attributes.ROTATION, i);
                                }
                                if (attributes.SCALE) {
                                    s.fromBufferAttribute(attributes.SCALE, i);
                                }
                                instancedMesh.setMatrixAt(i, m.compose(p, q, s));
                            }
                            for(var attributeName in attributes){
                                if (attributeName === "_COLOR_0") {
                                    var attr = attributes[attributeName];
                                    instancedMesh.instanceColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstancedBufferAttribute"](attr.array, attr.itemSize, attr.normalized);
                                } else if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
                                    mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
                                }
                            }
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"].prototype.copy.call(instancedMesh, mesh);
                            _this1.parser.assignFinalMaterial(instancedMesh);
                            instancedMeshes.push(instancedMesh);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                                _iterator["return"]();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    if (nodeObject.isGroup) {
                        var _nodeObject;
                        nodeObject.clear();
                        (_nodeObject = nodeObject).add.apply(_nodeObject, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(instancedMeshes));
                        return nodeObject;
                    }
                    return instancedMeshes[0];
                });
            }
        }
    ]);
    return GLTFMeshGpuInstancing;
}();
var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = {
    JSON: 1313821514,
    BIN: 5130562
};
var GLTFBinaryExtension = function GLTFBinaryExtension(data) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFBinaryExtension);
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    this.header = {
        magic: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(new Uint8Array(data.slice(0, 4))),
        version: headerView.getUint32(4, true),
        length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    var chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    var chunkIndex = 0;
    while(chunkIndex < chunkContentsLength){
        var chunkLength = chunkView.getUint32(chunkIndex, true);
        chunkIndex += 4;
        var chunkType = chunkView.getUint32(chunkIndex, true);
        chunkIndex += 4;
        if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
            var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
            this.content = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(contentArray);
        } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
            var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
            this.body = data.slice(byteOffset, byteOffset + chunkLength);
        }
        chunkIndex += chunkLength;
    }
    if (this.content === null) {
        throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
};
var GLTFDracoMeshCompressionExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFDracoMeshCompressionExtension(json, dracoLoader) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFDracoMeshCompressionExtension);
        if (!dracoLoader) {
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        }
        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
        this.json = json;
        this.dracoLoader = dracoLoader;
        this.dracoLoader.preload();
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFDracoMeshCompressionExtension, [
        {
            key: "decodePrimitive",
            value: function decodePrimitive(primitive, parser) {
                var json = this.json;
                var dracoLoader = this.dracoLoader;
                var bufferViewIndex = primitive.extensions[this.name].bufferView;
                var gltfAttributeMap = primitive.extensions[this.name].attributes;
                var threeAttributeMap = {};
                var attributeNormalizedMap = {};
                var attributeTypeMap = {};
                for(var attributeName in gltfAttributeMap){
                    var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
                    threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
                }
                for(var attributeName1 in primitive.attributes){
                    var threeAttributeName1 = ATTRIBUTES[attributeName1] || attributeName1.toLowerCase();
                    if (gltfAttributeMap[attributeName1] !== void 0) {
                        var accessorDef = json.accessors[primitive.attributes[attributeName1]];
                        var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
                        attributeTypeMap[threeAttributeName1] = componentType.name;
                        attributeNormalizedMap[threeAttributeName1] = accessorDef.normalized === true;
                    }
                }
                return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
                    return new Promise(function(resolve, reject) {
                        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
                            for(var attributeName in geometry.attributes){
                                var attribute = geometry.attributes[attributeName];
                                var normalized = attributeNormalizedMap[attributeName];
                                if (normalized !== void 0) attribute.normalized = normalized;
                            }
                            resolve(geometry);
                        }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);
                    });
                });
            }
        }
    ]);
    return GLTFDracoMeshCompressionExtension;
}();
var GLTFTextureTransformExtension = /*#__PURE__*/ function() {
    "use strict";
    function GLTFTextureTransformExtension() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFTextureTransformExtension);
        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFTextureTransformExtension, [
        {
            key: "extendTexture",
            value: function extendTexture(texture, transform) {
                if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
                    return texture;
                }
                texture = texture.clone();
                if (transform.texCoord !== void 0) {
                    texture.channel = transform.texCoord;
                }
                if (transform.offset !== void 0) {
                    texture.offset.fromArray(transform.offset);
                }
                if (transform.rotation !== void 0) {
                    texture.rotation = transform.rotation;
                }
                if (transform.scale !== void 0) {
                    texture.repeat.fromArray(transform.scale);
                }
                texture.needsUpdate = true;
                return texture;
            }
        }
    ]);
    return GLTFTextureTransformExtension;
}();
var GLTFMeshQuantizationExtension = function GLTFMeshQuantizationExtension() {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFMeshQuantizationExtension);
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
};
var GLTFCubicSplineInterpolant = /*#__PURE__*/ function(Interpolant) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFCubicSplineInterpolant, Interpolant);
    function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFCubicSplineInterpolant);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFCubicSplineInterpolant, [
            parameterPositions,
            sampleValues,
            sampleSize,
            resultBuffer
        ]);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFCubicSplineInterpolant, [
        {
            key: "copySampleValue_",
            value: function copySampleValue_(index) {
                var result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
                for(var i = 0; i !== valueSize; i++){
                    result[i] = values[offset + i];
                }
                return result;
            }
        },
        {
            key: "interpolate_",
            value: function interpolate_(i1, t0, t, t1) {
                var result = this.resultBuffer;
                var values = this.sampleValues;
                var stride = this.valueSize;
                var stride2 = stride * 2;
                var stride3 = stride * 3;
                var td = t1 - t0;
                var p = (t - t0) / td;
                var pp = p * p;
                var ppp = pp * p;
                var offset1 = i1 * stride3;
                var offset0 = offset1 - stride3;
                var s2 = -2 * ppp + 3 * pp;
                var s3 = ppp - pp;
                var s0 = 1 - s2;
                var s1 = s3 - pp + p;
                for(var i = 0; i !== stride; i++){
                    var p0 = values[offset0 + i + stride];
                    var m0 = values[offset0 + i + stride2] * td;
                    var p1 = values[offset1 + i + stride];
                    var m1 = values[offset1 + i] * td;
                    result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
                }
                return result;
            }
        }
    ]);
    return GLTFCubicSplineInterpolant;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Interpolant"]);
var _q = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
var GLTFCubicSplineQuaternionInterpolant = /*#__PURE__*/ function(GLTFCubicSplineInterpolant) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFCubicSplineQuaternionInterpolant, GLTFCubicSplineInterpolant);
    function GLTFCubicSplineQuaternionInterpolant() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFCubicSplineQuaternionInterpolant);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFCubicSplineQuaternionInterpolant, arguments);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFCubicSplineQuaternionInterpolant, [
        {
            key: "interpolate_",
            value: function interpolate_(i1, t0, t, t1) {
                var result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFCubicSplineQuaternionInterpolant.prototype), "interpolate_", this).call(this, i1, t0, t, t1);
                _q.fromArray(result).normalize().toArray(result);
                return result;
            }
        }
    ]);
    return GLTFCubicSplineQuaternionInterpolant;
}(GLTFCubicSplineInterpolant);
var WEBGL_CONSTANTS = {
    FLOAT: 5126,
    //FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
};
var WEBGL_FILTERS = {
    9728: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"],
    9729: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"],
    9984: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestMipmapNearestFilter"],
    9985: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearMipmapNearestFilter"],
    9986: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestMipmapLinearFilter"],
    9987: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearMipmapLinearFilter"]
};
var WEBGL_WRAPPINGS = {
    33071: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"],
    33648: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MirroredRepeatWrapping"],
    10497: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"]
};
var WEBGL_TYPE_SIZES = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
};
var ATTRIBUTES = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread_props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent"
}, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 152 ? {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3"
} : {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2"
}), {
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
});
var PATH_PROPERTIES = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
};
var INTERPOLATION = {
    CUBICSPLINE: void 0,
    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
    // keyframe track will be initialized with a default interpolation type, then modified.
    LINEAR: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterpolateLinear"],
    STEP: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterpolateDiscrete"]
};
var ALPHA_MODES = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
    if (cache["DefaultMaterial"] === void 0) {
        cache["DefaultMaterial"] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
            color: 16777215,
            emissive: 0,
            metalness: 1,
            roughness: 1,
            transparent: false,
            depthTest: true,
            side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FrontSide"]
        });
    }
    return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
    for(var name in objectDef.extensions){
        if (knownExtensions[name] === void 0) {
            object.userData.gltfExtensions = object.userData.gltfExtensions || {};
            object.userData.gltfExtensions[name] = objectDef.extensions[name];
        }
    }
}
function assignExtrasToUserData(object, gltfDef) {
    if (gltfDef.extras !== void 0) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(gltfDef.extras) === "object") {
            Object.assign(object.userData, gltfDef.extras);
        } else {
            console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
        }
    }
}
function addMorphTargets(geometry, targets, parser) {
    var hasMorphPosition = false;
    var hasMorphNormal = false;
    var hasMorphColor = false;
    for(var i = 0, il = targets.length; i < il; i++){
        var target = targets[i];
        if (target.POSITION !== void 0) hasMorphPosition = true;
        if (target.NORMAL !== void 0) hasMorphNormal = true;
        if (target.COLOR_0 !== void 0) hasMorphColor = true;
        if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;
    }
    if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);
    var pendingPositionAccessors = [];
    var pendingNormalAccessors = [];
    var pendingColorAccessors = [];
    for(var i1 = 0, il1 = targets.length; i1 < il1; i1++){
        var target1 = targets[i1];
        if (hasMorphPosition) {
            var pendingAccessor = target1.POSITION !== void 0 ? parser.getDependency("accessor", target1.POSITION) : geometry.attributes.position;
            pendingPositionAccessors.push(pendingAccessor);
        }
        if (hasMorphNormal) {
            var pendingAccessor1 = target1.NORMAL !== void 0 ? parser.getDependency("accessor", target1.NORMAL) : geometry.attributes.normal;
            pendingNormalAccessors.push(pendingAccessor1);
        }
        if (hasMorphColor) {
            var pendingAccessor2 = target1.COLOR_0 !== void 0 ? parser.getDependency("accessor", target1.COLOR_0) : geometry.attributes.color;
            pendingColorAccessors.push(pendingAccessor2);
        }
    }
    return Promise.all([
        Promise.all(pendingPositionAccessors),
        Promise.all(pendingNormalAccessors),
        Promise.all(pendingColorAccessors)
    ]).then(function(accessors) {
        var morphPositions = accessors[0];
        var morphNormals = accessors[1];
        var morphColors = accessors[2];
        if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
        if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
        if (hasMorphColor) geometry.morphAttributes.color = morphColors;
        geometry.morphTargetsRelative = true;
        return geometry;
    });
}
function updateMorphTargets(mesh, meshDef) {
    mesh.updateMorphTargets();
    if (meshDef.weights !== void 0) {
        for(var i = 0, il = meshDef.weights.length; i < il; i++){
            mesh.morphTargetInfluences[i] = meshDef.weights[i];
        }
    }
    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
        var targetNames = meshDef.extras.targetNames;
        if (mesh.morphTargetInfluences.length === targetNames.length) {
            mesh.morphTargetDictionary = {};
            for(var i1 = 0, il1 = targetNames.length; i1 < il1; i1++){
                mesh.morphTargetDictionary[targetNames[i1]] = i1;
            }
        } else {
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
        }
    }
}
function createPrimitiveKey(primitiveDef) {
    var geometryKey;
    var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    if (dracoExtension) {
        geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
    } else {
        geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
    }
    if (primitiveDef.targets !== void 0) {
        for(var i = 0, il = primitiveDef.targets.length; i < il; i++){
            geometryKey += ":" + createAttributesKey(primitiveDef.targets[i]);
        }
    }
    return geometryKey;
}
function createAttributesKey(attributes) {
    var attributesKey = "";
    var keys = Object.keys(attributes).sort();
    for(var i = 0, il = keys.length; i < il; i++){
        attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
    }
    return attributesKey;
}
function getNormalizedComponentScale(constructor) {
    switch(constructor){
        case Int8Array:
            return 1 / 127;
        case Uint8Array:
            return 1 / 255;
        case Int16Array:
            return 1 / 32767;
        case Uint16Array:
            return 1 / 65535;
        default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
}
function getImageURIMimeType(uri) {
    if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0) return "image/jpeg";
    if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0) return "image/webp";
    return "image/png";
}
var _identityMatrix = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
var GLTFParser = /*#__PURE__*/ function() {
    "use strict";
    function GLTFParser() {
        var json = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GLTFParser);
        this.json = json;
        this.extensions = {};
        this.plugins = {};
        this.options = options;
        this.cache = new GLTFRegistry();
        this.associations = /* @__PURE__ */ new Map();
        this.primitiveCache = {};
        this.nodeCache = {};
        this.meshCache = {
            refs: {},
            uses: {}
        };
        this.cameraCache = {
            refs: {},
            uses: {}
        };
        this.lightCache = {
            refs: {},
            uses: {}
        };
        this.sourceCache = {};
        this.textureCache = {};
        this.nodeNamesUsed = {};
        var isSafari = false;
        var isFirefox = false;
        var firefoxVersion = -1;
        if (typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined") {
            isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;
            isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
            firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
        }
        if (typeof createImageBitmap === "undefined" || isSafari || isFirefox && firefoxVersion < 98) {
            this.textureLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureLoader"](this.options.manager);
        } else {
            this.textureLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ImageBitmapLoader"](this.options.manager);
        }
        this.textureLoader.setCrossOrigin(this.options.crossOrigin);
        this.textureLoader.setRequestHeader(this.options.requestHeader);
        this.fileLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.options.manager);
        this.fileLoader.setResponseType("arraybuffer");
        if (this.options.crossOrigin === "use-credentials") {
            this.fileLoader.setWithCredentials(true);
        }
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GLTFParser, [
        {
            key: "setExtensions",
            value: function setExtensions(extensions) {
                this.extensions = extensions;
            }
        },
        {
            key: "setPlugins",
            value: function setPlugins(plugins) {
                this.plugins = plugins;
            }
        },
        {
            key: "parse",
            value: function parse(onLoad, onError) {
                var parser = this;
                var json = this.json;
                var extensions = this.extensions;
                this.cache.removeAll();
                this.nodeCache = {};
                this._invokeAll(function(ext) {
                    return ext._markDefs && ext._markDefs();
                });
                Promise.all(this._invokeAll(function(ext) {
                    return ext.beforeRoot && ext.beforeRoot();
                })).then(function() {
                    return Promise.all([
                        parser.getDependencies("scene"),
                        parser.getDependencies("animation"),
                        parser.getDependencies("camera")
                    ]);
                }).then(function(dependencies) {
                    var result = {
                        scene: dependencies[0][json.scene || 0],
                        scenes: dependencies[0],
                        animations: dependencies[1],
                        cameras: dependencies[2],
                        asset: json.asset,
                        parser: parser,
                        userData: {}
                    };
                    addUnknownExtensionsToUserData(extensions, result, json);
                    assignExtrasToUserData(result, json);
                    return Promise.all(parser._invokeAll(function(ext) {
                        return ext.afterRoot && ext.afterRoot(result);
                    })).then(function() {
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = result.scenes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var scene = _step.value;
                                scene.updateMatrixWorld();
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                                    _iterator["return"]();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        onLoad(result);
                    });
                })["catch"](onError);
            }
        },
        {
            /**
   * Marks the special nodes/meshes in json for efficient parse.
   */ key: "_markDefs",
            value: function _markDefs() {
                var nodeDefs = this.json.nodes || [];
                var skinDefs = this.json.skins || [];
                var meshDefs = this.json.meshes || [];
                for(var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++){
                    var joints = skinDefs[skinIndex].joints;
                    for(var i = 0, il = joints.length; i < il; i++){
                        nodeDefs[joints[i]].isBone = true;
                    }
                }
                for(var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){
                    var nodeDef = nodeDefs[nodeIndex];
                    if (nodeDef.mesh !== void 0) {
                        this._addNodeRef(this.meshCache, nodeDef.mesh);
                        if (nodeDef.skin !== void 0) {
                            meshDefs[nodeDef.mesh].isSkinnedMesh = true;
                        }
                    }
                    if (nodeDef.camera !== void 0) {
                        this._addNodeRef(this.cameraCache, nodeDef.camera);
                    }
                }
            }
        },
        {
            /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */ key: "_addNodeRef",
            value: function _addNodeRef(cache, index) {
                if (index === void 0) return;
                if (cache.refs[index] === void 0) {
                    cache.refs[index] = cache.uses[index] = 0;
                }
                cache.refs[index]++;
            }
        },
        {
            /** Returns a reference to a shared resource, cloning it if necessary. */ key: "_getNodeRef",
            value: function _getNodeRef(cache, index, object) {
                var _this = this;
                if (cache.refs[index] <= 1) return object;
                var ref = object.clone();
                var updateMappings = function(original, clone) {
                    var mappings = _this.associations.get(original);
                    if (mappings != null) {
                        _this.associations.set(clone, mappings);
                    }
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = original.children.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var _step_value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_step.value, 2), i = _step_value[0], child = _step_value[1];
                            updateMappings(child, clone.children[i]);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                                _iterator["return"]();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                };
                updateMappings(object, ref);
                ref.name += "_instance_" + cache.uses[index]++;
                return ref;
            }
        },
        {
            key: "_invokeOne",
            value: function _invokeOne(func) {
                var extensions = Object.values(this.plugins);
                extensions.push(this);
                for(var i = 0; i < extensions.length; i++){
                    var result = func(extensions[i]);
                    if (result) return result;
                }
                return null;
            }
        },
        {
            key: "_invokeAll",
            value: function _invokeAll(func) {
                var extensions = Object.values(this.plugins);
                extensions.unshift(this);
                var pending = [];
                for(var i = 0; i < extensions.length; i++){
                    var result = func(extensions[i]);
                    if (result) pending.push(result);
                }
                return pending;
            }
        },
        {
            /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */ key: "getDependency",
            value: function getDependency(type, index) {
                var cacheKey = type + ":" + index;
                var dependency = this.cache.get(cacheKey);
                if (!dependency) {
                    switch(type){
                        case "scene":
                            dependency = this.loadScene(index);
                            break;
                        case "node":
                            dependency = this._invokeOne(function(ext) {
                                return ext.loadNode && ext.loadNode(index);
                            });
                            break;
                        case "mesh":
                            dependency = this._invokeOne(function(ext) {
                                return ext.loadMesh && ext.loadMesh(index);
                            });
                            break;
                        case "accessor":
                            dependency = this.loadAccessor(index);
                            break;
                        case "bufferView":
                            dependency = this._invokeOne(function(ext) {
                                return ext.loadBufferView && ext.loadBufferView(index);
                            });
                            break;
                        case "buffer":
                            dependency = this.loadBuffer(index);
                            break;
                        case "material":
                            dependency = this._invokeOne(function(ext) {
                                return ext.loadMaterial && ext.loadMaterial(index);
                            });
                            break;
                        case "texture":
                            dependency = this._invokeOne(function(ext) {
                                return ext.loadTexture && ext.loadTexture(index);
                            });
                            break;
                        case "skin":
                            dependency = this.loadSkin(index);
                            break;
                        case "animation":
                            dependency = this._invokeOne(function(ext) {
                                return ext.loadAnimation && ext.loadAnimation(index);
                            });
                            break;
                        case "camera":
                            dependency = this.loadCamera(index);
                            break;
                        default:
                            dependency = this._invokeOne(function(ext) {
                                return ext != this && ext.getDependency && ext.getDependency(type, index);
                            });
                            if (!dependency) {
                                throw new Error("Unknown type: " + type);
                            }
                            break;
                    }
                    this.cache.add(cacheKey, dependency);
                }
                return dependency;
            }
        },
        {
            /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */ key: "getDependencies",
            value: function getDependencies(type) {
                var dependencies = this.cache.get(type);
                if (!dependencies) {
                    var parser = this;
                    var defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
                    dependencies = Promise.all(defs.map(function(def, index) {
                        return parser.getDependency(type, index);
                    }));
                    this.cache.add(type, dependencies);
                }
                return dependencies;
            }
        },
        {
            /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */ key: "loadBuffer",
            value: function loadBuffer(bufferIndex) {
                var bufferDef = this.json.buffers[bufferIndex];
                var loader = this.fileLoader;
                if (bufferDef.type && bufferDef.type !== "arraybuffer") {
                    throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
                }
                if (bufferDef.uri === void 0 && bufferIndex === 0) {
                    return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
                }
                var options = this.options;
                return new Promise(function(resolve, reject) {
                    loader.load(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
                        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
                    });
                });
            }
        },
        {
            /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */ key: "loadBufferView",
            value: function loadBufferView(bufferViewIndex) {
                var bufferViewDef = this.json.bufferViews[bufferViewIndex];
                return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
                    var byteLength = bufferViewDef.byteLength || 0;
                    var byteOffset = bufferViewDef.byteOffset || 0;
                    return buffer.slice(byteOffset, byteOffset + byteLength);
                });
            }
        },
        {
            /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */ key: "loadAccessor",
            value: function loadAccessor(accessorIndex) {
                var parser = this;
                var json = this.json;
                var accessorDef = this.json.accessors[accessorIndex];
                if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
                    var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
                    var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
                    var normalized = accessorDef.normalized === true;
                    var array = new TypedArray(accessorDef.count * itemSize);
                    return Promise.resolve(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](array, itemSize, normalized));
                }
                var pendingBufferViews = [];
                if (accessorDef.bufferView !== void 0) {
                    pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
                } else {
                    pendingBufferViews.push(null);
                }
                if (accessorDef.sparse !== void 0) {
                    pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
                    pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
                }
                return Promise.all(pendingBufferViews).then(function(bufferViews) {
                    var bufferView = bufferViews[0];
                    var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
                    var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
                    var elementBytes = TypedArray.BYTES_PER_ELEMENT;
                    var itemBytes = elementBytes * itemSize;
                    var byteOffset = accessorDef.byteOffset || 0;
                    var byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
                    var normalized = accessorDef.normalized === true;
                    var array, bufferAttribute;
                    if (byteStride && byteStride !== itemBytes) {
                        var ibSlice = Math.floor(byteOffset / byteStride);
                        var ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
                        var ib = parser.cache.get(ibCacheKey);
                        if (!ib) {
                            array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
                            ib = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBuffer"](array, byteStride / elementBytes);
                            parser.cache.add(ibCacheKey, ib);
                        }
                        bufferAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBufferAttribute"](ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
                    } else {
                        if (bufferView === null) {
                            array = new TypedArray(accessorDef.count * itemSize);
                        } else {
                            array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
                        }
                        bufferAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](array, itemSize, normalized);
                    }
                    if (accessorDef.sparse !== void 0) {
                        var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
                        var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
                        var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
                        var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
                        var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
                        var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
                        if (bufferView !== null) {
                            bufferAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
                        }
                        for(var i = 0, il = sparseIndices.length; i < il; i++){
                            var index = sparseIndices[i];
                            bufferAttribute.setX(index, sparseValues[i * itemSize]);
                            if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
                            if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
                            if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
                            if (itemSize >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
                        }
                    }
                    return bufferAttribute;
                });
            }
        },
        {
            /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */ key: "loadTexture",
            value: function loadTexture(textureIndex) {
                var json = this.json;
                var options = this.options;
                var textureDef = json.textures[textureIndex];
                var sourceIndex = textureDef.source;
                var sourceDef = json.images[sourceIndex];
                var loader = this.textureLoader;
                if (sourceDef.uri) {
                    var handler = options.manager.getHandler(sourceDef.uri);
                    if (handler !== null) loader = handler;
                }
                return this.loadTextureImage(textureIndex, sourceIndex, loader);
            }
        },
        {
            key: "loadTextureImage",
            value: function loadTextureImage(textureIndex, sourceIndex, loader) {
                var parser = this;
                var json = this.json;
                var textureDef = json.textures[textureIndex];
                var sourceDef = json.images[sourceIndex];
                var cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
                if (this.textureCache[cacheKey]) {
                    return this.textureCache[cacheKey];
                }
                var promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
                    texture.flipY = false;
                    texture.name = textureDef.name || sourceDef.name || "";
                    if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
                        texture.name = sourceDef.uri;
                    }
                    var samplers = json.samplers || {};
                    var sampler = samplers[textureDef.sampler] || {};
                    texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                    texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearMipmapLinearFilter"];
                    texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
                    texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
                    parser.associations.set(texture, {
                        textures: textureIndex
                    });
                    return texture;
                })["catch"](function() {
                    return null;
                });
                this.textureCache[cacheKey] = promise;
                return promise;
            }
        },
        {
            key: "loadImageSource",
            value: function loadImageSource(sourceIndex, loader) {
                var parser = this;
                var json = this.json;
                var options = this.options;
                if (this.sourceCache[sourceIndex] !== void 0) {
                    return this.sourceCache[sourceIndex].then(function(texture) {
                        return texture.clone();
                    });
                }
                var sourceDef = json.images[sourceIndex];
                var URL = self.URL || self.webkitURL;
                var sourceURI = sourceDef.uri || "";
                var isObjectURL = false;
                if (sourceDef.bufferView !== void 0) {
                    sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
                        isObjectURL = true;
                        var blob = new Blob([
                            bufferView
                        ], {
                            type: sourceDef.mimeType
                        });
                        sourceURI = URL.createObjectURL(blob);
                        return sourceURI;
                    });
                } else if (sourceDef.uri === void 0) {
                    throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
                }
                var promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
                    return new Promise(function(resolve, reject) {
                        var onLoad = resolve;
                        if (loader.isImageBitmapLoader === true) {
                            onLoad = function onLoad(imageBitmap) {
                                var texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"](imageBitmap);
                                texture.needsUpdate = true;
                                resolve(texture);
                            };
                        }
                        loader.load(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
                    });
                }).then(function(texture) {
                    if (isObjectURL === true) {
                        URL.revokeObjectURL(sourceURI);
                    }
                    assignExtrasToUserData(texture, sourceDef);
                    texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
                    return texture;
                })["catch"](function(error) {
                    console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
                    throw error;
                });
                this.sourceCache[sourceIndex] = promise;
                return promise;
            }
        },
        {
            /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */ key: "assignTexture",
            value: function assignTexture(materialParams, mapName, mapDef, colorSpace) {
                var parser = this;
                return this.getDependency("texture", mapDef.index).then(function(texture) {
                    if (!texture) return null;
                    if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
                        texture = texture.clone();
                        texture.channel = mapDef.texCoord;
                    }
                    if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
                        var transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (transform) {
                            var gltfReference = parser.associations.get(texture);
                            texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
                            parser.associations.set(texture, gltfReference);
                        }
                    }
                    if (colorSpace !== void 0) {
                        if (typeof colorSpace === "number") colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;
                        if ("colorSpace" in texture) texture.colorSpace = colorSpace;
                        else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
                    }
                    materialParams[mapName] = texture;
                    return texture;
                });
            }
        },
        {
            /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */ key: "assignFinalMaterial",
            value: function assignFinalMaterial(mesh) {
                var geometry = mesh.geometry;
                var material = mesh.material;
                var useDerivativeTangents = geometry.attributes.tangent === void 0;
                var useVertexColors = geometry.attributes.color !== void 0;
                var useFlatShading = geometry.attributes.normal === void 0;
                if (mesh.isPoints) {
                    var cacheKey = "PointsMaterial:" + material.uuid;
                    var pointsMaterial = this.cache.get(cacheKey);
                    if (!pointsMaterial) {
                        pointsMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointsMaterial"]();
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"].prototype.copy.call(pointsMaterial, material);
                        pointsMaterial.color.copy(material.color);
                        pointsMaterial.map = material.map;
                        pointsMaterial.sizeAttenuation = false;
                        this.cache.add(cacheKey, pointsMaterial);
                    }
                    material = pointsMaterial;
                } else if (mesh.isLine) {
                    var cacheKey1 = "LineBasicMaterial:" + material.uuid;
                    var lineMaterial = this.cache.get(cacheKey1);
                    if (!lineMaterial) {
                        lineMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]();
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"].prototype.copy.call(lineMaterial, material);
                        lineMaterial.color.copy(material.color);
                        lineMaterial.map = material.map;
                        this.cache.add(cacheKey1, lineMaterial);
                    }
                    material = lineMaterial;
                }
                if (useDerivativeTangents || useVertexColors || useFlatShading) {
                    var cacheKey2 = "ClonedMaterial:" + material.uuid + ":";
                    if (useDerivativeTangents) cacheKey2 += "derivative-tangents:";
                    if (useVertexColors) cacheKey2 += "vertex-colors:";
                    if (useFlatShading) cacheKey2 += "flat-shading:";
                    var cachedMaterial = this.cache.get(cacheKey2);
                    if (!cachedMaterial) {
                        cachedMaterial = material.clone();
                        if (useVertexColors) cachedMaterial.vertexColors = true;
                        if (useFlatShading) cachedMaterial.flatShading = true;
                        if (useDerivativeTangents) {
                            if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
                            if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;
                        }
                        this.cache.add(cacheKey2, cachedMaterial);
                        this.associations.set(cachedMaterial, this.associations.get(material));
                    }
                    material = cachedMaterial;
                }
                mesh.material = material;
            }
        },
        {
            key: "getMaterialType",
            value: function getMaterialType() {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"];
            }
        },
        {
            /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */ key: "loadMaterial",
            value: function loadMaterial(materialIndex) {
                var parser = this;
                var json = this.json;
                var extensions = this.extensions;
                var materialDef = json.materials[materialIndex];
                var materialType;
                var materialParams = {};
                var materialExtensions = materialDef.extensions || {};
                var pending = [];
                if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
                    var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
                    materialType = kmuExtension.getMaterialType();
                    pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
                } else {
                    var metallicRoughness = materialDef.pbrMetallicRoughness || {};
                    materialParams.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](1, 1, 1);
                    materialParams.opacity = 1;
                    if (Array.isArray(metallicRoughness.baseColorFactor)) {
                        var array = metallicRoughness.baseColorFactor;
                        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
                        materialParams.opacity = array[3];
                    }
                    if (metallicRoughness.baseColorTexture !== void 0) {
                        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
                    }
                    materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
                    materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
                    if (metallicRoughness.metallicRoughnessTexture !== void 0) {
                        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
                        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
                    }
                    materialType = this._invokeOne(function(ext) {
                        return ext.getMaterialType && ext.getMaterialType(materialIndex);
                    });
                    pending.push(Promise.all(this._invokeAll(function(ext) {
                        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
                    })));
                }
                if (materialDef.doubleSided === true) {
                    materialParams.side = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"];
                }
                var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
                if (alphaMode === ALPHA_MODES.BLEND) {
                    materialParams.transparent = true;
                    materialParams.depthWrite = false;
                } else {
                    materialParams.transparent = false;
                    if (alphaMode === ALPHA_MODES.MASK) {
                        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
                    }
                }
                if (materialDef.normalTexture !== void 0 && materialType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]) {
                    pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
                    materialParams.normalScale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](1, 1);
                    if (materialDef.normalTexture.scale !== void 0) {
                        var scale = materialDef.normalTexture.scale;
                        materialParams.normalScale.set(scale, scale);
                    }
                }
                if (materialDef.occlusionTexture !== void 0 && materialType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]) {
                    pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
                    if (materialDef.occlusionTexture.strength !== void 0) {
                        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
                    }
                }
                if (materialDef.emissiveFactor !== void 0 && materialType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]) {
                    var emissiveFactor = materialDef.emissiveFactor;
                    materialParams.emissive = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);
                }
                if (materialDef.emissiveTexture !== void 0 && materialType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]) {
                    pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
                }
                return Promise.all(pending).then(function() {
                    var material = new materialType(materialParams);
                    if (materialDef.name) material.name = materialDef.name;
                    assignExtrasToUserData(material, materialDef);
                    parser.associations.set(material, {
                        materials: materialIndex
                    });
                    if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
                    return material;
                });
            }
        },
        {
            /** When Object3D instances are targeted by animation, they need unique names. */ key: "createUniqueName",
            value: function createUniqueName(originalName) {
                var sanitizedName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PropertyBinding"].sanitizeNodeName(originalName || "");
                if (sanitizedName in this.nodeNamesUsed) {
                    return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
                } else {
                    this.nodeNamesUsed[sanitizedName] = 0;
                    return sanitizedName;
                }
            }
        },
        {
            /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */ key: "loadGeometries",
            value: function loadGeometries(primitives) {
                var parser = this;
                var extensions = this.extensions;
                var cache = this.primitiveCache;
                function createDracoPrimitive(primitive) {
                    return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
                        return addPrimitiveAttributes(geometry, primitive, parser);
                    });
                }
                var pending = [];
                for(var i = 0, il = primitives.length; i < il; i++){
                    var primitive = primitives[i];
                    var cacheKey = createPrimitiveKey(primitive);
                    var cached = cache[cacheKey];
                    if (cached) {
                        pending.push(cached.promise);
                    } else {
                        var geometryPromise = void 0;
                        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
                            geometryPromise = createDracoPrimitive(primitive);
                        } else {
                            geometryPromise = addPrimitiveAttributes(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"](), primitive, parser);
                        }
                        cache[cacheKey] = {
                            primitive: primitive,
                            promise: geometryPromise
                        };
                        pending.push(geometryPromise);
                    }
                }
                return Promise.all(pending);
            }
        },
        {
            /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */ key: "loadMesh",
            value: function loadMesh(meshIndex) {
                var parser = this;
                var json = this.json;
                var extensions = this.extensions;
                var meshDef = json.meshes[meshIndex];
                var primitives = meshDef.primitives;
                var pending = [];
                for(var i = 0, il = primitives.length; i < il; i++){
                    var material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
                    pending.push(material);
                }
                pending.push(parser.loadGeometries(primitives));
                return Promise.all(pending).then(function(results) {
                    var materials = results.slice(0, results.length - 1);
                    var geometries = results[results.length - 1];
                    var meshes = [];
                    for(var i = 0, il = geometries.length; i < il; i++){
                        var geometry = geometries[i];
                        var primitive = primitives[i];
                        var mesh = void 0;
                        var material = materials[i];
                        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
                            mesh = meshDef.isSkinnedMesh === true ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SkinnedMesh"](geometry, material) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, material);
                            if (mesh.isSkinnedMesh === true) {
                                mesh.normalizeSkinWeights();
                            }
                            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
                                mesh.geometry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$BufferGeometryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toTrianglesDrawMode"])(mesh.geometry, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TriangleStripDrawMode"]);
                            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
                                mesh.geometry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$BufferGeometryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toTrianglesDrawMode"])(mesh.geometry, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TriangleFanDrawMode"]);
                            }
                        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
                            mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineSegments"](geometry, material);
                        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
                            mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"](geometry, material);
                        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
                            mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineLoop"](geometry, material);
                        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
                            mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Points"](geometry, material);
                        } else {
                            throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
                        }
                        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
                            updateMorphTargets(mesh, meshDef);
                        }
                        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
                        assignExtrasToUserData(mesh, meshDef);
                        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);
                        parser.assignFinalMaterial(mesh);
                        meshes.push(mesh);
                    }
                    for(var i1 = 0, il1 = meshes.length; i1 < il1; i1++){
                        parser.associations.set(meshes[i1], {
                            meshes: meshIndex,
                            primitives: i1
                        });
                    }
                    if (meshes.length === 1) {
                        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
                        return meshes[0];
                    }
                    var group = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
                    if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);
                    parser.associations.set(group, {
                        meshes: meshIndex
                    });
                    for(var i2 = 0, il2 = meshes.length; i2 < il2; i2++){
                        group.add(meshes[i2]);
                    }
                    return group;
                });
            }
        },
        {
            /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */ key: "loadCamera",
            value: function loadCamera(cameraIndex) {
                var camera;
                var cameraDef = this.json.cameras[cameraIndex];
                var params = cameraDef[cameraDef.type];
                if (!params) {
                    console.warn("THREE.GLTFLoader: Missing camera parameters.");
                    return;
                }
                if (cameraDef.type === "perspective") {
                    camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
                } else if (cameraDef.type === "orthographic") {
                    camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrthographicCamera"](-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
                }
                if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);
                assignExtrasToUserData(camera, cameraDef);
                return Promise.resolve(camera);
            }
        },
        {
            /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */ key: "loadSkin",
            value: function loadSkin(skinIndex) {
                var skinDef = this.json.skins[skinIndex];
                var pending = [];
                for(var i = 0, il = skinDef.joints.length; i < il; i++){
                    pending.push(this._loadNodeShallow(skinDef.joints[i]));
                }
                if (skinDef.inverseBindMatrices !== void 0) {
                    pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
                } else {
                    pending.push(null);
                }
                return Promise.all(pending).then(function(results) {
                    var inverseBindMatrices = results.pop();
                    var jointNodes = results;
                    var bones = [];
                    var boneInverses = [];
                    for(var i = 0, il = jointNodes.length; i < il; i++){
                        var jointNode = jointNodes[i];
                        if (jointNode) {
                            bones.push(jointNode);
                            var mat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
                            if (inverseBindMatrices !== null) {
                                mat.fromArray(inverseBindMatrices.array, i * 16);
                            }
                            boneInverses.push(mat);
                        } else {
                            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i]);
                        }
                    }
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Skeleton"](bones, boneInverses);
                });
            }
        },
        {
            /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */ key: "loadAnimation",
            value: function loadAnimation(animationIndex) {
                var json = this.json;
                var parser = this;
                var animationDef = json.animations[animationIndex];
                var animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
                var pendingNodes = [];
                var pendingInputAccessors = [];
                var pendingOutputAccessors = [];
                var pendingSamplers = [];
                var pendingTargets = [];
                for(var i = 0, il = animationDef.channels.length; i < il; i++){
                    var channel = animationDef.channels[i];
                    var sampler = animationDef.samplers[channel.sampler];
                    var target = channel.target;
                    var name = target.node;
                    var input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
                    var output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
                    if (target.node === void 0) continue;
                    pendingNodes.push(this.getDependency("node", name));
                    pendingInputAccessors.push(this.getDependency("accessor", input));
                    pendingOutputAccessors.push(this.getDependency("accessor", output));
                    pendingSamplers.push(sampler);
                    pendingTargets.push(target);
                }
                return Promise.all([
                    Promise.all(pendingNodes),
                    Promise.all(pendingInputAccessors),
                    Promise.all(pendingOutputAccessors),
                    Promise.all(pendingSamplers),
                    Promise.all(pendingTargets)
                ]).then(function(dependencies) {
                    var nodes = dependencies[0];
                    var inputAccessors = dependencies[1];
                    var outputAccessors = dependencies[2];
                    var samplers = dependencies[3];
                    var targets = dependencies[4];
                    var tracks = [];
                    for(var i = 0, il = nodes.length; i < il; i++){
                        var node = nodes[i];
                        var inputAccessor = inputAccessors[i];
                        var outputAccessor = outputAccessors[i];
                        var sampler = samplers[i];
                        var target = targets[i];
                        if (node === void 0) continue;
                        if (node.updateMatrix) {
                            node.updateMatrix();
                        }
                        var createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
                        if (createdTracks) {
                            for(var k = 0; k < createdTracks.length; k++){
                                tracks.push(createdTracks[k]);
                            }
                        }
                    }
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"](animationName, void 0, tracks);
                });
            }
        },
        {
            key: "createNodeMesh",
            value: function createNodeMesh(nodeIndex) {
                var json = this.json;
                var parser = this;
                var nodeDef = json.nodes[nodeIndex];
                if (nodeDef.mesh === void 0) return null;
                return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
                    var node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
                    if (nodeDef.weights !== void 0) {
                        node.traverse(function(o) {
                            if (!o.isMesh) return;
                            for(var i = 0, il = nodeDef.weights.length; i < il; i++){
                                o.morphTargetInfluences[i] = nodeDef.weights[i];
                            }
                        });
                    }
                    return node;
                });
            }
        },
        {
            /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */ key: "loadNode",
            value: function loadNode(nodeIndex) {
                var json = this.json;
                var parser = this;
                var nodeDef = json.nodes[nodeIndex];
                var nodePending = parser._loadNodeShallow(nodeIndex);
                var childPending = [];
                var childrenDef = nodeDef.children || [];
                for(var i = 0, il = childrenDef.length; i < il; i++){
                    childPending.push(parser.getDependency("node", childrenDef[i]));
                }
                var skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
                return Promise.all([
                    nodePending,
                    Promise.all(childPending),
                    skeletonPending
                ]).then(function(results) {
                    var node = results[0];
                    var children = results[1];
                    var skeleton = results[2];
                    if (skeleton !== null) {
                        node.traverse(function(mesh) {
                            if (!mesh.isSkinnedMesh) return;
                            mesh.bind(skeleton, _identityMatrix);
                        });
                    }
                    for(var i = 0, il = children.length; i < il; i++){
                        node.add(children[i]);
                    }
                    return node;
                });
            }
        },
        {
            // ._loadNodeShallow() parses a single node.
            // skin and child nodes are created and added in .loadNode() (no '_' prefix).
            key: "_loadNodeShallow",
            value: function _loadNodeShallow(nodeIndex) {
                var json = this.json;
                var extensions = this.extensions;
                var parser = this;
                if (this.nodeCache[nodeIndex] !== void 0) {
                    return this.nodeCache[nodeIndex];
                }
                var nodeDef = json.nodes[nodeIndex];
                var nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
                var pending = [];
                var meshPromise = parser._invokeOne(function(ext) {
                    return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
                });
                if (meshPromise) {
                    pending.push(meshPromise);
                }
                if (nodeDef.camera !== void 0) {
                    pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
                        return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
                    }));
                }
                parser._invokeAll(function(ext) {
                    return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
                }).forEach(function(promise) {
                    pending.push(promise);
                });
                this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
                    var node;
                    if (nodeDef.isBone === true) {
                        node = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Bone"]();
                    } else if (objects.length > 1) {
                        node = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
                    } else if (objects.length === 1) {
                        node = objects[0];
                    } else {
                        node = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"]();
                    }
                    if (node !== objects[0]) {
                        for(var i = 0, il = objects.length; i < il; i++){
                            node.add(objects[i]);
                        }
                    }
                    if (nodeDef.name) {
                        node.userData.name = nodeDef.name;
                        node.name = nodeName;
                    }
                    assignExtrasToUserData(node, nodeDef);
                    if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);
                    if (nodeDef.matrix !== void 0) {
                        var matrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
                        matrix.fromArray(nodeDef.matrix);
                        node.applyMatrix4(matrix);
                    } else {
                        if (nodeDef.translation !== void 0) {
                            node.position.fromArray(nodeDef.translation);
                        }
                        if (nodeDef.rotation !== void 0) {
                            node.quaternion.fromArray(nodeDef.rotation);
                        }
                        if (nodeDef.scale !== void 0) {
                            node.scale.fromArray(nodeDef.scale);
                        }
                    }
                    if (!parser.associations.has(node)) {
                        parser.associations.set(node, {});
                    }
                    parser.associations.get(node).nodes = nodeIndex;
                    return node;
                });
                return this.nodeCache[nodeIndex];
            }
        },
        {
            /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */ key: "loadScene",
            value: function loadScene(sceneIndex) {
                var extensions = this.extensions;
                var sceneDef = this.json.scenes[sceneIndex];
                var parser = this;
                var scene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
                if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);
                assignExtrasToUserData(scene, sceneDef);
                if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
                var nodeIds = sceneDef.nodes || [];
                var pending = [];
                for(var i = 0, il = nodeIds.length; i < il; i++){
                    pending.push(parser.getDependency("node", nodeIds[i]));
                }
                return Promise.all(pending).then(function(nodes) {
                    for(var i = 0, il = nodes.length; i < il; i++){
                        scene.add(nodes[i]);
                    }
                    var reduceAssociations = function(node) {
                        var reducedAssociations = /* @__PURE__ */ new Map();
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = parser.associations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var _step_value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_step.value, 2), key = _step_value[0], value = _step_value[1];
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(key, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"]) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(key, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"])) {
                                    reducedAssociations.set(key, value);
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                                    _iterator["return"]();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        node.traverse(function(node2) {
                            var mappings = parser.associations.get(node2);
                            if (mappings != null) {
                                reducedAssociations.set(node2, mappings);
                            }
                        });
                        return reducedAssociations;
                    };
                    parser.associations = reduceAssociations(scene);
                    return scene;
                });
            }
        },
        {
            key: "_createAnimationTracks",
            value: function _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
                var tracks = [];
                var targetName = node.name ? node.name : node.uuid;
                var targetNames = [];
                if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
                    node.traverse(function(object) {
                        if (object.morphTargetInfluences) {
                            targetNames.push(object.name ? object.name : object.uuid);
                        }
                    });
                } else {
                    targetNames.push(targetName);
                }
                var TypedKeyframeTrack;
                switch(PATH_PROPERTIES[target.path]){
                    case PATH_PROPERTIES.weights:
                        TypedKeyframeTrack = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NumberKeyframeTrack"];
                        break;
                    case PATH_PROPERTIES.rotation:
                        TypedKeyframeTrack = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QuaternionKeyframeTrack"];
                        break;
                    case PATH_PROPERTIES.position:
                    case PATH_PROPERTIES.scale:
                        TypedKeyframeTrack = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"];
                        break;
                    default:
                        switch(outputAccessor.itemSize){
                            case 1:
                                TypedKeyframeTrack = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NumberKeyframeTrack"];
                                break;
                            case 2:
                            case 3:
                            default:
                                TypedKeyframeTrack = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"];
                                break;
                        }
                        break;
                }
                var interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterpolateLinear"];
                var outputArray = this._getArrayFromAccessor(outputAccessor);
                for(var j = 0, jl = targetNames.length; j < jl; j++){
                    var track = new TypedKeyframeTrack(targetNames[j] + "." + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);
                    if (sampler.interpolation === "CUBICSPLINE") {
                        this._createCubicSplineTrackInterpolant(track);
                    }
                    tracks.push(track);
                }
                return tracks;
            }
        },
        {
            key: "_getArrayFromAccessor",
            value: function _getArrayFromAccessor(accessor) {
                var outputArray = accessor.array;
                if (accessor.normalized) {
                    var scale = getNormalizedComponentScale(outputArray.constructor);
                    var scaled = new Float32Array(outputArray.length);
                    for(var j = 0, jl = outputArray.length; j < jl; j++){
                        scaled[j] = outputArray[j] * scale;
                    }
                    outputArray = scaled;
                }
                return outputArray;
            }
        },
        {
            key: "_createCubicSplineTrackInterpolant",
            value: function _createCubicSplineTrackInterpolant(track) {
                track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
                    var interpolantType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QuaternionKeyframeTrack"]) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
                    return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
                };
                track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
            }
        }
    ]);
    return GLTFParser;
}();
function computeBounds(geometry, primitiveDef, parser) {
    var attributes = primitiveDef.attributes;
    var box = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
    if (attributes.POSITION !== void 0) {
        var accessor = parser.json.accessors[attributes.POSITION];
        var min = accessor.min;
        var max = accessor.max;
        if (min !== void 0 && max !== void 0) {
            box.set(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](min[0], min[1], min[2]), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](max[0], max[1], max[2]));
            if (accessor.normalized) {
                var boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
                box.min.multiplyScalar(boxScale);
                box.max.multiplyScalar(boxScale);
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return;
        }
    } else {
        return;
    }
    var targets = primitiveDef.targets;
    if (targets !== void 0) {
        var maxDisplacement = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        var vector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        for(var i = 0, il = targets.length; i < il; i++){
            var target = targets[i];
            if (target.POSITION !== void 0) {
                var accessor1 = parser.json.accessors[target.POSITION];
                var min1 = accessor1.min;
                var max1 = accessor1.max;
                if (min1 !== void 0 && max1 !== void 0) {
                    vector.setX(Math.max(Math.abs(min1[0]), Math.abs(max1[0])));
                    vector.setY(Math.max(Math.abs(min1[1]), Math.abs(max1[1])));
                    vector.setZ(Math.max(Math.abs(min1[2]), Math.abs(max1[2])));
                    if (accessor1.normalized) {
                        var boxScale1 = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor1.componentType]);
                        vector.multiplyScalar(boxScale1);
                    }
                    maxDisplacement.max(vector);
                } else {
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                }
            }
        }
        box.expandByVector(maxDisplacement);
    }
    geometry.boundingBox = box;
    var sphere = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sphere"]();
    box.getCenter(sphere.center);
    sphere.radius = box.min.distanceTo(box.max) / 2;
    geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
    var attributes = primitiveDef.attributes;
    var pending = [];
    function assignAttributeAccessor(accessorIndex, attributeName) {
        return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
            geometry.setAttribute(attributeName, accessor);
        });
    }
    for(var gltfAttributeName in attributes){
        var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
        if (threeAttributeName in geometry.attributes) continue;
        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
    }
    if (primitiveDef.indices !== void 0 && !geometry.index) {
        var accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
            geometry.setIndex(accessor2);
        });
        pending.push(accessor);
    }
    assignExtrasToUserData(geometry, primitiveDef);
    computeBounds(geometry, primitiveDef, parser);
    return Promise.all(pending).then(function() {
        return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
    });
}
;
 //# sourceMappingURL=GLTFLoader.js.map
}),
"[project]/node_modules/three-stdlib/loaders/DRACOLoader.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DRACOLoader",
    ()=>DRACOLoader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_call_super.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_inherits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_type_of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
;
;
;
;
var _taskCache = /* @__PURE__ */ new WeakMap();
var DRACOLoader = /*#__PURE__*/ function(Loader) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(DRACOLoader, Loader);
    function DRACOLoader(manager) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, DRACOLoader);
        var _this;
        _this = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, DRACOLoader, [
            manager
        ]);
        _this.decoderPath = "";
        _this.decoderConfig = {};
        _this.decoderBinary = null;
        _this.decoderPending = null;
        _this.workerLimit = 4;
        _this.workerPool = [];
        _this.workerNextTaskID = 1;
        _this.workerSourceURL = "";
        _this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        };
        _this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        };
        return _this;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(DRACOLoader, [
        {
            key: "setDecoderPath",
            value: function setDecoderPath(path) {
                this.decoderPath = path;
                return this;
            }
        },
        {
            key: "setDecoderConfig",
            value: function setDecoderConfig(config) {
                this.decoderConfig = config;
                return this;
            }
        },
        {
            key: "setWorkerLimit",
            value: function setWorkerLimit(workerLimit) {
                this.workerLimit = workerLimit;
                return this;
            }
        },
        {
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
                var _this = this;
                var loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
                loader.setPath(this.path);
                loader.setResponseType("arraybuffer");
                loader.setRequestHeader(this.requestHeader);
                loader.setWithCredentials(this.withCredentials);
                loader.load(url, function(buffer) {
                    var taskConfig = {
                        attributeIDs: _this.defaultAttributeIDs,
                        attributeTypes: _this.defaultAttributeTypes,
                        useUniqueIDs: false
                    };
                    _this.decodeGeometry(buffer, taskConfig).then(onLoad)["catch"](onError);
                }, onProgress, onError);
            }
        },
        {
            /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */ key: "decodeDracoFile",
            value: function decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {
                var taskConfig = {
                    attributeIDs: attributeIDs || this.defaultAttributeIDs,
                    attributeTypes: attributeTypes || this.defaultAttributeTypes,
                    useUniqueIDs: !!attributeIDs
                };
                this.decodeGeometry(buffer, taskConfig).then(callback);
            }
        },
        {
            key: "decodeGeometry",
            value: function decodeGeometry(buffer, taskConfig) {
                var _this = this;
                for(var attribute in taskConfig.attributeTypes){
                    var type = taskConfig.attributeTypes[attribute];
                    if (type.BYTES_PER_ELEMENT !== void 0) {
                        taskConfig.attributeTypes[attribute] = type.name;
                    }
                }
                var taskKey = JSON.stringify(taskConfig);
                if (_taskCache.has(buffer)) {
                    var cachedTask = _taskCache.get(buffer);
                    if (cachedTask.key === taskKey) {
                        return cachedTask.promise;
                    } else if (buffer.byteLength === 0) {
                        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
                    }
                }
                var worker;
                var taskID = this.workerNextTaskID++;
                var taskCost = buffer.byteLength;
                var geometryPending = this._getWorker(taskID, taskCost).then(function(_worker) {
                    worker = _worker;
                    return new Promise(function(resolve, reject) {
                        worker._callbacks[taskID] = {
                            resolve: resolve,
                            reject: reject
                        };
                        worker.postMessage({
                            type: "decode",
                            id: taskID,
                            taskConfig: taskConfig,
                            buffer: buffer
                        }, [
                            buffer
                        ]);
                    });
                }).then(function(message) {
                    return _this._createGeometry(message.geometry);
                });
                geometryPending["catch"](function() {
                    return true;
                }).then(function() {
                    if (worker && taskID) {
                        _this._releaseTask(worker, taskID);
                    }
                });
                _taskCache.set(buffer, {
                    key: taskKey,
                    promise: geometryPending
                });
                return geometryPending;
            }
        },
        {
            key: "_createGeometry",
            value: function _createGeometry(geometryData) {
                var geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
                if (geometryData.index) {
                    geometry.setIndex(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](geometryData.index.array, 1));
                }
                for(var i = 0; i < geometryData.attributes.length; i++){
                    var attribute = geometryData.attributes[i];
                    var name = attribute.name;
                    var array = attribute.array;
                    var itemSize = attribute.itemSize;
                    geometry.setAttribute(name, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](array, itemSize));
                }
                return geometry;
            }
        },
        {
            key: "_loadLibrary",
            value: function _loadLibrary(url, responseType) {
                var loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
                loader.setPath(this.decoderPath);
                loader.setResponseType(responseType);
                loader.setWithCredentials(this.withCredentials);
                return new Promise(function(resolve, reject) {
                    loader.load(url, resolve, void 0, reject);
                });
            }
        },
        {
            key: "preload",
            value: function preload() {
                this._initDecoder();
                return this;
            }
        },
        {
            key: "_initDecoder",
            value: function _initDecoder() {
                var _this = this;
                if (this.decoderPending) return this.decoderPending;
                var useJS = (typeof WebAssembly === "undefined" ? "undefined" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(WebAssembly)) !== "object" || this.decoderConfig.type === "js";
                var librariesPending = [];
                if (useJS) {
                    librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
                } else {
                    librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
                    librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
                }
                this.decoderPending = Promise.all(librariesPending).then(function(libraries) {
                    var jsContent = libraries[0];
                    if (!useJS) {
                        _this.decoderConfig.wasmBinary = libraries[1];
                    }
                    var fn = DRACOWorker.toString();
                    var body = [
                        "/* draco decoder */",
                        jsContent,
                        "",
                        "/* worker */",
                        fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
                    ].join("\n");
                    _this.workerSourceURL = URL.createObjectURL(new Blob([
                        body
                    ]));
                });
                return this.decoderPending;
            }
        },
        {
            key: "_getWorker",
            value: function _getWorker(taskID, taskCost) {
                var _this = this;
                return this._initDecoder().then(function() {
                    if (_this.workerPool.length < _this.workerLimit) {
                        var worker2 = new Worker(_this.workerSourceURL);
                        worker2._callbacks = {};
                        worker2._taskCosts = {};
                        worker2._taskLoad = 0;
                        worker2.postMessage({
                            type: "init",
                            decoderConfig: _this.decoderConfig
                        });
                        worker2.onmessage = function(e) {
                            var message = e.data;
                            switch(message.type){
                                case "decode":
                                    worker2._callbacks[message.id].resolve(message);
                                    break;
                                case "error":
                                    worker2._callbacks[message.id].reject(message);
                                    break;
                                default:
                                    console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
                            }
                        };
                        _this.workerPool.push(worker2);
                    } else {
                        _this.workerPool.sort(function(a, b) {
                            return a._taskLoad > b._taskLoad ? -1 : 1;
                        });
                    }
                    var worker = _this.workerPool[_this.workerPool.length - 1];
                    worker._taskCosts[taskID] = taskCost;
                    worker._taskLoad += taskCost;
                    return worker;
                });
            }
        },
        {
            key: "_releaseTask",
            value: function _releaseTask(worker, taskID) {
                worker._taskLoad -= worker._taskCosts[taskID];
                delete worker._callbacks[taskID];
                delete worker._taskCosts[taskID];
            }
        },
        {
            key: "debug",
            value: function debug() {
                console.log("Task load: ", this.workerPool.map(function(worker) {
                    return worker._taskLoad;
                }));
            }
        },
        {
            key: "dispose",
            value: function dispose() {
                for(var i = 0; i < this.workerPool.length; ++i){
                    this.workerPool[i].terminate();
                }
                this.workerPool.length = 0;
                return this;
            }
        }
    ]);
    return DRACOLoader;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"]);
function DRACOWorker() {
    var decoderConfig;
    var decoderPending;
    onmessage = function onmessage1(e) {
        var message = e.data;
        switch(message.type){
            case "init":
                decoderConfig = message.decoderConfig;
                decoderPending = new Promise(function(resolve) {
                    decoderConfig.onModuleLoaded = function(draco) {
                        resolve({
                            draco: draco
                        });
                    };
                    DracoDecoderModule(decoderConfig);
                });
                break;
            case "decode":
                var buffer = message.buffer;
                var taskConfig = message.taskConfig;
                decoderPending.then(function(module) {
                    var draco = module.draco;
                    var decoder = new draco.Decoder();
                    var decoderBuffer = new draco.DecoderBuffer();
                    decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);
                    try {
                        var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);
                        var buffers = geometry.attributes.map(function(attr) {
                            return attr.array.buffer;
                        });
                        if (geometry.index) buffers.push(geometry.index.array.buffer);
                        self.postMessage({
                            type: "decode",
                            id: message.id,
                            geometry: geometry
                        }, buffers);
                    } catch (error) {
                        console.error(error);
                        self.postMessage({
                            type: "error",
                            id: message.id,
                            error: error.message
                        });
                    } finally{
                        draco.destroy(decoderBuffer);
                        draco.destroy(decoder);
                    }
                });
                break;
        }
    };
    function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {
        var attributeIDs = taskConfig.attributeIDs;
        var attributeTypes = taskConfig.attributeTypes;
        var dracoGeometry;
        var decodingStatus;
        var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);
        if (geometryType === draco.TRIANGULAR_MESH) {
            dracoGeometry = new draco.Mesh();
            decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);
        } else if (geometryType === draco.POINT_CLOUD) {
            dracoGeometry = new draco.PointCloud();
            decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);
        } else {
            throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
        }
        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
            throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
        }
        var geometry = {
            index: null,
            attributes: []
        };
        for(var attributeName in attributeIDs){
            var attributeType = self[attributeTypes[attributeName]];
            var attribute = void 0;
            var attributeID = void 0;
            if (taskConfig.useUniqueIDs) {
                attributeID = attributeIDs[attributeName];
                attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
            } else {
                attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
                if (attributeID === -1) continue;
                attribute = decoder.GetAttribute(dracoGeometry, attributeID);
            }
            geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));
        }
        if (geometryType === draco.TRIANGULAR_MESH) {
            geometry.index = decodeIndex(draco, decoder, dracoGeometry);
        }
        draco.destroy(dracoGeometry);
        return geometry;
    }
    function decodeIndex(draco, decoder, dracoGeometry) {
        var numFaces = dracoGeometry.num_faces();
        var numIndices = numFaces * 3;
        var byteLength = numIndices * 4;
        var ptr = draco._malloc(byteLength);
        decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
        var index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
        draco._free(ptr);
        return {
            array: index,
            itemSize: 1
        };
    }
    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
        var numComponents = attribute.num_components();
        var numPoints = dracoGeometry.num_points();
        var numValues = numPoints * numComponents;
        var byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
        var dataType = getDracoDataType(draco, attributeType);
        var ptr = draco._malloc(byteLength);
        decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
        var array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
        draco._free(ptr);
        return {
            name: attributeName,
            array: array,
            itemSize: numComponents
        };
    }
    function getDracoDataType(draco, attributeType) {
        switch(attributeType){
            case Float32Array:
                return draco.DT_FLOAT32;
            case Int8Array:
                return draco.DT_INT8;
            case Int16Array:
                return draco.DT_INT16;
            case Int32Array:
                return draco.DT_INT32;
            case Uint8Array:
                return draco.DT_UINT8;
            case Uint16Array:
                return draco.DT_UINT16;
            case Uint32Array:
                return draco.DT_UINT32;
        }
    }
}
;
 //# sourceMappingURL=DRACOLoader.js.map
}),
"[project]/node_modules/three-stdlib/libs/MeshoptDecoder.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MeshoptDecoder",
    ()=>MeshoptDecoder
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_type_of.js [app-client] (ecmascript)");
;
var generated;
var MeshoptDecoder = function() {
    var unpack = function unpack(data) {
        var result = new Uint8Array(data.length);
        for(var i = 0; i < data.length; ++i){
            var ch = data.charCodeAt(i);
            result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;
        }
        var write = 0;
        for(var i1 = 0; i1 < data.length; ++i1){
            result[write++] = result[i1] < 60 ? wasmpack[result[i1]] : (result[i1] - 60) * 64 + result[++i1];
        }
        return result.buffer.slice(0, write);
    };
    var decode = function decode(fun, target, count, size, source, filter) {
        var sbrk = instance.exports.sbrk;
        var count4 = count + 3 & ~3;
        var tp = sbrk(count4 * size);
        var sp = sbrk(source.length);
        var heap = new Uint8Array(instance.exports.memory.buffer);
        heap.set(source, sp);
        var res = fun(tp, count, size, sp, source.length);
        if (res === 0 && filter) {
            filter(tp, count4, size);
        }
        target.set(heap.subarray(tp, tp + count * size));
        sbrk(tp - sbrk(0));
        if (res !== 0) {
            throw new Error("Malformed buffer data: ".concat(res));
        }
    };
    if (generated) return generated;
    var wasm_base = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
    var wasm_simd = "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";
    var detector = new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        4,
        1,
        96,
        0,
        0,
        3,
        3,
        2,
        0,
        0,
        5,
        3,
        1,
        0,
        1,
        12,
        1,
        0,
        10,
        22,
        2,
        12,
        0,
        65,
        0,
        65,
        0,
        65,
        0,
        252,
        10,
        0,
        0,
        11,
        7,
        0,
        65,
        0,
        253,
        15,
        26,
        11
    ]);
    var wasmpack = new Uint8Array([
        32,
        0,
        65,
        253,
        3,
        1,
        2,
        34,
        4,
        106,
        6,
        5,
        11,
        8,
        7,
        20,
        13,
        33,
        12,
        16,
        128,
        9,
        116,
        64,
        19,
        113,
        127,
        15,
        10,
        21,
        22,
        14,
        255,
        66,
        24,
        54,
        136,
        107,
        18,
        23,
        192,
        26,
        114,
        118,
        132,
        17,
        77,
        101,
        130,
        144,
        27,
        87,
        131,
        44,
        45,
        74,
        156,
        154,
        70,
        167
    ]);
    if ((typeof WebAssembly === "undefined" ? "undefined" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(WebAssembly)) !== "object") {
        return {
            supported: false
        };
    }
    var wasm = wasm_base;
    if (WebAssembly.validate(detector)) {
        wasm = wasm_simd;
    }
    var instance;
    var promise = WebAssembly.instantiate(unpack(wasm), {}).then(function(result) {
        instance = result.instance;
        instance.exports.__wasm_call_ctors();
    });
    var filters = {
        // legacy index-based enums for glTF
        0: "",
        1: "meshopt_decodeFilterOct",
        2: "meshopt_decodeFilterQuat",
        3: "meshopt_decodeFilterExp",
        // string-based enums for glTF
        NONE: "",
        OCTAHEDRAL: "meshopt_decodeFilterOct",
        QUATERNION: "meshopt_decodeFilterQuat",
        EXPONENTIAL: "meshopt_decodeFilterExp"
    };
    var decoders = {
        // legacy index-based enums for glTF
        0: "meshopt_decodeVertexBuffer",
        1: "meshopt_decodeIndexBuffer",
        2: "meshopt_decodeIndexSequence",
        // string-based enums for glTF
        ATTRIBUTES: "meshopt_decodeVertexBuffer",
        TRIANGLES: "meshopt_decodeIndexBuffer",
        INDICES: "meshopt_decodeIndexSequence"
    };
    generated = {
        ready: promise,
        supported: true,
        decodeVertexBuffer: function decodeVertexBuffer(target, count, size, source, filter) {
            decode(instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);
        },
        decodeIndexBuffer: function decodeIndexBuffer(target, count, size, source) {
            decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);
        },
        decodeIndexSequence: function decodeIndexSequence(target, count, size, source) {
            decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);
        },
        decodeGltfBuffer: function decodeGltfBuffer(target, count, size, source, mode, filter) {
            decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);
        }
    };
    return generated;
};
;
 //# sourceMappingURL=MeshoptDecoder.js.map
}),
"[project]/node_modules/@react-three/fiber/dist/events-f8cd670d.esm.js [app-client] (ecmascript) <export G as useLoader>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useLoader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$f8cd670d$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["G"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$f8cd670d$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@react-three/fiber/dist/events-f8cd670d.esm.js [app-client] (ecmascript)");
}),
"[project]/node_modules/three-stdlib/utils/SkeletonUtils.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SkeletonUtils",
    ()=>SkeletonUtils
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
function retarget(target, source) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var pos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](), quat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"](), scale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](), bindBoneMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"](), relativeMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"](), globalMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;
    options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;
    options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;
    options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;
    options.hip = options.hip !== void 0 ? options.hip : "hip";
    options.names = options.names || {};
    var sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source), bones = target.isObject3D ? target.skeleton.bones : getBones(target);
    var bindBones, bone, name, boneTo, bonesPosition;
    if (target.isObject3D) {
        target.skeleton.pose();
    } else {
        options.useTargetMatrix = true;
        options.preserveMatrix = false;
    }
    if (options.preservePosition) {
        bonesPosition = [];
        for(var i = 0; i < bones.length; i++){
            bonesPosition.push(bones[i].position.clone());
        }
    }
    if (options.preserveMatrix) {
        target.updateMatrixWorld();
        target.matrixWorld.identity();
        for(var i1 = 0; i1 < target.children.length; ++i1){
            target.children[i1].updateMatrixWorld(true);
        }
    }
    if (options.offsets) {
        bindBones = [];
        for(var i2 = 0; i2 < bones.length; ++i2){
            bone = bones[i2];
            name = options.names[bone.name] || bone.name;
            if (options.offsets[name]) {
                bone.matrix.multiply(options.offsets[name]);
                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
                bone.updateMatrixWorld();
            }
            bindBones.push(bone.matrixWorld.clone());
        }
    }
    for(var i3 = 0; i3 < bones.length; ++i3){
        bone = bones[i3];
        name = options.names[bone.name] || bone.name;
        boneTo = getBoneByName(name, sourceBones);
        globalMatrix.copy(bone.matrixWorld);
        if (boneTo) {
            boneTo.updateMatrixWorld();
            if (options.useTargetMatrix) {
                relativeMatrix.copy(boneTo.matrixWorld);
            } else {
                relativeMatrix.copy(target.matrixWorld).invert();
                relativeMatrix.multiply(boneTo.matrixWorld);
            }
            scale.setFromMatrixScale(relativeMatrix);
            relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));
            globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));
            if (target.isObject3D) {
                var boneIndex = bones.indexOf(bone), wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();
                globalMatrix.multiply(wBindMatrix);
            }
            globalMatrix.copyPosition(relativeMatrix);
        }
        if (bone.parent && bone.parent.isBone) {
            bone.matrix.copy(bone.parent.matrixWorld).invert();
            bone.matrix.multiply(globalMatrix);
        } else {
            bone.matrix.copy(globalMatrix);
        }
        if (options.preserveHipPosition && name === options.hip) {
            bone.matrix.setPosition(pos.set(0, bone.position.y, 0));
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        bone.updateMatrixWorld();
    }
    if (options.preservePosition) {
        for(var i4 = 0; i4 < bones.length; ++i4){
            bone = bones[i4];
            name = options.names[bone.name] || bone.name;
            if (name !== options.hip) {
                bone.position.copy(bonesPosition[i4]);
            }
        }
    }
    if (options.preserveMatrix) {
        target.updateMatrixWorld(true);
    }
}
function retargetClip(target, source, clip) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;
    options.fps = options.fps !== void 0 ? options.fps : 30;
    options.names = options.names || [];
    if (!source.isObject3D) {
        source = getHelperFromSkeleton(source);
    }
    var numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3), delta = 1 / options.fps, convertedTracks = [], mixer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationMixer"](source), bones = getBones(target.skeleton), boneDatas = [];
    var positionOffset, bone, boneTo, boneData, name;
    mixer.clipAction(clip).play();
    mixer.update(0);
    source.updateMatrixWorld();
    for(var i = 0; i < numFrames; ++i){
        var time = i * delta;
        retarget(target, source, options);
        for(var j = 0; j < bones.length; ++j){
            name = options.names[bones[j].name] || bones[j].name;
            boneTo = getBoneByName(name, source.skeleton);
            if (boneTo) {
                bone = bones[j];
                boneData = boneDatas[j] = boneDatas[j] || {
                    bone: bone
                };
                if (options.hip === name) {
                    if (!boneData.pos) {
                        boneData.pos = {
                            times: new Float32Array(numFrames),
                            values: new Float32Array(numFrames * 3)
                        };
                    }
                    if (options.useFirstFramePosition) {
                        if (i === 0) {
                            positionOffset = bone.position.clone();
                        }
                        bone.position.sub(positionOffset);
                    }
                    boneData.pos.times[i] = time;
                    bone.position.toArray(boneData.pos.values, i * 3);
                }
                if (!boneData.quat) {
                    boneData.quat = {
                        times: new Float32Array(numFrames),
                        values: new Float32Array(numFrames * 4)
                    };
                }
                boneData.quat.times[i] = time;
                bone.quaternion.toArray(boneData.quat.values, i * 4);
            }
        }
        mixer.update(delta);
        source.updateMatrixWorld();
    }
    for(var i1 = 0; i1 < boneDatas.length; ++i1){
        boneData = boneDatas[i1];
        if (boneData) {
            if (boneData.pos) {
                convertedTracks.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"](".bones[" + boneData.bone.name + "].position", boneData.pos.times, boneData.pos.values));
            }
            convertedTracks.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QuaternionKeyframeTrack"](".bones[" + boneData.bone.name + "].quaternion", boneData.quat.times, boneData.quat.values));
        }
    }
    mixer.uncacheAction(clip);
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"](clip.name, -1, convertedTracks);
}
function clone(source) {
    var sourceLookup = /* @__PURE__ */ new Map();
    var cloneLookup = /* @__PURE__ */ new Map();
    var clone2 = source.clone();
    parallelTraverse(source, clone2, function(sourceNode, clonedNode) {
        sourceLookup.set(clonedNode, sourceNode);
        cloneLookup.set(sourceNode, clonedNode);
    });
    clone2.traverse(function(node) {
        if (!node.isSkinnedMesh) return;
        var clonedMesh = node;
        var sourceMesh = sourceLookup.get(node);
        var sourceBones = sourceMesh.skeleton.bones;
        clonedMesh.skeleton = sourceMesh.skeleton.clone();
        clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);
        clonedMesh.skeleton.bones = sourceBones.map(function(bone) {
            return cloneLookup.get(bone);
        });
        clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);
    });
    return clone2;
}
function getBoneByName(name, skeleton) {
    for(var i = 0, bones = getBones(skeleton); i < bones.length; i++){
        if (name === bones[i].name) return bones[i];
    }
}
function getBones(skeleton) {
    return Array.isArray(skeleton) ? skeleton : skeleton.bones;
}
function getHelperFromSkeleton(skeleton) {
    var source = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SkeletonHelper"](skeleton.bones[0]);
    source.skeleton = skeleton;
    return source;
}
function parallelTraverse(a, b, callback) {
    callback(a, b);
    for(var i = 0; i < a.children.length; i++){
        parallelTraverse(a.children[i], b.children[i], callback);
    }
}
var SkeletonUtils = {
    retarget: retarget,
    retargetClip: retargetClip,
    clone: clone
};
;
 //# sourceMappingURL=SkeletonUtils.js.map
}),
"[project]/node_modules/@react-three/drei/core/Clone.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Clone",
    ()=>Clone
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_instanceof.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_object_spread.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread_props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_object_spread_props.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_without_properties$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_object_without_properties.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$SkeletonUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three-stdlib/utils/SkeletonUtils.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
function createSpread(child, param) {
    var _param_keys = param.keys, keys = _param_keys === void 0 ? [
        'near',
        'far',
        'color',
        'distance',
        'decay',
        'penumbra',
        'angle',
        'intensity',
        'skeleton',
        'visible',
        'castShadow',
        'receiveShadow',
        'morphTargetDictionary',
        'morphTargetInfluences',
        'name',
        'geometry',
        'material',
        'position',
        'rotation',
        'scale',
        'up',
        'userData',
        'bindMode',
        'bindMatrix',
        'bindMatrixInverse',
        'skeleton'
    ] : _param_keys, deep = param.deep, inject = param.inject, castShadow = param.castShadow, receiveShadow = param.receiveShadow;
    var spread = {};
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var key = _step.value;
            spread[key] = child[key];
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    if (deep) {
        if (spread.geometry && deep !== 'materialsOnly') spread.geometry = spread.geometry.clone();
        if (spread.material && deep !== 'geometriesOnly') spread.material = spread.material.clone();
    }
    if (inject) {
        if (typeof inject === 'function') spread = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread_props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({}, spread), {
            children: inject(child)
        });
        else if (/*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidElement"](inject)) spread = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread_props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({}, spread), {
            children: inject
        });
        else spread = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({}, spread, inject);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(child, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"])) {
        if (castShadow) spread.castShadow = true;
        if (receiveShadow) spread.receiveShadow = true;
    }
    return spread;
}
var Clone = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"](function(_param, forwardRef) {
    var _param_isChild = _param.isChild, isChild = _param_isChild === void 0 ? false : _param_isChild, object = _param.object, children = _param.children, deep = _param.deep, castShadow = _param.castShadow, receiveShadow = _param.receiveShadow, inject = _param.inject, keys = _param.keys, props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_without_properties$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_param, [
        "isChild",
        "object",
        "children",
        "deep",
        "castShadow",
        "receiveShadow",
        "inject",
        "keys"
    ]);
    var config = {
        keys: keys,
        deep: deep,
        inject: inject,
        castShadow: castShadow,
        receiveShadow: receiveShadow
    };
    object = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "Clone.useMemo": function() {
            if (isChild === false && !Array.isArray(object)) {
                var isSkinned = false;
                object.traverse({
                    "Clone.useMemo": function(object) {
                        if (object.isSkinnedMesh) isSkinned = true;
                    }
                }["Clone.useMemo"]);
                if (isSkinned) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$SkeletonUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SkeletonUtils"].clone(object);
            }
            return object;
        }
    }["Clone.useMemo"], [
        object,
        isChild
    ]);
    // Deal with arrayed clones
    if (Array.isArray(object)) {
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"]("group", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, props, {
            ref: forwardRef
        }), object.map(function(o) {
            return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](Clone, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
                key: o.uuid,
                object: o
            }, config));
        }), children);
    }
    // Singleton clones
    var _createSpread = createSpread(object, config), injectChildren = _createSpread.children, spread = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_without_properties$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_createSpread, [
        "children"
    ]);
    var Element = object.type[0].toLowerCase() + object.type.slice(1);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](Element, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, spread, props, {
        ref: forwardRef
    }), object.children.map(function(child) {
        if (child.type === 'Bone') return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"]("primitive", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
            key: child.uuid,
            object: child
        }, config));
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](Clone, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
            key: child.uuid,
            object: child
        }, config, {
            isChild: true
        }));
    }), children, injectChildren);
});
;
}),
"[project]/node_modules/@react-three/drei/core/Gltf.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Gltf",
    ()=>Gltf,
    "useGLTF",
    ()=>useGLTF
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_without_properties$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_object_without_properties.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$GLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three-stdlib/loaders/GLTFLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$DRACOLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three-stdlib/loaders/DRACOLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$MeshoptDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three-stdlib/libs/MeshoptDecoder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$f8cd670d$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__G__as__useLoader$3e$__ = __turbopack_context__.i("[project]/node_modules/@react-three/fiber/dist/events-f8cd670d.esm.js [app-client] (ecmascript) <export G as useLoader>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$three$2f$drei$2f$core$2f$Clone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@react-three/drei/core/Clone.js [app-client] (ecmascript)");
;
;
;
;
;
;
var dracoLoader = null;
var decoderPath = 'https://www.gstatic.com/draco/versioned/decoders/1.5.5/';
function extensions() {
    var useDraco = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, useMeshopt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, extendLoader = arguments.length > 2 ? arguments[2] : void 0;
    return function(loader) {
        if (extendLoader) {
            extendLoader(loader);
        }
        if (useDraco) {
            if (!dracoLoader) {
                dracoLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$DRACOLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DRACOLoader"]();
            }
            dracoLoader.setDecoderPath(typeof useDraco === 'string' ? useDraco : decoderPath);
            loader.setDRACOLoader(dracoLoader);
        }
        if (useMeshopt) {
            loader.setMeshoptDecoder(typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$MeshoptDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshoptDecoder"] === 'function' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$MeshoptDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshoptDecoder"])() : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$MeshoptDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshoptDecoder"]);
        }
    };
}
var useGLTF = function(path, useDraco, useMeshopt, extendLoader) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$f8cd670d$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__G__as__useLoader$3e$__["useLoader"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$GLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GLTFLoader"], path, extensions(useDraco, useMeshopt, extendLoader));
};
useGLTF.preload = function(path, useDraco, useMeshopt, extendLoader) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$f8cd670d$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__G__as__useLoader$3e$__["useLoader"].preload(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$GLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GLTFLoader"], path, extensions(useDraco, useMeshopt, extendLoader));
};
useGLTF.clear = function(path) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$f8cd670d$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__G__as__useLoader$3e$__["useLoader"].clear(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$GLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GLTFLoader"], path);
};
useGLTF.setDecoderPath = function(path) {
    decoderPath = path;
};
//
var Gltf = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"](function(_param, ref) {
    var src = _param.src, useDraco = _param.useDraco, useMeshOpt = _param.useMeshOpt, extendLoader = _param.extendLoader, props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_without_properties$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_param, [
        "src",
        "useDraco",
        "useMeshOpt",
        "extendLoader"
    ]);
    var scene = useGLTF(src, useDraco, useMeshOpt, extendLoader).scene;
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$three$2f$drei$2f$core$2f$Clone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Clone"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
        ref: ref
    }, props, {
        object: scene
    }));
});
;
}),
]);

//# sourceMappingURL=node_modules_25303444._.js.map