{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/_polyfill/constants.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/_polyfill/constants.ts"],"sourcesContent":["import { REVISION } from 'three'\n\nexport const version = /* @__PURE__ */ (() => parseInt(REVISION.replace(/\\D+/g, '')))()\n"],"names":[],"mappings":";;;;;;AAEa,IAAA,UAAA,aAAA,GAAA;WAAiC,SAAS,8JAAA,CAAS,OAAA,CAAQ,QAAQ,EAAE,CAAC,GAAG"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/objects/GroundProjectedEnv.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/objects/GroundProjectedEnv.ts"],"sourcesContent":["import { Mesh, IcosahedronGeometry, ShaderMaterial, DoubleSide, Texture, CubeTexture, BufferGeometry } from 'three'\nimport { version } from '../_polyfill/constants'\n\nexport interface GroundProjectedEnvParameters {\n  height?: number\n  radius?: number\n}\n\nconst isCubeTexture = (def: CubeTexture | Texture): def is CubeTexture => def && (def as CubeTexture).isCubeTexture\n\nexport class GroundProjectedEnv extends Mesh<BufferGeometry, ShaderMaterial> {\n  constructor(texture: CubeTexture | Texture, options?: GroundProjectedEnvParameters) {\n    const isCubeMap = isCubeTexture(texture)\n    const w = (isCubeMap ? texture.image[0]?.width : texture.image.width) ?? 1024\n    const cubeSize = w / 4\n    const _lodMax = Math.floor(Math.log2(cubeSize))\n    const _cubeSize = Math.pow(2, _lodMax)\n    const width = 3 * Math.max(_cubeSize, 16 * 7)\n    const height = 4 * _cubeSize\n\n    const defines = [\n      isCubeMap ? '#define ENVMAP_TYPE_CUBE' : '',\n      `#define CUBEUV_TEXEL_WIDTH ${1.0 / width}`,\n      `#define CUBEUV_TEXEL_HEIGHT ${1.0 / height}`,\n      `#define CUBEUV_MAX_MIP ${_lodMax}.0`,\n    ]\n\n    const vertexShader = /* glsl */ `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `\n    const fragmentShader =\n      defines.join('\\n') +\n      /* glsl */ `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n        }\n        `\n\n    const uniforms = {\n      map: { value: texture },\n      height: { value: options?.height || 15 },\n      radius: { value: options?.radius || 100 },\n    }\n\n    const geometry = new IcosahedronGeometry(1, 16)\n    const material = new ShaderMaterial({\n      uniforms,\n      fragmentShader,\n      vertexShader,\n      side: DoubleSide,\n    })\n\n    super(geometry, material)\n  }\n\n  set radius(radius: number) {\n    this.material.uniforms.radius.value = radius\n  }\n\n  get radius(): number {\n    return this.material.uniforms.radius.value\n  }\n\n  set height(height: number) {\n    this.material.uniforms.height.value = height\n  }\n\n  get height(): number {\n    return this.material.uniforms.height.value\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAQA,IAAM,gBAAgB,SAAC;WAAmD,OAAQ,IAAoB,aAAA;;uCAE/F;;;gCACO,OAAA,EAAgC,OAAA,EAAwC;;;QAC5E,IAAA,YAAY,cAAc,OAAO;QACjC,IAAA,IAAA,CAAK,KAAA,YAAA,CAAY,KAAA,QAAQ,KAAA,CAAM,CAAC,CAAA,KAAf,OAAA,KAAA,IAAA,GAAkB,KAAA,GAAQ,QAAQ,KAAA,CAAM,KAAA,KAApD,OAAA,KAA8D;QACzE,IAAM,WAAW,IAAI;QACrB,IAAM,UAAU,KAAK,KAAA,CAAM,KAAK,IAAA,CAAK,QAAQ,CAAC;QAC9C,IAAM,YAAY,KAAK,GAAA,CAAI,GAAG,OAAO;QACrC,IAAM,QAAQ,IAAI,KAAK,GAAA,CAAI,WAAW,KAAK,CAAC;QAC5C,IAAM,SAAS,IAAI;QAEnB,IAAM,UAAU;YACd,YAAY,6BAA6B;YACzC,8BAAoC,OAAN,IAAM;YACpC,+BAAqC,OAAN,IAAM;YACrC,0BAA0B,OAAA,SAAA;SAAA;QAGtB,IAAA,eAAA,QAAA,GAA0B;QAU1B,IAAA,iBACJ,QAAQ,IAAA,CAAK,IAAI,IAAA,QAAA,GACN,2/EAqEgD,OAAzC,uKAAA,IAAW,MAAM,wBAAwB,sBAAA;QAI7D,IAAM,WAAW;YACf,KAAK;gBAAE,OAAO;YAAQ;YACtB,QAAQ;gBAAE,OAAA,CAAO,WAAA,OAAA,KAAA,IAAA,QAAS,MAAA,KAAU;YAAG;YACvC,QAAQ;gBAAE,OAAA,CAAO,WAAA,OAAA,KAAA,IAAA,QAAS,MAAA,KAAU;YAAI;QAAA;QAG1C,IAAM,WAAW,IAAI,yKAAA,CAAoB,GAAG,EAAE;QACxC,IAAA,WAAW,IAAI,oKAAA,CAAe;sBAClC;4BACA;0BACA;YACA,MAAM,gKAAA;QAAA,CACP;QAED,OAAA;YAAM;YAAU,QAAQ;;;;;YAGtB;iBAIJ,IAAI,SAAiB;gBACZ,OAAA,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,MAAA,CAAO,KAAA;YACvC;iBANA,aAAW,MAAA,EAAgB;gBACpB,IAAA,CAAA,QAAA,CAAS,QAAA,CAAS,MAAA,CAAO,KAAA,GAAQ;YACxC;;;iBAMI;iBAIJ,IAAI,SAAiB;gBACZ,OAAA,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,MAAA,CAAO,KAAA;YACvC;iBANA,aAAW,MAAA,EAAgB;gBACpB,IAAA,CAAA,QAAA,CAAS,QAAA,CAAS,MAAA,CAAO,KAAA,GAAQ;YACxC;;;WAjIW;EAA2B,0JAAA,CAAqC"}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/RGBELoader.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/loaders/RGBELoader.js"],"sourcesContent":["import { DataTextureLoader, DataUtils, FloatType, HalfFloatType, LinearFilter } from 'three'\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n  parse(buffer) {\n    const /* default error routine.  change this to change error handling */\n      rgbe_read_error = 1,\n      rgbe_write_error = 2,\n      rgbe_format_error = 3,\n      rgbe_memory_error = 4,\n      rgbe_error = function (rgbe_error_code, msg) {\n        switch (rgbe_error_code) {\n          case rgbe_read_error:\n            throw new Error('THREE.RGBELoader: Read Error: ' + (msg || ''))\n          case rgbe_write_error:\n            throw new Error('THREE.RGBELoader: Write Error: ' + (msg || ''))\n          case rgbe_format_error:\n            throw new Error('THREE.RGBELoader: Bad File Format: ' + (msg || ''))\n          default:\n          case rgbe_memory_error:\n            throw new Error('THREE.RGBELoader: Memory Error: ' + (msg || ''))\n        }\n      },\n      /* offsets to red, green, and blue components in a data (float) pixel */\n      //RGBE_DATA_RED = 0,\n      //RGBE_DATA_GREEN = 1,\n      //RGBE_DATA_BLUE = 2,\n\n      /* number of floats per pixel, use 4 since stored in rgba image format */\n      //RGBE_DATA_SIZE = 4,\n\n      /* flags indicating which fields in an rgbe_header_info are valid */\n      RGBE_VALID_PROGRAMTYPE = 1,\n      RGBE_VALID_FORMAT = 2,\n      RGBE_VALID_DIMENSIONS = 4,\n      NEWLINE = '\\n',\n      fgets = function (buffer, lineLimit, consume) {\n        const chunkSize = 128\n\n        lineLimit = !lineLimit ? 1024 : lineLimit\n        let p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)))\n\n        while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n          s += chunk\n          len += chunk.length\n          p += chunkSize\n          chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)))\n        }\n\n        if (-1 < i) {\n          /*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n          if (false !== consume) buffer.pos += len + i + 1\n          return s + chunk.slice(0, i)\n        }\n\n        return false\n      },\n      /* minimal header reading.  modify if you want to parse more information */\n      RGBE_ReadHeader = function (buffer) {\n        // regexes to parse header info fields\n        const magic_token_re = /^#\\?(\\S+)/,\n          gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n          dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n          // RGBE format header struct\n          header = {\n            valid: 0 /* indicate which fields are valid */,\n\n            string: '' /* the actual header string */,\n\n            comments: '' /* comments found in header */,\n\n            programtype: 'RGBE' /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */,\n\n            format: '' /* RGBE format, default 32-bit_rle_rgbe */,\n\n            gamma: 1.0 /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */,\n\n            exposure: 1.0 /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */,\n\n            width: 0,\n            height: 0 /* image dimensions, width/height */,\n          }\n\n        let line, match\n\n        if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n          rgbe_error(rgbe_read_error, 'no header found')\n        }\n\n        /* if you want to require the magic token then uncomment the next line */\n        if (!(match = line.match(magic_token_re))) {\n          rgbe_error(rgbe_format_error, 'bad initial token')\n        }\n\n        header.valid |= RGBE_VALID_PROGRAMTYPE\n        header.programtype = match[1]\n        header.string += line + '\\n'\n\n        while (true) {\n          line = fgets(buffer)\n          if (false === line) break\n          header.string += line + '\\n'\n\n          if ('#' === line.charAt(0)) {\n            header.comments += line + '\\n'\n            continue // comment line\n          }\n\n          if ((match = line.match(gamma_re))) {\n            header.gamma = parseFloat(match[1])\n          }\n\n          if ((match = line.match(exposure_re))) {\n            header.exposure = parseFloat(match[1])\n          }\n\n          if ((match = line.match(format_re))) {\n            header.valid |= RGBE_VALID_FORMAT\n            header.format = match[1] //'32-bit_rle_rgbe';\n          }\n\n          if ((match = line.match(dimensions_re))) {\n            header.valid |= RGBE_VALID_DIMENSIONS\n            header.height = parseInt(match[1], 10)\n            header.width = parseInt(match[2], 10)\n          }\n\n          if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break\n        }\n\n        if (!(header.valid & RGBE_VALID_FORMAT)) {\n          rgbe_error(rgbe_format_error, 'missing format specifier')\n        }\n\n        if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n          rgbe_error(rgbe_format_error, 'missing image size specifier')\n        }\n\n        return header\n      },\n      RGBE_ReadPixels_RLE = function (buffer, w, h) {\n        const scanline_width = w\n\n        if (\n          // run length encoding is not allowed so read flat\n          scanline_width < 8 ||\n          scanline_width > 0x7fff ||\n          // this file is not run length encoded\n          2 !== buffer[0] ||\n          2 !== buffer[1] ||\n          buffer[2] & 0x80\n        ) {\n          // return the flat buffer\n          return new Uint8Array(buffer)\n        }\n\n        if (scanline_width !== ((buffer[2] << 8) | buffer[3])) {\n          rgbe_error(rgbe_format_error, 'wrong scanline width')\n        }\n\n        const data_rgba = new Uint8Array(4 * w * h)\n\n        if (!data_rgba.length) {\n          rgbe_error(rgbe_memory_error, 'unable to allocate buffer space')\n        }\n\n        let offset = 0,\n          pos = 0\n\n        const ptr_end = 4 * scanline_width\n        const rgbeStart = new Uint8Array(4)\n        const scanline_buffer = new Uint8Array(ptr_end)\n        let num_scanlines = h\n\n        // read in each successive scanline\n        while (num_scanlines > 0 && pos < buffer.byteLength) {\n          if (pos + 4 > buffer.byteLength) {\n            rgbe_error(rgbe_read_error)\n          }\n\n          rgbeStart[0] = buffer[pos++]\n          rgbeStart[1] = buffer[pos++]\n          rgbeStart[2] = buffer[pos++]\n          rgbeStart[3] = buffer[pos++]\n\n          if (2 != rgbeStart[0] || 2 != rgbeStart[1] || ((rgbeStart[2] << 8) | rgbeStart[3]) != scanline_width) {\n            rgbe_error(rgbe_format_error, 'bad rgbe scanline format')\n          }\n\n          // read each of the four channels for the scanline into the buffer\n          // first red, then green, then blue, then exponent\n          let ptr = 0,\n            count\n\n          while (ptr < ptr_end && pos < buffer.byteLength) {\n            count = buffer[pos++]\n            const isEncodedRun = count > 128\n            if (isEncodedRun) count -= 128\n\n            if (0 === count || ptr + count > ptr_end) {\n              rgbe_error(rgbe_format_error, 'bad scanline data')\n            }\n\n            if (isEncodedRun) {\n              // a (encoded) run of the same value\n              const byteValue = buffer[pos++]\n              for (let i = 0; i < count; i++) {\n                scanline_buffer[ptr++] = byteValue\n              }\n              //ptr += count;\n            } else {\n              // a literal-run\n              scanline_buffer.set(buffer.subarray(pos, pos + count), ptr)\n              ptr += count\n              pos += count\n            }\n          }\n\n          // now convert data from buffer into rgba\n          // first red, then green, then blue, then exponent (alpha)\n          const l = scanline_width //scanline_buffer.byteLength;\n          for (let i = 0; i < l; i++) {\n            let off = 0\n            data_rgba[offset] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 1] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 2] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 3] = scanline_buffer[i + off]\n            offset += 4\n          }\n\n          num_scanlines--\n        }\n\n        return data_rgba\n      }\n\n    const RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3]\n      const scale = Math.pow(2.0, e - 128.0) / 255.0\n\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale\n      destArray[destOffset + 3] = 1\n    }\n\n    const RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3]\n      const scale = Math.pow(2.0, e - 128.0) / 255.0\n\n      // clamping to 65504, the maximum representable value in float16\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504))\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504))\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504))\n      destArray[destOffset + 3] = DataUtils.toHalfFloat(1)\n    }\n\n    const byteArray = new Uint8Array(buffer)\n    byteArray.pos = 0\n    const rgbe_header_info = RGBE_ReadHeader(byteArray)\n\n    const w = rgbe_header_info.width,\n      h = rgbe_header_info.height,\n      image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h)\n\n    let data, type\n    let numElements\n\n    switch (this.type) {\n      case FloatType:\n        numElements = image_rgba_data.length / 4\n        const floatArray = new Float32Array(numElements * 4)\n\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4)\n        }\n\n        data = floatArray\n        type = FloatType\n        break\n\n      case HalfFloatType:\n        numElements = image_rgba_data.length / 4\n        const halfArray = new Uint16Array(numElements * 4)\n\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4)\n        }\n\n        data = halfArray\n        type = HalfFloatType\n        break\n\n      default:\n        throw new Error('THREE.RGBELoader: Unsupported type: ' + this.type)\n        break\n    }\n\n    return {\n      width: w,\n      height: h,\n      data: data,\n      header: rgbe_header_info.string,\n      gamma: rgbe_header_info.gamma,\n      exposure: rgbe_header_info.exposure,\n      type: type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case FloatType:\n        case HalfFloatType:\n          if ('colorSpace' in texture) texture.colorSpace = 'srgb-linear'\n          else texture.encoding = 3000 // LinearEncoding\n          texture.minFilter = LinearFilter\n          texture.magFilter = LinearFilter\n          texture.generateMipmaps = false\n          texture.flipY = true\n\n          break\n      }\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { RGBELoader }\n"],"names":["buffer","w","h"],"mappings":"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"}},
    {"offset": {"line": 382, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/EXRLoader.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/loaders/EXRLoader.js"],"sourcesContent":["import {\n  Texture,\n  DataTextureLoader,\n  DataUtils,\n  FloatType,\n  HalfFloatType,\n  LinearFilter,\n  RedFormat,\n  RGBAFormat,\n} from 'three'\nimport { unzlibSync } from 'fflate'\nimport { version } from '../_polyfill/constants'\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\n// https://github.com/mrdoob/three.js/pull/25771\nconst hasColorSpace = version >= 152\n\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16\n    const BITMAP_SIZE = USHORT_RANGE >> 3\n\n    const HUF_ENCBITS = 16 // literal (value) bit length\n    const HUF_DECBITS = 14 // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1 // encoding table size\n    const HUF_DECSIZE = 1 << HUF_DECBITS // decoding table size\n    const HUF_DECMASK = HUF_DECSIZE - 1\n\n    const NBITS = 16\n    const A_OFFSET = 1 << (NBITS - 1)\n    const MOD_MASK = (1 << NBITS) - 1\n\n    const SHORT_ZEROCODE_RUN = 59\n    const LONG_ZEROCODE_RUN = 63\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN\n\n    const ULONG_SIZE = 8\n    const FLOAT32_SIZE = 4\n    const INT32_SIZE = 4\n    const INT16_SIZE = 2\n    const INT8_SIZE = 1\n\n    const STATIC_HUFFMAN = 0\n    const DEFLATE = 1\n\n    const UNKNOWN = 0\n    const LOSSY_DCT = 1\n    const RLE = 2\n\n    const logBase = Math.pow(2.7182818, 2.2)\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0\n\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & (1 << (i & 7))) {\n          lut[k++] = i\n        }\n      }\n\n      var n = k - 1\n\n      while (k < USHORT_RANGE) lut[k++] = 0\n\n      return n\n    }\n\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {}\n        hdec[i].len = 0\n        hdec[i].lit = 0\n        hdec[i].p = null\n      }\n    }\n\n    const getBitsReturn = { l: 0, c: 0, lc: 0 }\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n        lc += 8\n      }\n\n      lc -= nBits\n\n      getBitsReturn.l = (c >> lc) & ((1 << nBits) - 1)\n      getBitsReturn.c = c\n      getBitsReturn.lc = lc\n    }\n\n    const hufTableBuffer = new Array(59)\n\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1\n\n      var c = 0\n\n      for (var i = 58; i > 0; --i) {\n        var nc = (c + hufTableBuffer[i]) >> 1\n        hufTableBuffer[i] = c\n        c = nc\n      }\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i]\n        if (l > 0) hcode[i] = l | (hufTableBuffer[l]++ << 6)\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset\n      var c = 0\n      var lc = 0\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false\n\n        getBits(6, c, lc, uInt8Array, p)\n\n        var l = getBitsReturn.l\n        c = getBitsReturn.c\n        lc = getBitsReturn.lc\n\n        hcode[im] = l\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          getBits(8, c, lc, uInt8Array, p)\n\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN\n          c = getBitsReturn.c\n          lc = getBitsReturn.lc\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        }\n      }\n\n      hufCanonicalCodeTable(hcode)\n    }\n\n    function hufLength(code) {\n      return code & 63\n    }\n\n    function hufCode(code) {\n      return code >> 6\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im])\n        var l = hufLength(hcode[im])\n\n        if (c >> l) {\n          throw 'Invalid table entry'\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> (l - HUF_DECBITS)]\n\n          if (pl.len) {\n            throw 'Invalid table entry'\n          }\n\n          pl.lit++\n\n          if (pl.p) {\n            var p = pl.p\n            pl.p = new Array(pl.lit)\n\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i]\n            }\n          } else {\n            pl.p = new Array(1)\n          }\n\n          pl.p[pl.lit - 1] = im\n        } else if (l) {\n          var plOffset = 0\n\n          for (var i = 1 << (HUF_DECBITS - l); i > 0; i--) {\n            var pl = hdecod[(c << (HUF_DECBITS - l)) + plOffset]\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry'\n            }\n\n            pl.len = l\n            pl.lit = im\n\n            plOffset++\n          }\n        }\n      }\n\n      return true\n    }\n\n    const getCharReturn = { c: 0, lc: 0 }\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n      lc += 8\n\n      getCharReturn.c = c\n      getCharReturn.lc = lc\n    }\n\n    const getCodeReturn = { c: 0, lc: 0 }\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset)\n          c = getCharReturn.c\n          lc = getCharReturn.lc\n        }\n\n        lc -= 8\n\n        var cs = c >> lc\n        var cs = new Uint8Array([cs])[0]\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1]\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po\n      } else {\n        return false\n      }\n\n      getCodeReturn.c = c\n      getCodeReturn.lc = lc\n    }\n\n    function UInt16(value) {\n      return value & 0xffff\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value)\n      return ref > 0x7fff ? ref - 0x10000 : ref\n    }\n\n    const wdec14Return = { a: 0, b: 0 }\n\n    function wdec14(l, h) {\n      var ls = Int16(l)\n      var hs = Int16(h)\n\n      var hi = hs\n      var ai = ls + (hi & 1) + (hi >> 1)\n\n      var as = ai\n      var bs = ai - hi\n\n      wdec14Return.a = as\n      wdec14Return.b = bs\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l)\n      var d = UInt16(h)\n\n      var bb = (m - (d >> 1)) & MOD_MASK\n      var aa = (d + bb - A_OFFSET) & MOD_MASK\n\n      wdec14Return.a = aa\n      wdec14Return.b = bb\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14\n      var n = nx > ny ? ny : nx\n      var p = 1\n      var p2\n\n      while (p <= n) p <<= 1\n\n      p >>= 1\n      p2 = p\n      p >>= 1\n\n      while (p >= 1) {\n        var py = 0\n        var ey = py + oy * (ny - p2)\n        var oy1 = oy * p\n        var oy2 = oy * p2\n        var ox1 = ox * p\n        var ox2 = ox * p2\n        var i00, i01, i10, i11\n\n        for (; py <= ey; py += oy2) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n            var p10 = px + oy1\n            var p11 = p10 + ox1\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec14(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec14(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec14(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec16(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec16(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec16(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1\n\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j])\n            else wdec16(buffer[px + j], buffer[p10 + j])\n\n            i00 = wdec14Return.a\n            buffer[p10 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        if (ny & p) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j])\n            else wdec16(buffer[px + j], buffer[p01 + j])\n\n            i00 = wdec14Return.a\n            buffer[p01 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        p2 = p\n        p >>= 1\n      }\n\n      return py\n    }\n\n    function hufDecode(\n      encodingTable,\n      decodingTable,\n      uInt8Array,\n      inDataView,\n      inOffset,\n      ni,\n      rlc,\n      no,\n      outBuffer,\n      outOffset,\n    ) {\n      var c = 0\n      var lc = 0\n      var outBufferEndOffset = no\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8)\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset)\n\n        c = getCharReturn.c\n        lc = getCharReturn.lc\n\n        while (lc >= HUF_DECBITS) {\n          var index = (c >> (lc - HUF_DECBITS)) & HUF_DECMASK\n          var pl = decodingTable[index]\n\n          if (pl.len) {\n            lc -= pl.len\n\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n            c = getCodeReturn.c\n            lc = getCodeReturn.lc\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues'\n            }\n\n            var j\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]])\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset)\n\n                c = getCharReturn.c\n                lc = getCharReturn.lc\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == ((c >> (lc - l)) & ((1 << l) - 1))) {\n                  lc -= l\n\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset,\n                  )\n\n                  c = getCodeReturn.c\n                  lc = getCodeReturn.lc\n\n                  break\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues'\n            }\n          }\n        }\n      }\n\n      var i = (8 - ni) & 7\n\n      c >>= i\n      lc -= i\n\n      while (lc > 0) {\n        var pl = decodingTable[(c << (HUF_DECBITS - lc)) & HUF_DECMASK]\n\n        if (pl.len) {\n          lc -= pl.len\n\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n          c = getCodeReturn.c\n          lc = getCodeReturn.lc\n        } else {\n          throw 'hufDecode issues'\n        }\n      }\n\n      return true\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 }\n      var initialInOffset = inOffset.value\n\n      var im = parseUint32(inDataView, inOffset)\n      var iM = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      var nBits = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE'\n      }\n\n      var freq = new Array(HUF_ENCSIZE)\n      var hdec = new Array(HUF_DECSIZE)\n\n      hufClearDecTable(hdec)\n\n      var ni = nCompressed - (inOffset.value - initialInOffset)\n\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq)\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress'\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec)\n\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset)\n    }\n\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]]\n      }\n    }\n\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128\n        source[t] = d\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0\n      var t2 = Math.floor((source.length + 1) / 2)\n      var s = 0\n      var stop = source.length - 1\n\n      while (true) {\n        if (s > stop) break\n        out[s++] = source[t1++]\n\n        if (s > stop) break\n        out[s++] = source[t2++]\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength\n      var out = new Array()\n      var p = 0\n\n      var reader = new DataView(source)\n\n      while (size > 0) {\n        var l = reader.getInt8(p++)\n\n        if (l < 0) {\n          var count = -l\n          size -= count + 1\n\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++))\n          }\n        } else {\n          var count = l\n          size -= 2\n\n          var value = reader.getUint8(p++)\n\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value)\n          }\n        }\n      }\n\n      return out\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer)\n\n      var width = channelData[cscSet.idx[0]].width\n      var height = channelData[cscSet.idx[0]].height\n\n      var numComp = 3\n\n      var numFullBlocksX = Math.floor(width / 8.0)\n      var numBlocksX = Math.ceil(width / 8.0)\n      var numBlocksY = Math.ceil(height / 8.0)\n      var leftoverX = width - (numBlocksX - 1) * 8\n      var leftoverY = height - (numBlocksY - 1) * 8\n\n      var currAcComp = { value: 0 }\n      var currDcComp = new Array(numComp)\n      var dctData = new Array(numComp)\n      var halfZigBlock = new Array(numComp)\n      var rowBlock = new Array(numComp)\n      var rowOffsets = new Array(numComp)\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]]\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY\n        dctData[comp] = new Float32Array(64)\n        halfZigBlock[comp] = new Uint16Array(64)\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64)\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8\n\n        if (blocky == numBlocksY - 1) maxY = leftoverY\n\n        var maxX = 8\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0)\n\n            // set block DC component\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]\n            // set block AC components\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp])\n\n            // UnZigZag block to float\n            unZigZag(halfZigBlock[comp], dctData[comp])\n            // decode float dct\n            dctInverse(dctData[comp])\n          }\n\n          if (numComp == 3) {\n            csc709Inverse(dctData)\n          }\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64)\n          }\n        } // blockx\n\n        let offset = 0\n\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type\n\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y]\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8\n\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true)\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true)\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true)\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true)\n\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true)\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true)\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true)\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true)\n\n              offset += 8 * INT16_SIZE * type\n            }\n          }\n\n          // handle partial X blocks\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8\n\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true)\n              }\n            }\n          }\n        } // comp\n      } // blocky\n\n      var halfRow = new Uint16Array(width)\n      var dataView = new DataView(outBuffer.buffer)\n\n      // convert channels back to float, if needed\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true\n        var type = channelData[cscSet.idx[comp]].type\n\n        if (channelData[comp].type != 2) continue\n\n        for (var y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y]\n\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true)\n          }\n\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true)\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue\n      var dctComp = 1\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value]\n\n        if (acValue == 0xff00) {\n          dctComp = 64\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff\n        } else {\n          halfZigBlock[dctComp] = acValue\n          dctComp++\n        }\n\n        currAcComp.value++\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0])\n      dst[1] = decodeFloat16(src[1])\n      dst[2] = decodeFloat16(src[5])\n      dst[3] = decodeFloat16(src[6])\n      dst[4] = decodeFloat16(src[14])\n      dst[5] = decodeFloat16(src[15])\n      dst[6] = decodeFloat16(src[27])\n      dst[7] = decodeFloat16(src[28])\n      dst[8] = decodeFloat16(src[2])\n      dst[9] = decodeFloat16(src[4])\n\n      dst[10] = decodeFloat16(src[7])\n      dst[11] = decodeFloat16(src[13])\n      dst[12] = decodeFloat16(src[16])\n      dst[13] = decodeFloat16(src[26])\n      dst[14] = decodeFloat16(src[29])\n      dst[15] = decodeFloat16(src[42])\n      dst[16] = decodeFloat16(src[3])\n      dst[17] = decodeFloat16(src[8])\n      dst[18] = decodeFloat16(src[12])\n      dst[19] = decodeFloat16(src[17])\n\n      dst[20] = decodeFloat16(src[25])\n      dst[21] = decodeFloat16(src[30])\n      dst[22] = decodeFloat16(src[41])\n      dst[23] = decodeFloat16(src[43])\n      dst[24] = decodeFloat16(src[9])\n      dst[25] = decodeFloat16(src[11])\n      dst[26] = decodeFloat16(src[18])\n      dst[27] = decodeFloat16(src[24])\n      dst[28] = decodeFloat16(src[31])\n      dst[29] = decodeFloat16(src[40])\n\n      dst[30] = decodeFloat16(src[44])\n      dst[31] = decodeFloat16(src[53])\n      dst[32] = decodeFloat16(src[10])\n      dst[33] = decodeFloat16(src[19])\n      dst[34] = decodeFloat16(src[23])\n      dst[35] = decodeFloat16(src[32])\n      dst[36] = decodeFloat16(src[39])\n      dst[37] = decodeFloat16(src[45])\n      dst[38] = decodeFloat16(src[52])\n      dst[39] = decodeFloat16(src[54])\n\n      dst[40] = decodeFloat16(src[20])\n      dst[41] = decodeFloat16(src[22])\n      dst[42] = decodeFloat16(src[33])\n      dst[43] = decodeFloat16(src[38])\n      dst[44] = decodeFloat16(src[46])\n      dst[45] = decodeFloat16(src[51])\n      dst[46] = decodeFloat16(src[55])\n      dst[47] = decodeFloat16(src[60])\n      dst[48] = decodeFloat16(src[21])\n      dst[49] = decodeFloat16(src[34])\n\n      dst[50] = decodeFloat16(src[37])\n      dst[51] = decodeFloat16(src[47])\n      dst[52] = decodeFloat16(src[50])\n      dst[53] = decodeFloat16(src[56])\n      dst[54] = decodeFloat16(src[59])\n      dst[55] = decodeFloat16(src[61])\n      dst[56] = decodeFloat16(src[35])\n      dst[57] = decodeFloat16(src[36])\n      dst[58] = decodeFloat16(src[48])\n      dst[59] = decodeFloat16(src[49])\n\n      dst[60] = decodeFloat16(src[57])\n      dst[61] = decodeFloat16(src[58])\n      dst[62] = decodeFloat16(src[62])\n      dst[63] = decodeFloat16(src[63])\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0)\n      const b = 0.5 * Math.cos(3.14159 / 16.0)\n      const c = 0.5 * Math.cos(3.14159 / 8.0)\n      const d = 0.5 * Math.cos((3.0 * 3.14159) / 16.0)\n      const e = 0.5 * Math.cos((5.0 * 3.14159) / 16.0)\n      const f = 0.5 * Math.cos((3.0 * 3.14159) / 8.0)\n      const g = 0.5 * Math.cos((7.0 * 3.14159) / 16.0)\n\n      var alpha = new Array(4)\n      var beta = new Array(4)\n      var theta = new Array(4)\n      var gamma = new Array(4)\n\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8\n\n        alpha[0] = c * data[rowPtr + 2]\n        alpha[1] = f * data[rowPtr + 2]\n        alpha[2] = c * data[rowPtr + 6]\n        alpha[3] = f * data[rowPtr + 6]\n\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7]\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7]\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7]\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7]\n\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4])\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4])\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[rowPtr + 0] = gamma[0] + beta[0]\n        data[rowPtr + 1] = gamma[1] + beta[1]\n        data[rowPtr + 2] = gamma[2] + beta[2]\n        data[rowPtr + 3] = gamma[3] + beta[3]\n\n        data[rowPtr + 4] = gamma[3] - beta[3]\n        data[rowPtr + 5] = gamma[2] - beta[2]\n        data[rowPtr + 6] = gamma[1] - beta[1]\n        data[rowPtr + 7] = gamma[0] - beta[0]\n      }\n\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column]\n        alpha[1] = f * data[16 + column]\n        alpha[2] = c * data[48 + column]\n        alpha[3] = f * data[48 + column]\n\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column]\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column]\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column]\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column]\n\n        theta[0] = a * (data[column] + data[32 + column])\n        theta[3] = a * (data[column] - data[32 + column])\n\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[0 + column] = gamma[0] + beta[0]\n        data[8 + column] = gamma[1] + beta[1]\n        data[16 + column] = gamma[2] + beta[2]\n        data[24 + column] = gamma[3] + beta[3]\n\n        data[32 + column] = gamma[3] - beta[3]\n        data[40 + column] = gamma[2] - beta[2]\n        data[48 + column] = gamma[1] - beta[1]\n        data[56 + column] = gamma[0] - beta[0]\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i]\n        var cb = data[1][i]\n        var cr = data[2][i]\n\n        data[0][i] = y + 1.5747 * cr\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr\n        data[2][i] = y + 1.8556 * cb\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]))\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2)\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0)\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size)\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size)\n\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed))\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type))\n      var bitmap = new Uint8Array(BITMAP_SIZE)\n\n      // Setup channel info\n      var outBufferEnd = 0\n      var pizChannelData = new Array(info.channels)\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {}\n        pizChannelData[i]['start'] = outBufferEnd\n        pizChannelData[i]['end'] = pizChannelData[i]['start']\n        pizChannelData[i]['nx'] = info.width\n        pizChannelData[i]['ny'] = info.lines\n        pizChannelData[i]['size'] = info.type\n\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size\n      }\n\n      // Read range compression data\n\n      var minNonZero = parseUint16(inDataView, inOffset)\n      var maxNonZero = parseUint16(inDataView, inOffset)\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE'\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset)\n        }\n      }\n\n      // Reverse LUT\n      var lut = new Uint16Array(USHORT_RANGE)\n      var maxValue = reverseLutFromBitmap(bitmap, lut)\n\n      var length = parseUint32(inDataView, inOffset)\n\n      // Huffman decoding\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd)\n\n      // Wavelet decoding\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i]\n\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue)\n        }\n      }\n\n      // Expand the pixel data to their original range\n      applyLut(lut, outBuffer, outBufferEnd)\n\n      // Rearrange the pixel data into the format expected by the caller.\n      var tmpOffset = 0\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength)\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c]\n\n          var n = cd.nx * cd.size\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE)\n\n          tmpBuffer.set(cp, tmpOffset)\n          tmpOffset += n * INT16_SIZE\n          cd.end += n\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n\n      const sz = info.lines * info.channels * info.width\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz)\n\n      let tmpBufferEnd = 0\n      let writePtr = 0\n      const ptr = new Array(4)\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              tmpBufferEnd = ptr[1] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 8) | rawBuffer[ptr[1]++]\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n\n            case 2:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              ptr[2] = ptr[1] + info.width\n              tmpBufferEnd = ptr[2] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 24) | (rawBuffer[ptr[1]++] << 16) | (rawBuffer[ptr[2]++] << 8)\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE))\n\n      // Read compression header information\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset),\n      }\n\n      if (dwaHeader.version < 2) {\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported'\n      }\n\n      // Read channel ruleset information\n      var channelRules = new Array()\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset)\n        var value = parseUint8(inDataView, inOffset)\n        var compression = (value >> 2) & 3\n        var csc = (value >> 4) - 1\n        var index = new Int8Array([csc])[0]\n        var type = parseUint8(inDataView, inOffset)\n\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression,\n        })\n\n        ruleSize -= name.length + 3\n      }\n\n      // Classify channels\n      var channels = EXRHeader.channels\n      var channelData = new Array(info.channels)\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = (channelData[i] = {})\n        var channel = channels[i]\n\n        cd.name = channel.name\n        cd.compression = UNKNOWN\n        cd.decoded = false\n        cd.type = channel.pixelType\n        cd.pLinear = channel.pLinear\n        cd.width = info.width\n        cd.height = info.lines\n      }\n\n      var cscSet = {\n        idx: new Array(3),\n      }\n\n      for (var offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset]\n\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i]\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset\n            }\n\n            cd.offset = offset\n          }\n        }\n      }\n\n      // Read DCT - AC component data\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount)\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount,\n            )\n            break\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount)\n            var data = unzlibSync(compressed)\n            var acBuffer = new Uint16Array(data.buffer)\n            inOffset.value += dwaHeader.totalAcUncompressedCount\n            break\n        }\n      }\n\n      // Read DCT - DC component data\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize,\n        }\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer)\n        inOffset.value += dwaHeader.dcCompressedSize\n      }\n\n      // Read RLE compressed data\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize)\n        var data = unzlibSync(compressed)\n        var rleBuffer = decodeRunLength(data.buffer)\n\n        inOffset.value += dwaHeader.rleCompressedSize\n      }\n\n      // Prepare outbuffer data offset\n      var outBufferEnd = 0\n      var rowOffsets = new Array(channelData.length)\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array()\n      }\n\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd)\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE\n        }\n      }\n\n      // Lossy DCT decode RGB channels\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer)\n\n      // Decode other channels\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i]\n\n        if (cd.decoded) continue\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0\n            var rleOffset = 0\n\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row]\n\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height]\n                }\n\n                rleOffset++\n              }\n\n              row++\n            }\n\n            break\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression'\n        }\n      }\n\n      return new DataView(outBuffer.buffer)\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer)\n      var endOffset = 0\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset))\n\n      offset.value = offset.value + endOffset + 1\n\n      return stringValue\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size))\n\n      offset.value = offset.value + size\n\n      return stringValue\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Int32\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Uint32\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value]\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value)\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    const parseInt64 = function (dataView, offset) {\n      let int\n\n      if ('getBigInt64' in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset.value, true))\n      } else {\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32)\n      }\n\n      offset.value += ULONG_SIZE\n\n      return int\n    }\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true)\n\n      offset.value += FLOAT32_SIZE\n\n      return float\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset))\n    }\n\n    // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n        fraction = binary & 0x03ff\n\n      return (\n        (binary >> 15 ? -1 : 1) *\n        (exponent\n          ? exponent === 0x1f\n            ? fraction\n              ? NaN\n              : Infinity\n            : Math.pow(2, exponent - 15) * (1 + fraction / 0x400)\n          : 6.103515625e-5 * (fraction / 0x400))\n      )\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true)\n\n      offset.value += INT16_SIZE\n\n      return Uint16\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset))\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value\n      var channels = []\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset)\n        var pixelType = parseInt32(dataView, offset)\n        var pLinear = parseUint8(dataView, offset)\n        offset.value += 3 // reserved, three chars\n        var xSampling = parseInt32(dataView, offset)\n        var ySampling = parseInt32(dataView, offset)\n\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling,\n        })\n      }\n\n      offset.value += 1\n\n      return channels\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset)\n      var redY = parseFloat32(dataView, offset)\n      var greenX = parseFloat32(dataView, offset)\n      var greenY = parseFloat32(dataView, offset)\n      var blueX = parseFloat32(dataView, offset)\n      var blueY = parseFloat32(dataView, offset)\n      var whiteX = parseFloat32(dataView, offset)\n      var whiteY = parseFloat32(dataView, offset)\n\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY,\n      }\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = [\n        'NO_COMPRESSION',\n        'RLE_COMPRESSION',\n        'ZIPS_COMPRESSION',\n        'ZIP_COMPRESSION',\n        'PIZ_COMPRESSION',\n        'PXR24_COMPRESSION',\n        'B44_COMPRESSION',\n        'B44A_COMPRESSION',\n        'DWAA_COMPRESSION',\n        'DWAB_COMPRESSION',\n      ]\n\n      var compression = parseUint8(dataView, offset)\n\n      return compressionCodes[compression]\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset)\n      var yMin = parseUint32(dataView, offset)\n      var xMax = parseUint32(dataView, offset)\n      var yMax = parseUint32(dataView, offset)\n\n      return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax }\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y']\n\n      var lineOrder = parseUint8(dataView, offset)\n\n      return lineOrders[lineOrder]\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n      var z = parseFloat32(dataView, offset)\n\n      return [x, y, z]\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size)\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size)\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset)\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset)\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset)\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset)\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset)\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset)\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset)\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset)\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset)\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset)\n      } else if (type === 'preview') {\n        offset.value += size\n        return 'skipped'\n      } else {\n        offset.value += size\n        return undefined\n      }\n    }\n\n    function parseHeader(dataView, buffer, offset) {\n      const EXRHeader = {}\n\n      if (dataView.getUint32(0, true) != 20000630) {\n        // magic\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\"\n      }\n\n      EXRHeader.version = dataView.getUint8(4)\n\n      const spec = dataView.getUint8(5) // fullMask\n\n      EXRHeader.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16),\n      }\n\n      // start of header\n\n      offset.value = 8 // start at 8 - after pre-amble\n\n      var keepReading = true\n\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer, offset)\n\n        if (attributeName == 0) {\n          keepReading = false\n        } else {\n          var attributeType = parseNullTerminatedString(buffer, offset)\n          var attributeSize = parseUint32(dataView, offset)\n          var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize)\n\n          if (attributeValue === undefined) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`)\n          } else {\n            EXRHeader[attributeName] = attributeValue\n          }\n        }\n      }\n\n      if ((spec & ~0x04) != 0) {\n        // unsupported tiled, deep-image, multi-part\n        console.error('EXRHeader:', EXRHeader)\n        throw 'THREE.EXRLoader: provided file is currently unsupported.'\n      }\n\n      return EXRHeader\n    }\n\n    function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n      const EXRDecoder = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array,\n        offset: offset,\n        width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n        height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n        channels: EXRHeader.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? 'colorSpace' : 'encoding']: null,\n      }\n\n      switch (EXRHeader.compression) {\n        case 'NO_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRAW\n          break\n\n        case 'RLE_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRLE\n          break\n\n        case 'ZIPS_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'ZIP_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'PIZ_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressPIZ\n          break\n\n        case 'PXR24_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressPXR\n          break\n\n        case 'DWAA_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        case 'DWAB_COMPRESSION':\n          EXRDecoder.lines = 256\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        default:\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported'\n      }\n\n      EXRDecoder.scanlineBlockSize = EXRDecoder.lines\n\n      if (EXRDecoder.type == 1) {\n        // half\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = parseUint16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n        }\n      } else if (EXRDecoder.type == 2) {\n        // float\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = decodeFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n        }\n      } else {\n        throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.'\n      }\n\n      EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize\n\n      for (var i = 0; i < EXRDecoder.blockCount; i++) parseInt64(dataView, offset) // scanlineOffset\n\n      // we should be passed the scanline offset table, ready to start reading pixel data.\n\n      // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n      EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels\n      const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels\n\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder.byteArray = new Float32Array(size)\n\n          // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size)\n\n          break\n\n        case HalfFloatType:\n          EXRDecoder.byteArray = new Uint16Array(size)\n\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size) // Uint16Array holds half float data, 0x3C00 is 1\n\n          break\n\n        default:\n          console.error('THREE.EXRLoader: unsupported type: ', outputType)\n          break\n      }\n\n      EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels\n\n      if (EXRDecoder.outputChannels == 4) EXRDecoder.format = RGBAFormat\n      else EXRDecoder.format = RedFormat\n\n      if (hasColorSpace) EXRDecoder.colorSpace = 'srgb-linear'\n      else EXRDecoder.encoding = 3000 // LinearEncoding\n\n      return EXRDecoder\n    }\n\n    // start parsing file [START]\n\n    const bufferDataView = new DataView(buffer)\n    const uInt8Array = new Uint8Array(buffer)\n    const offset = { value: 0 }\n\n    // get header information and validate format.\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset)\n\n    // get input compression information and prepare decoding.\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type)\n\n    const tmpOffset = { value: 0 }\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 }\n\n    for (\n      let scanlineBlockIdx = 0;\n      scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize;\n      scanlineBlockIdx++\n    ) {\n      const line = parseUint32(bufferDataView, offset) // line_no\n      EXRDecoder.size = parseUint32(bufferDataView, offset) // data_len\n      EXRDecoder.lines =\n        line + EXRDecoder.scanlineBlockSize > EXRDecoder.height\n          ? EXRDecoder.height - line\n          : EXRDecoder.scanlineBlockSize\n\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder)\n\n      offset.value += EXRDecoder.size\n\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize\n        if (true_y >= EXRDecoder.height) break\n\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name]\n\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value =\n              (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) *\n              EXRDecoder.inputSize\n            const outIndex =\n              (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) +\n              x * EXRDecoder.outputChannels +\n              cOff\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset)\n          }\n        }\n      }\n    }\n\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? 'colorSpace' : 'encoding']: EXRDecoder[hasColorSpace ? 'colorSpace' : 'encoding'],\n      type: this.type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace) texture.colorSpace = texData.colorSpace\n      else texture.encoding = texData.encoding\n      texture.minFilter = LinearFilter\n      texture.magFilter = LinearFilter\n      texture.generateMipmaps = false\n      texture.flipY = false\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { EXRLoader }\n"],"names":["uInt8Array","buffer","comp","offset","type","y","x","tmpOffset","EXRHeader","EXRDecoder"],"mappings":"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AAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAE/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAE/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC;oBAC/B,GAAA,CAAI,EAAE,CAAA,GAAI,cAAc,GAAA,CAAI,EAAE,CAAC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"}},
    {"offset": {"line": 1788, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/lines/LineSegmentsGeometry.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/lines/LineSegmentsGeometry.js"],"sourcesContent":["import {\n  Box3,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry,\n} from 'three'\n\nconst _box = /* @__PURE__ */ new Box3()\nconst _vector = /* @__PURE__ */ new Vector3()\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n  constructor() {\n    super()\n\n    this.isLineSegmentsGeometry = true\n\n    this.type = 'LineSegmentsGeometry'\n\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0]\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2]\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]\n\n    this.setIndex(index)\n    this.setAttribute('position', new Float32BufferAttribute(positions, 3))\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n  }\n\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix)\n\n      end.applyMatrix4(matrix)\n\n      start.needsUpdate = true\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox()\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere()\n    }\n\n    return this\n  }\n\n  setPositions(array) {\n    let lineSegments\n\n    if (array instanceof Float32Array) {\n      lineSegments = array\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array)\n    }\n\n    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1) // xyz, xyz\n\n    this.setAttribute('instanceStart', new InterleavedBufferAttribute(instanceBuffer, 3, 0)) // xyz\n    this.setAttribute('instanceEnd', new InterleavedBufferAttribute(instanceBuffer, 3, 3)) // xyz\n\n    //\n\n    this.computeBoundingBox()\n    this.computeBoundingSphere()\n\n    return this\n  }\n\n  setColors(array, itemSize = 3) {\n    let colors\n\n    if (array instanceof Float32Array) {\n      colors = array\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array)\n    }\n\n    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, itemSize * 2, 1) // rgb(a), rgb(a)\n\n    this.setAttribute('instanceColorStart', new InterleavedBufferAttribute(instanceColorBuffer, itemSize, 0)) // rgb(a)\n    this.setAttribute('instanceColorEnd', new InterleavedBufferAttribute(instanceColorBuffer, itemSize, itemSize)) // rgb(a)\n\n    return this\n  }\n\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array)\n\n    return this\n  }\n\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array)\n\n    return this\n  }\n\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry))\n\n    // set colors, maybe\n\n    return this\n  }\n\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry\n\n    this.setPositions(geometry.attributes.position.array) // assumes non-indexed\n\n    // set colors, maybe\n\n    return this\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3()\n    }\n\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start)\n\n      _box.setFromBufferAttribute(end)\n\n      this.boundingBox.union(_box)\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere()\n    }\n\n    if (this.boundingBox === null) {\n      this.computeBoundingBox()\n    }\n\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center\n\n      this.boundingBox.getCenter(center)\n\n      let maxRadiusSq = 0\n\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i)\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector))\n\n        _vector.fromBufferAttribute(end, i)\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector))\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq)\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error(\n          'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.',\n          this,\n        )\n      }\n    }\n  }\n\n  toJSON() {\n    // todo\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().')\n\n    return this.applyMatrix4(matrix)\n  }\n}\n\nexport { LineSegmentsGeometry }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2029, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/lines/LineMaterial.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/lines/LineMaterial.js"],"sourcesContent":["/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n * }\n */\n\nimport { ShaderMaterial, UniformsLib, UniformsUtils, Vector2 } from 'three'\nimport { version } from '../_polyfill/constants'\n\nclass LineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: 'LineMaterial',\n\n      uniforms: UniformsUtils.clone(\n        UniformsUtils.merge([\n          UniformsLib.common,\n          UniformsLib.fog,\n          {\n            worldUnits: { value: 1 },\n            linewidth: { value: 1 },\n            resolution: { value: new Vector2(1, 1) },\n            dashOffset: { value: 0 },\n            dashScale: { value: 1 },\n            dashSize: { value: 1 },\n            gapSize: { value: 1 }, // todo FIX - maybe change to totalSize\n          },\n        ]),\n      ),\n\n      vertexShader: /* glsl */ `\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\n\t\t\t\tuniform float linewidth;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tattribute vec3 instanceStart;\n\t\t\t\tattribute vec3 instanceEnd;\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t\tattribute vec4 instanceColorStart;\n\t\t\t\t\t\tattribute vec4 instanceColorEnd;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t\tattribute vec3 instanceColorStart;\n\t\t\t\t\t\tattribute vec3 instanceColorEnd;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashScale;\n\t\t\t\t\tattribute float instanceDistanceStart;\n\t\t\t\t\tattribute float instanceDistanceEnd;\n\t\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#endif\n\n\t\t\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t\t\t// conservative estimate of the near plane\n\t\t\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#ifdef USE_COLOR\n\n\t\t\t\t\t\tvLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t\t\t// camera space\n\t\t\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\tworldStart = start.xyz;\n\t\t\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\t\t\tif ( perspective ) {\n\n\t\t\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// clip space\n\t\t\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t\t\t// ndc space\n\t\t\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t\t\t// direction\n\t\t\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t\t\t// account for clip-space aspect ratio\n\t\t\t\t\tdir.x *= aspect;\n\t\t\t\t\tdir = normalize( dir );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\t\t\tvec3 offset;\n\t\t\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t\t\t// set the world position\n\t\t\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t\t\t// project the worldpos\n\t\t\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t\t\t// segments overlap neatly\n\t\t\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\t\t\tdir.x /= aspect;\n\t\t\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset += - dir;\n\n\t\t\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\t\t\toffset += dir;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth;\n\n\t\t\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t\t\t// select end\n\t\t\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t\t\t// back to clip space\n\t\t\t\t\t\toffset *= clip.w;\n\n\t\t\t\t\t\tclip.xy += offset;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_Position = clip;\n\n\t\t\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n      fragmentShader: /* glsl */ `\n\t\t\t\tuniform vec3 diffuse;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform float linewidth;\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashOffset;\n\t\t\t\t\tuniform float dashSize;\n\t\t\t\t\tuniform float gapSize;\n\n\t\t\t\t#endif\n\n\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <clipping_planes_pars_fragment>\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\t\t\tfloat mua;\n\t\t\t\t\tfloat mub;\n\n\t\t\t\t\tvec3 p13 = p1 - p3;\n\t\t\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\t\t\tmua = numer / denom;\n\t\t\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\t\t\treturn vec2( mua, mub );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat alpha = opacity;\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\t\t\tfloat len = length( delta );\n\t\t\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\t\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\t\tdiffuseColor *= vLineColor;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tdiffuseColor.rgb *= vLineColor;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\t\t\tgl_FragColor = diffuseColor;\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t`,\n      clipping: true, // required for clipping support\n    })\n\n    this.isLineMaterial = true\n\n    this.onBeforeCompile = function () {\n      if (this.transparent) {\n        this.defines.USE_LINE_COLOR_ALPHA = '1'\n      } else {\n        delete this.defines.USE_LINE_COLOR_ALPHA\n      }\n    }\n\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.diffuse.value\n        },\n\n        set: function (value) {\n          this.uniforms.diffuse.value = value\n        },\n      },\n\n      worldUnits: {\n        enumerable: true,\n\n        get: function () {\n          return 'WORLD_UNITS' in this.defines\n        },\n\n        set: function (value) {\n          if (value === true) {\n            this.defines.WORLD_UNITS = ''\n          } else {\n            delete this.defines.WORLD_UNITS\n          }\n        },\n      },\n\n      linewidth: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.linewidth.value\n        },\n\n        set: function (value) {\n          this.uniforms.linewidth.value = value\n        },\n      },\n\n      dashed: {\n        enumerable: true,\n\n        get: function () {\n          return Boolean('USE_DASH' in this.defines)\n        },\n\n        set(value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true\n          }\n\n          if (value === true) {\n            this.defines.USE_DASH = ''\n          } else {\n            delete this.defines.USE_DASH\n          }\n        },\n      },\n\n      dashScale: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.dashScale.value\n        },\n\n        set: function (value) {\n          this.uniforms.dashScale.value = value\n        },\n      },\n\n      dashSize: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.dashSize.value\n        },\n\n        set: function (value) {\n          this.uniforms.dashSize.value = value\n        },\n      },\n\n      dashOffset: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.dashOffset.value\n        },\n\n        set: function (value) {\n          this.uniforms.dashOffset.value = value\n        },\n      },\n\n      gapSize: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.gapSize.value\n        },\n\n        set: function (value) {\n          this.uniforms.gapSize.value = value\n        },\n      },\n\n      opacity: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.opacity.value\n        },\n\n        set: function (value) {\n          this.uniforms.opacity.value = value\n        },\n      },\n\n      resolution: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.resolution.value\n        },\n\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value)\n        },\n      },\n\n      alphaToCoverage: {\n        enumerable: true,\n\n        get: function () {\n          return Boolean('USE_ALPHA_TO_COVERAGE' in this.defines)\n        },\n\n        set: function (value) {\n          if (Boolean(value) !== Boolean('USE_ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true\n          }\n\n          if (value === true) {\n            this.defines.USE_ALPHA_TO_COVERAGE = ''\n            this.extensions.derivatives = true\n          } else {\n            delete this.defines.USE_ALPHA_TO_COVERAGE\n            this.extensions.derivatives = false\n          }\n        },\n      },\n    })\n\n    this.setValues(parameters)\n  }\n}\n\nexport { LineMaterial }\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAeA;;;0BACc,UAAA,EAAY;;;gBACtB;YAAM;gBACJ,MAAM;gBAEN,UAAU,mKAAA,CAAc,KAAA,CACtB,mKAAA,CAAc,KAAA,CAAM;oBAClB,mLAAA,CAAY,MAAA;oBACZ,mLAAA,CAAY,GAAA;oBACZ;wBACE,YAAY;4BAAE,OAAO;wBAAG;wBACxB,WAAW;4BAAE,OAAO;wBAAG;wBACvB,YAAY;4BAAE,OAAO,IAAI,6JAAA,CAAQ,GAAG,CAAC;wBAAG;wBACxC,YAAY;4BAAE,OAAO;wBAAG;wBACxB,WAAW;4BAAE,OAAO;wBAAG;wBACvB,UAAU;4BAAE,OAAO;wBAAG;wBACtB,SAAS;4BAAE,OAAO;wBAAG;oBACtB;iBACF;gBAGH,cAAA,QAAA,GAAyB;gBA6OzB,gBAAA,QAAA,GAA2B,ghHAuKyB,OAAzC,uKAAA,IAAW,MAAM,wBAAwB,sBAAA;gBAMpD,UAAU;YAChB,CAAK;;QAED,MAAK,cAAA,GAAiB;QAEtB,MAAK,eAAA,GAAkB,WAAY;YACjC,IAAI,IAAA,CAAK,WAAA,EAAa;gBACpB,IAAA,CAAK,OAAA,CAAQ,oBAAA,GAAuB;YAC5C,OAAa;gBACL,OAAO,IAAA,CAAK,OAAA,CAAQ,oBAAA;YACrB;QACF;QAED,OAAO,gBAAA,CAAiB,OAAM;YAC5B,OAAO;gBACL,YAAY;qBAEP,SAAL,EAAiB;oBACf,OAAO,IAAA,CAAK,QAAA,CAAS,OAAA,CAAQ,KAAA;gBAC9B;qBAEI,SAAL,IAAe,KAAA,EAAO;oBACpB,IAAA,CAAK,QAAA,CAAS,OAAA,CAAQ,KAAA,GAAQ;gBAC/B;YACF;YAED,YAAY;gBACV,YAAY;qBAEP,SAAL,EAAiB;oBACf,OAAO,iBAAiB,IAAA,CAAK,OAAA;gBAC9B;qBAEI,SAAL,IAAe,KAAA,EAAO;oBACpB,IAAI,UAAU,MAAM;wBAClB,IAAA,CAAK,OAAA,CAAQ,WAAA,GAAc;oBACvC,OAAiB;wBACL,OAAO,IAAA,CAAK,OAAA,CAAQ,WAAA;oBACrB;gBACF;YACF;YAED,WAAW;gBACT,YAAY;qBAEP,SAAL,EAAiB;oBACf,OAAO,IAAA,CAAK,QAAA,CAAS,SAAA,CAAU,KAAA;gBAChC;qBAEI,SAAL,IAAe,KAAA,EAAO;oBACpB,IAAA,CAAK,QAAA,CAAS,SAAA,CAAU,KAAA,GAAQ;gBACjC;YACF;YAED,QAAQ;gBACN,YAAY;qBAEP,SAAL,EAAiB;oBACf,OAAO,QAAQ,cAAc,IAAA,CAAK,OAAO;gBAC1C;8BAED,IAAI,KAAA,EAAO;oBACT,IAAI,QAAQ,KAAK,MAAM,QAAQ,cAAc,IAAA,CAAK,OAAO,GAAG;wBAC1D,IAAA,CAAK,WAAA,GAAc;oBACpB;oBAED,IAAI,UAAU,MAAM;wBAClB,IAAA,CAAK,OAAA,CAAQ,QAAA,GAAW;oBACpC,OAAiB;wBACL,OAAO,IAAA,CAAK,OAAA,CAAQ,QAAA;oBACrB;gBACF;YACF;YAED,WAAW;gBACT,YAAY;gBAEZ,KAAK,WAAY;oBACf,OAAO,IAAA,CAAK,QAAA,CAAS,SAAA,CAAU,KAAA;gBAChC;qBAEI,SAAL,IAAe,KAAA,EAAO;oBACpB,IAAA,CAAK,QAAA,CAAS,SAAA,CAAU,KAAA,GAAQ;gBACjC;YACF;YAED,UAAU;gBACR,YAAY;qBAEP,SAAL,EAAiB;oBACf,OAAO,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,KAAA;gBAC/B;qBAEI,SAAL,IAAe,KAAA,EAAO;oBACpB,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,KAAA,GAAQ;gBAChC;YACF;YAED,YAAY;gBACV,YAAY;qBAEP,SAAL,EAAiB;oBACf,OAAO,IAAA,CAAK,QAAA,CAAS,UAAA,CAAW,KAAA;gBACjC;gBAED,KAAK,aAAU,KAAA,EAAO;oBACpB,IAAA,CAAK,QAAA,CAAS,UAAA,CAAW,KAAA,GAAQ;gBAClC;YACF;YAED,SAAS;gBACP,YAAY;qBAEP,SAAL,EAAiB;oBACf,OAAO,IAAA,CAAK,QAAA,CAAS,OAAA,CAAQ,KAAA;gBAC9B;qBAEI,SAAL,IAAe,KAAA,EAAO;oBACpB,IAAA,CAAK,QAAA,CAAS,OAAA,CAAQ,KAAA,GAAQ;gBAC/B;YACF;YAED,SAAS;gBACP,YAAY;qBAEP,SAAL,EAAiB;oBACf,OAAO,IAAA,CAAK,QAAA,CAAS,OAAA,CAAQ,KAAA;gBAC9B;qBAEI,SAAL,IAAe,KAAA,EAAO;oBACpB,IAAA,CAAK,QAAA,CAAS,OAAA,CAAQ,KAAA,GAAQ;gBAC/B;YACF;YAED,YAAY;gBACV,YAAY;qBAEP,SAAL,EAAiB;oBACf,OAAO,IAAA,CAAK,QAAA,CAAS,UAAA,CAAW,KAAA;gBACjC;qBAEI,SAAL,IAAe,KAAA,EAAO;oBACpB,IAAA,CAAK,QAAA,CAAS,UAAA,CAAW,KAAA,CAAM,IAAA,CAAK,KAAK;gBAC1C;YACF;YAED,iBAAiB;gBACf,YAAY;qBAEP,SAAL,EAAiB;oBACf,OAAO,QAAQ,2BAA2B,IAAA,CAAK,OAAO;gBACvD;qBAEI,SAAL,IAAe,KAAA,EAAO;oBACpB,IAAI,QAAQ,KAAK,MAAM,QAAQ,2BAA2B,IAAA,CAAK,OAAO,GAAG;wBACvE,IAAA,CAAK,WAAA,GAAc;oBACpB;oBAED,IAAI,UAAU,MAAM;wBAClB,IAAA,CAAK,OAAA,CAAQ,qBAAA,GAAwB;wBACrC,IAAA,CAAK,UAAA,CAAW,WAAA,GAAc;oBAC1C,OAAiB;wBACL,OAAO,IAAA,CAAK,OAAA,CAAQ,qBAAA;wBACpB,IAAA,CAAK,UAAA,CAAW,WAAA,GAAc;oBAC/B;gBACF;YACF;QACP,CAAK;QAED,MAAK,SAAA,CAAU,UAAU;;;WAxlBvB;EAAqB,oKAAA,CAAe"}},
    {"offset": {"line": 2225, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/_polyfill/uv1.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/_polyfill/uv1.ts"],"sourcesContent":["import { version } from \"./constants\";\n\n/** uv2 renamed to uv1 in r125\n * \n * https://github.com/mrdoob/three.js/pull/25943\n*/\nexport const UV1 = version >= 125 ? 'uv1' : 'uv2'"],"names":[],"mappings":";;;;;;AAMa,IAAA,MAAM,uKAAA,IAAW,MAAM,QAAQ"}},
    {"offset": {"line": 2238, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/lines/LineSegments2.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/lines/LineSegments2.js"],"sourcesContent":["import {\n  Box3,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4,\n} from 'three'\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry'\nimport { LineMaterial } from '../lines/LineMaterial'\nimport { UV1 } from '../_polyfill/uv1'\n\nconst _viewport = /* @__PURE__ */ new Vector4()\n\nconst _start = /* @__PURE__ */ new Vector3()\nconst _end = /* @__PURE__ */ new Vector3()\n\nconst _start4 = /* @__PURE__ */ new Vector4()\nconst _end4 = /* @__PURE__ */ new Vector4()\n\nconst _ssOrigin = /* @__PURE__ */ new Vector4()\nconst _ssOrigin3 = /* @__PURE__ */ new Vector3()\nconst _mvMatrix = /* @__PURE__ */ new Matrix4()\nconst _line = /* @__PURE__ */ new Line3()\nconst _closestPoint = /* @__PURE__ */ new Vector3()\n\nconst _box = /* @__PURE__ */ new Box3()\nconst _sphere = /* @__PURE__ */ new Sphere()\nconst _clipToWorldVector = /* @__PURE__ */ new Vector4()\n\nlet _ray, _lineWidth\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix)\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w)\n  _clipToWorldVector.x = _lineWidth / resolution.width\n  _clipToWorldVector.y = _lineWidth / resolution.height\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse)\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w)\n\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y))\n}\n\nfunction raycastWorldUnits(lineSegments, intersects) {\n  const matrixWorld = lineSegments.matrixWorld\n  const geometry = lineSegments.geometry\n  const instanceStart = geometry.attributes.instanceStart\n  const instanceEnd = geometry.attributes.instanceEnd\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count)\n\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _line.start.fromBufferAttribute(instanceStart, i)\n    _line.end.fromBufferAttribute(instanceEnd, i)\n\n    _line.applyMatrix4(matrixWorld)\n\n    const pointOnLine = new Vector3()\n    const point = new Vector3()\n\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine)\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5\n\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null,\n      })\n    }\n  }\n}\n\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix\n  const material = lineSegments.material\n  const resolution = material.resolution\n  const matrixWorld = lineSegments.matrixWorld\n\n  const geometry = lineSegments.geometry\n  const instanceStart = geometry.attributes.instanceStart\n  const instanceEnd = geometry.attributes.instanceEnd\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count)\n\n  const near = -camera.near\n\n  //\n\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n  _ray.at(1, _ssOrigin)\n\n  // ndc space [ - 1.0, 1.0 ]\n  _ssOrigin.w = 1\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse)\n  _ssOrigin.applyMatrix4(projectionMatrix)\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w)\n\n  // screen space\n  _ssOrigin.x *= resolution.x / 2\n  _ssOrigin.y *= resolution.y / 2\n  _ssOrigin.z = 0\n\n  _ssOrigin3.copy(_ssOrigin)\n\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld)\n\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i)\n    _end4.fromBufferAttribute(instanceEnd, i)\n\n    _start4.w = 1\n    _end4.w = 1\n\n    // camera space\n    _start4.applyMatrix4(_mvMatrix)\n    _end4.applyMatrix4(_mvMatrix)\n\n    // skip the segment if it's entirely behind the camera\n    const isBehindCameraNear = _start4.z > near && _end4.z > near\n    if (isBehindCameraNear) {\n      continue\n    }\n\n    // trim the segment if it extends behind camera near\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z\n      const t = (_start4.z - near) / deltaDist\n      _start4.lerp(_end4, t)\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z\n      const t = (_end4.z - near) / deltaDist\n      _end4.lerp(_start4, t)\n    }\n\n    // clip space\n    _start4.applyMatrix4(projectionMatrix)\n    _end4.applyMatrix4(projectionMatrix)\n\n    // ndc space [ - 1.0, 1.0 ]\n    _start4.multiplyScalar(1 / _start4.w)\n    _end4.multiplyScalar(1 / _end4.w)\n\n    // screen space\n    _start4.x *= resolution.x / 2\n    _start4.y *= resolution.y / 2\n\n    _end4.x *= resolution.x / 2\n    _end4.y *= resolution.y / 2\n\n    // create 2d segment\n    _line.start.copy(_start4)\n    _line.start.z = 0\n\n    _line.end.copy(_end4)\n    _line.end.z = 0\n\n    // get closest point on ray to segment\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true)\n    _line.at(param, _closestPoint)\n\n    // check if the intersection point is within clip space\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param)\n    const isInClipSpace = zPos >= -1 && zPos <= 1\n\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5\n\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i)\n      _line.end.fromBufferAttribute(instanceEnd, i)\n\n      _line.start.applyMatrix4(matrixWorld)\n      _line.end.applyMatrix4(matrixWorld)\n\n      const pointOnLine = new Vector3()\n      const point = new Vector3()\n\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine)\n\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null,\n      })\n    }\n  }\n}\n\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 0xffffff })) {\n    super(geometry, material)\n\n    this.isLineSegments2 = true\n\n    this.type = 'LineSegments2'\n  }\n\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n  computeLineDistances() {\n    const geometry = this.geometry\n\n    const instanceStart = geometry.attributes.instanceStart\n    const instanceEnd = geometry.attributes.instanceEnd\n    const lineDistances = new Float32Array(2 * instanceStart.count)\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i)\n      _end.fromBufferAttribute(instanceEnd, i)\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1]\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end)\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1) // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)) // d0\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)) // d1\n\n    return this\n  }\n\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits\n    const camera = raycaster.camera\n\n    if (camera === null && !worldUnits) {\n      console.error(\n        'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.',\n      )\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0\n\n    _ray = raycaster.ray\n\n    const matrixWorld = this.matrixWorld\n    const geometry = this.geometry\n    const material = this.material\n\n    _lineWidth = material.linewidth + threshold\n\n    // check if we intersect the sphere bounds\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere()\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld)\n\n    // increase the sphere bounds by the worst case line screen space width\n    let sphereMargin\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin))\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution)\n    }\n\n    _sphere.radius += sphereMargin\n\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return\n    }\n\n    // check if we intersect the box bounds\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox()\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld)\n\n    // increase the box bounds by the worst case line width\n    let boxMargin\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin))\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution)\n    }\n\n    _box.expandByScalar(boxMargin)\n\n    if (_ray.intersectsBox(_box) === false) {\n      return\n    }\n\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects)\n    } else {\n      raycastScreenSpace(this, camera, intersects)\n    }\n  }\n\n  onBeforeRender(renderer) {\n    const uniforms = this.material.uniforms\n\n    if (uniforms && uniforms.resolution) {\n      renderer.getViewport(_viewport)\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w)\n    }\n  }\n}\n\nexport { LineSegments2 }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2495, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/lines/LineGeometry.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/lines/LineGeometry.js"],"sourcesContent":["import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry'\n\nclass LineGeometry extends LineSegmentsGeometry {\n  constructor() {\n    super()\n\n    this.isLineGeometry = true\n\n    this.type = 'LineGeometry'\n  }\n\n  setPositions(array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n\n    const length = array.length - 3\n    const points = new Float32Array(2 * length)\n\n    for (let i = 0; i < length; i += 3) {\n      points[2 * i] = array[i]\n      points[2 * i + 1] = array[i + 1]\n      points[2 * i + 2] = array[i + 2]\n\n      points[2 * i + 3] = array[i + 3]\n      points[2 * i + 4] = array[i + 4]\n      points[2 * i + 5] = array[i + 5]\n    }\n\n    super.setPositions(points)\n\n    return this\n  }\n\n  setColors(array, itemSize = 3) {\n    // converts [ r1, g1, b1, (a1),  r2, g2, b2, (a2), ... ] to pairs format\n\n    const length = array.length - itemSize\n    const colors = new Float32Array(2 * length)\n\n    if (itemSize === 3) {\n      for (let i = 0; i < length; i += itemSize) {\n        colors[2 * i] = array[i]\n        colors[2 * i + 1] = array[i + 1]\n        colors[2 * i + 2] = array[i + 2]\n\n        colors[2 * i + 3] = array[i + 3]\n        colors[2 * i + 4] = array[i + 4]\n        colors[2 * i + 5] = array[i + 5]\n      }\n    } else {\n      for (let i = 0; i < length; i += itemSize) {\n        colors[2 * i] = array[i]\n        colors[2 * i + 1] = array[i + 1]\n        colors[2 * i + 2] = array[i + 2]\n        colors[2 * i + 3] = array[i + 3]\n\n        colors[2 * i + 4] = array[i + 4]\n        colors[2 * i + 5] = array[i + 5]\n        colors[2 * i + 6] = array[i + 6]\n        colors[2 * i + 7] = array[i + 7]\n      }\n    }\n\n    super.setColors(colors, itemSize)\n\n    return this\n  }\n\n  fromLine(line) {\n    const geometry = line.geometry\n\n    this.setPositions(geometry.attributes.position.array) // assumes non-indexed\n\n    // set colors, maybe\n\n    return this\n  }\n}\n\nexport { LineGeometry }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2590, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/lines/Line2.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/lines/Line2.js"],"sourcesContent":["import { LineSegments2 } from '../lines/LineSegments2'\nimport { LineGeometry } from '../lines/LineGeometry'\nimport { LineMaterial } from '../lines/LineMaterial'\n\nclass Line2 extends LineSegments2 {\n  constructor(geometry = new LineGeometry(), material = new LineMaterial({ color: Math.random() * 0xffffff })) {\n    super(geometry, material)\n\n    this.isLine2 = true\n\n    this.type = 'Line2'\n  }\n}\n\nexport { Line2 }\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;0BAIA;;;;uBACc,iEAAW,IAAI,2KAAA,CAAc,cAAE,iEAAW,IAAI,2KAAA,CAAa;YAAE,OAAO,KAAK,MAAA,KAAW;QAAU,CAAA,GAAG;;;gBAC3G;YAAM;YAAU,QAAQ;;QAExB,MAAK,OAAA,GAAU;QAEf,MAAK,IAAA,GAAO;;;WANV;EAAc,6KAAA,CAAc"}},
    {"offset": {"line": 2631, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/types/helpers.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/types/helpers.ts"],"sourcesContent":["export const getWithKey = <T, K extends keyof T>(obj: T, key: K): T[K] => obj[key]\n"],"names":[],"mappings":";;;;AAAO,IAAM,aAAa,SAAuB,KAAQ;WAAiB,GAAA,CAAI,GAAG,CAAA"}},
    {"offset": {"line": 2644, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/utils/BufferGeometryUtils.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/utils/BufferGeometryUtils.ts"],"sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  TrianglesDrawMode,\n  Vector3,\n  Mesh,\n  Line,\n  Points,\n  Material,\n  SkinnedMesh,\n} from 'three'\n\nimport { getWithKey } from '../types/helpers'\nimport type { TypedArrayConstructors, TypedArray } from '../types/shared'\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nexport const mergeBufferGeometries = (geometries: BufferGeometry[], useGroups?: boolean): BufferGeometry | null => {\n  const isIndexed = geometries[0].index !== null\n\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes))\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes))\n\n  const attributes: { [key: string]: Array<InterleavedBufferAttribute | BufferAttribute> } = {}\n  const morphAttributes: { [key: string]: Array<BufferAttribute | InterleavedBufferAttribute>[] } = {}\n\n  const morphTargetsRelative = geometries[0].morphTargetsRelative\n\n  const mergedGeometry = new BufferGeometry()\n\n  let offset = 0\n\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0\n\n    // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.',\n      )\n      return null\n    }\n\n    // gather attributes, exit early if they're different\n\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. All geometries must have compatible attributes; make sure \"' +\n            name +\n            '\" attribute exists among all geometries, or in none of them.',\n        )\n        return null\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = []\n      }\n\n      attributes[name].push(geom.attributes[name])\n\n      attributesCount++\n    }\n\n    // ensure geometries have the same number of attributes\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. Make sure all geometries have the same number of attributes.',\n      )\n      return null\n    }\n\n    // gather morph attributes, exit early if they're different\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. .morphTargetsRelative must be consistent throughout all geometries.',\n      )\n      return null\n    }\n\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '.  .morphAttributes must be consistent throughout all geometries.',\n        )\n        return null\n      }\n\n      if (morphAttributes[name] === undefined) morphAttributes[name] = []\n\n      morphAttributes[name].push(geom.morphAttributes[name])\n    }\n\n    // gather .userData\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || []\n    mergedGeometry.userData.mergedUserData.push(geom.userData)\n\n    if (useGroups) {\n      let count\n\n      if (geom.index) {\n        count = geom.index.count\n      } else if (geom.attributes.position !== undefined) {\n        count = geom.attributes.position.count\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. The geometry must have either an index or a position attribute',\n        )\n        return null\n      }\n\n      mergedGeometry.addGroup(offset, count, i)\n\n      offset += count\n    }\n  })\n\n  // merge indices\n\n  if (isIndexed) {\n    let indexOffset = 0\n    const mergedIndex: number[] = []\n\n    geometries.forEach((geom) => {\n      const index = geom.index as BufferAttribute\n\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset)\n      }\n\n      indexOffset += geom.attributes.position.count\n    })\n\n    mergedGeometry.setIndex(mergedIndex)\n  }\n\n  // merge attributes\n\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name] as BufferAttribute[])\n\n    if (!mergedAttribute) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.',\n      )\n      return null\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute)\n  }\n\n  // merge morph attributes\n\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length\n\n    if (numMorphTargets === 0) break\n\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {}\n    mergedGeometry.morphAttributes[name] = []\n\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = []\n\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i])\n      }\n\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge as BufferAttribute[])\n\n      if (!mergedMorphAttribute) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' +\n            name +\n            ' morphAttribute.',\n        )\n        return null\n      }\n\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)\n    }\n  }\n\n  return mergedGeometry\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nexport const mergeBufferAttributes = (attributes: BufferAttribute[]): BufferAttribute | null | undefined => {\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let itemSize: number | undefined = undefined\n  let normalized: boolean | undefined = undefined\n  let arrayLength = 0\n\n  attributes.forEach((attr) => {\n    if (TypedArray === undefined) {\n      TypedArray = attr.array.constructor\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.',\n      )\n      return null\n    }\n\n    if (itemSize === undefined) itemSize = attr.itemSize\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    if (normalized === undefined) normalized = attr.normalized\n    if (normalized !== attr.normalized) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    arrayLength += attr.array.length\n  })\n\n  if (TypedArray && itemSize) {\n    // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n    const array = new TypedArray(arrayLength)\n    let offset = 0\n\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset)\n      offset += attr.array.length\n    })\n\n    return new BufferAttribute(array, itemSize, normalized)\n  }\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nexport const interleaveAttributes = (attributes: BufferAttribute[]): InterleavedBufferAttribute[] | null => {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let arrayLength = 0\n  let stride = 0\n\n  // calculate the the length and type of the interleavedBuffer\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i]\n\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved')\n      return null\n    }\n\n    arrayLength += attribute.array.length\n    stride += attribute.itemSize\n  }\n\n  // Create the set of buffer attributes\n  // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride)\n  let offset = 0\n  const res = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n  const setters = ['setX', 'setY', 'setZ', 'setW']\n\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j]\n    const itemSize = attribute.itemSize\n    const count = attribute.count\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized)\n    res.push(iba)\n\n    offset += itemSize\n\n    // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k] as keyof InterleavedBufferAttribute) as InterleavedBufferAttribute[\n          | 'setX'\n          | 'setY'\n          | 'setZ'\n          | 'setW']\n        const get = getWithKey(attribute, getters[k] as keyof BufferAttribute) as BufferAttribute[\n          | 'getX'\n          | 'getY'\n          | 'getZ'\n          | 'getW']\n        set(c, get(c))\n      }\n    }\n  }\n\n  return res\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nexport function estimateBytesUsed(geometry: BufferGeometry): number {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name)\n    mem += attr.count * attr.itemSize * (attr.array as TypedArray).BYTES_PER_ELEMENT\n  }\n\n  const indices = geometry.getIndex()\n  mem += indices ? indices.count * indices.itemSize * (indices.array as TypedArray).BYTES_PER_ELEMENT : 0\n  return mem\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nexport function mergeVertices(geometry: BufferGeometry, tolerance = 1e-4): BufferGeometry {\n  tolerance = Math.max(tolerance, Number.EPSILON)\n\n  // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n  const hashToIndex: {\n    [key: string]: number\n  } = {}\n  const indices = geometry.getIndex()\n  const positions = geometry.getAttribute('position')\n  const vertexCount = indices ? indices.count : positions.count\n\n  // next value for triangle indices\n  let nextIndex = 0\n\n  // attributes and new attribute arrays\n  const attributeNames = Object.keys(geometry.attributes)\n  const attrArrays: {\n    [key: string]: []\n  } = {}\n  const morphAttrsArrays: {\n    [key: string]: Array<Array<BufferAttribute | InterleavedBufferAttribute>>\n  } = {}\n  const newIndices = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n\n  // initialize the arrays\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n\n    attrArrays[name] = []\n\n    const morphAttr = geometry.morphAttributes[name]\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => [])\n    }\n  }\n\n  // convert the error tolerance to an amount of decimal places to truncate to\n  const decimalShift = Math.log10(1 / tolerance)\n  const shiftMultiplier = Math.pow(10, decimalShift)\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i\n\n    // Generate a hash for the vertex attributes at the current index 'i'\n    let hash = ''\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j]\n      const attribute = geometry.getAttribute(name)\n      const itemSize = attribute.itemSize\n\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        // @ts-ignore no\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`\n      }\n    }\n\n    // Add another reference to the vertex if it's already\n    // used by another index\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash])\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j]\n        const attribute = geometry.getAttribute(name)\n        const morphAttr = geometry.morphAttributes[name]\n        const itemSize = attribute.itemSize\n        const newarray = attrArrays[name]\n        const newMorphArrays = morphAttrsArrays[name]\n\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k]\n          // @ts-ignore\n          newarray.push(attribute[getterFunc](index))\n\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              // @ts-ignore\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index))\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex\n      newIndices.push(nextIndex)\n      nextIndex++\n    }\n  }\n\n  // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n  const result = geometry.clone()\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n    const oldAttribute = geometry.getAttribute(name)\n    //@ts-expect-error  something to do with functions and constructors and new\n    const buffer = new (oldAttribute.array as TypedArray).constructor(attrArrays[name])\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized)\n\n    result.setAttribute(name, attribute)\n\n    // Update the attribute arrays\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j]\n        //@ts-expect-error something to do with functions and constructors and new\n        const buffer = new (oldMorphAttribute.array as TypedArray).constructor(morphAttrsArrays[name][j])\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized)\n        result.morphAttributes[name][j] = morphAttribute\n      }\n    }\n  }\n\n  // indices\n\n  result.setIndex(newIndices)\n\n  return result\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nexport function toTrianglesDrawMode(geometry: BufferGeometry, drawMode: number): BufferGeometry {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.')\n    return geometry\n  }\n\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex()\n\n    // generate index if not present\n\n    if (index === null) {\n      const indices = []\n\n      const position = geometry.getAttribute('position')\n\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i)\n        }\n\n        geometry.setIndex(indices)\n        index = geometry.getIndex()\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',\n        )\n        return geometry\n      }\n    }\n\n    //\n\n    const numberOfTriangles = (index as BufferAttribute).count - 2\n    const newIndices = []\n\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0))\n          newIndices.push(index.getX(i))\n          newIndices.push(index.getX(i + 1))\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i + 2))\n          } else {\n            newIndices.push(index.getX(i + 2))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i))\n          }\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.')\n    }\n\n    // build final geometry\n\n    const newGeometry = geometry.clone()\n    newGeometry.setIndex(newIndices)\n    newGeometry.clearGroups()\n\n    return newGeometry\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode)\n    return geometry\n  }\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nexport type ComputedMorphedAttribute = {\n  positionAttribute: BufferAttribute | InterleavedBufferAttribute\n  normalAttribute: BufferAttribute | InterleavedBufferAttribute\n  morphedPositionAttribute: Float32BufferAttribute\n  morphedNormalAttribute: Float32BufferAttribute\n}\n\nexport function computeMorphedAttributes(object: Mesh | Line | Points): ComputedMorphedAttribute | null {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.')\n    return null\n  }\n\n  const _vA = new Vector3()\n  const _vB = new Vector3()\n  const _vC = new Vector3()\n\n  const _tempA = new Vector3()\n  const _tempB = new Vector3()\n  const _tempC = new Vector3()\n\n  const _morphA = new Vector3()\n  const _morphB = new Vector3()\n  const _morphC = new Vector3()\n\n  function _calculateMorphedAttributeData(\n    object: Mesh | Line | Points,\n    material: Material,\n    attribute: BufferAttribute | InterleavedBufferAttribute,\n    morphAttribute: (BufferAttribute | InterleavedBufferAttribute)[],\n    morphTargetsRelative: boolean,\n    a: number,\n    b: number,\n    c: number,\n    modifiedAttributeArray: Float32Array,\n  ): void {\n    _vA.fromBufferAttribute(attribute, a)\n    _vB.fromBufferAttribute(attribute, b)\n    _vC.fromBufferAttribute(attribute, c)\n\n    const morphInfluences = object.morphTargetInfluences\n\n    if (\n      // @ts-ignore\n      material.morphTargets &&\n      morphAttribute &&\n      morphInfluences\n    ) {\n      _morphA.set(0, 0, 0)\n      _morphB.set(0, 0, 0)\n      _morphC.set(0, 0, 0)\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i]\n        const morph = morphAttribute[i]\n\n        if (influence === 0) continue\n\n        _tempA.fromBufferAttribute(morph, a)\n        _tempB.fromBufferAttribute(morph, b)\n        _tempC.fromBufferAttribute(morph, c)\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence)\n          _morphB.addScaledVector(_tempB, influence)\n          _morphC.addScaledVector(_tempC, influence)\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence)\n          _morphB.addScaledVector(_tempB.sub(_vB), influence)\n          _morphC.addScaledVector(_tempC.sub(_vC), influence)\n        }\n      }\n\n      _vA.add(_morphA)\n      _vB.add(_morphB)\n      _vC.add(_morphC)\n    }\n\n    if ((object as SkinnedMesh).isSkinnedMesh) {\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(a, _vA)\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(b, _vB)\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(c, _vC)\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x\n    modifiedAttributeArray[a * 3 + 1] = _vA.y\n    modifiedAttributeArray[a * 3 + 2] = _vA.z\n    modifiedAttributeArray[b * 3 + 0] = _vB.x\n    modifiedAttributeArray[b * 3 + 1] = _vB.y\n    modifiedAttributeArray[b * 3 + 2] = _vB.z\n    modifiedAttributeArray[c * 3 + 0] = _vC.x\n    modifiedAttributeArray[c * 3 + 1] = _vC.y\n    modifiedAttributeArray[c * 3 + 2] = _vC.z\n  }\n\n  const geometry = object.geometry\n  const material = object.material\n\n  let a, b, c\n  const index = geometry.index\n  const positionAttribute = geometry.attributes.position\n  const morphPosition = geometry.morphAttributes.position\n  const morphTargetsRelative = geometry.morphTargetsRelative\n  const normalAttribute = geometry.attributes.normal\n  const morphNormal = geometry.morphAttributes.position\n\n  const groups = geometry.groups\n  const drawRange = geometry.drawRange\n  let i, j, il, jl\n  let group, groupMaterial\n  let start, end\n\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize)\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize)\n\n  if (index !== null) {\n    // indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j)\n          b = index.getX(j + 1)\n          c = index.getX(j + 2)\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(index.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i)\n        b = index.getX(i + 1)\n        c = index.getX(i + 2)\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  } else if (positionAttribute !== undefined) {\n    // non-indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j\n          b = j + 1\n          c = j + 2\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i\n        b = i + 1\n        c = i + 2\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  }\n\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3)\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3)\n\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute,\n  }\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * Backwards compatible with code such as @react-three/drei's `<RoundedBox>`\n * which uses this method to operate on the original geometry.\n *\n * As of this writing, BufferGeometry.toNonIndexed() warns if the geometry is\n * non-indexed and returns `this`, i.e. the same geometry on which it was called:\n * `BufferGeometry is already non-indexed.`\n *\n * @param geometry\n * @param creaseAngle\n */\nexport function toCreasedNormals(geometry: BufferGeometry, creaseAngle = Math.PI / 3 /* 60 degrees */): BufferGeometry {\n  const creaseDot = Math.cos(creaseAngle)\n  const hashMultiplier = (1 + 1e-10) * 1e2\n\n  // reusable vectors\n  const verts = [new Vector3(), new Vector3(), new Vector3()]\n  const tempVec1 = new Vector3()\n  const tempVec2 = new Vector3()\n  const tempNorm = new Vector3()\n  const tempNorm2 = new Vector3()\n\n  // hashes a vector\n  function hashVertex(v: Vector3): string {\n    const x = ~~(v.x * hashMultiplier)\n    const y = ~~(v.y * hashMultiplier)\n    const z = ~~(v.z * hashMultiplier)\n    return `${x},${y},${z}`\n  }\n\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry\n  const posAttr = resultGeometry.attributes.position\n  const vertexMap: { [key: string]: Vector3[] } = {}\n\n  // find all the normals shared by commonly located vertices\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    // add the normal to the map for all vertices\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize()\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = []\n      }\n\n      vertexMap[hash].push(normal)\n    }\n  }\n\n  // average normals from all vertices that share a common location if they are within the\n  // provided crease threshold\n  const normalArray = new Float32Array(posAttr.count * 3)\n  const normAttr = new BufferAttribute(normalArray, 3, false)\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    // get the face normal for this vertex\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize()\n\n    // average all normals that meet the threshold and set the normal value\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      const otherNormals = vertexMap[hash]\n      tempNorm2.set(0, 0, 0)\n\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k]\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm)\n        }\n      }\n\n      tempNorm2.normalize()\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z)\n    }\n  }\n\n  resultGeometry.setAttribute('normal', normAttr)\n  return resultGeometry\n}\n"],"names":["buffer","object","material","morphTargetsRelative","a","b","c","i","il"],"mappings":"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"}},
    {"offset": {"line": 3207, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/_polyfill/LoaderUtils.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/_polyfill/LoaderUtils.js"],"sourcesContent":["export function decodeText(array) {\n  if (typeof TextDecoder !== 'undefined') {\n    return new TextDecoder().decode(array)\n  }\n\n  // Avoid the String.fromCharCode.apply(null, array) shortcut, which\n  // throws a \"maximum call stack size exceeded\" error for large arrays.\n\n  let s = ''\n\n  for (let i = 0, il = array.length; i < il; i++) {\n    // Implicitly assumes little-endian.\n    s += String.fromCharCode(array[i])\n  }\n\n  try {\n    // merges multi-byte utf-8 characters.\n\n    return decodeURIComponent(escape(s))\n  } catch (e) {\n    // see https://github.com/mrdoob/three.js/issues/16358\n\n    return s\n  }\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,WAAW,KAAA,EAAO;IAChC,IAAI,OAAO,gBAAgB,aAAa;QACtC,OAAO,IAAI,YAAW,EAAG,MAAA,CAAO,KAAK;IACtC;IAKD,IAAI,IAAI;IAER,IAAA,IAAS,IAAI,GAAG,KAAK,MAAM,MAAA,EAAQ,IAAI,IAAI,IAAK;QAE9C,KAAK,OAAO,YAAA,CAAa,KAAA,CAAM,CAAC,CAAC;IAClC;IAED,IAAI;QAGF,OAAO,mBAAmB,OAAO,CAAC,CAAC;IACpC,EAAA,OAAQ,GAAP;QAGA,OAAO;IACR;AACH"}},
    {"offset": {"line": 3231, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/GLTFLoader.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/loaders/GLTFLoader.js"],"sourcesContent":["import {\n  AnimationClip,\n  Bone,\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  DoubleSide,\n  FileLoader,\n  FrontSide,\n  Group,\n  ImageBitmapLoader,\n  InstancedMesh,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  Interpolant,\n  InterpolateDiscrete,\n  InterpolateLinear,\n  Line,\n  LineBasicMaterial,\n  LineLoop,\n  LineSegments,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  LinearMipmapNearestFilter,\n  Loader,\n  LoaderUtils,\n  Material,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  NearestMipmapLinearFilter,\n  NearestMipmapNearestFilter,\n  NumberKeyframeTrack,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  Points,\n  PointsMaterial,\n  PropertyBinding,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  Sphere,\n  SpotLight,\n  Texture,\n  TextureLoader,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  Vector2,\n  Vector3,\n  VectorKeyframeTrack,\n  InstancedBufferAttribute,\n} from 'three'\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils'\nimport { version } from '../_polyfill/constants'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\nconst SRGBColorSpace = 'srgb'\nconst LinearSRGBColorSpace = 'srgb-linear'\nconst sRGBEncoding = 3001\nconst LinearEncoding = 3000\n\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.dracoLoader = null\n    this.ktx2Loader = null\n    this.meshoptDecoder = null\n\n    this.pluginCallbacks = []\n\n    this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsDispersionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureAVIFExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSheenExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsVolumeExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIorExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSpecularExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIridescenceExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsBumpExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFLightsExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshGpuInstancing(parser)\n    })\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    let resourcePath\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath\n    } else if (this.path !== '') {\n      // If a base path is set, resources will be relative paths from that plus the relative path of the gltf file\n      // Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'\n      // resourcePath = 'https://my-cnd-server.com/assets/models/'\n      // referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'\n      // referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'\n      const relativeUrl = LoaderUtils.extractUrlBase(url)\n      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path)\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url)\n    }\n\n    // Tells the LoadingManager to track an extra item, which resolves after\n    // the model is fully loaded. This means the count of items loaded will\n    // be incorrect, but ensures manager.onLoad() does not fire early.\n    this.manager.itemStart(url)\n\n    const _onError = function (e) {\n      if (onError) {\n        onError(e)\n      } else {\n        console.error(e)\n      }\n\n      scope.manager.itemError(url)\n      scope.manager.itemEnd(url)\n    }\n\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function (gltf) {\n              onLoad(gltf)\n\n              scope.manager.itemEnd(url)\n            },\n            _onError,\n          )\n        } catch (e) {\n          _onError(e)\n        }\n      },\n      onProgress,\n      _onError,\n    )\n  }\n\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader\n    return this\n  }\n\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".')\n  }\n\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader\n    return this\n  }\n\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder\n    return this\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback)\n    }\n\n    return this\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)\n    }\n\n    return this\n  }\n\n  parse(data, path, onLoad, onError) {\n    let json\n    const extensions = {}\n    const plugins = {}\n\n    if (typeof data === 'string') {\n      json = JSON.parse(data)\n    } else if (data instanceof ArrayBuffer) {\n      const magic = decodeText(new Uint8Array(data.slice(0, 4)))\n\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data)\n        } catch (error) {\n          if (onError) onError(error)\n          return\n        }\n\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content)\n      } else {\n        json = JSON.parse(decodeText(new Uint8Array(data)))\n      }\n    } else {\n      json = data\n    }\n\n    if (json.asset === undefined || json.asset.version[0] < 2) {\n      if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'))\n      return\n    }\n\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || '',\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder,\n    })\n\n    parser.fileLoader.setRequestHeader(this.requestHeader)\n\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser)\n\n      if (!plugin.name) console.error('THREE.GLTFLoader: Invalid plugin found: missing name')\n\n      plugins[plugin.name] = plugin\n\n      // Workaround to avoid determining as unknown extension\n      // in addUnknownExtensionsToUserData().\n      // Remove this workaround if we move all the existing\n      // extension handlers to plugin system\n      extensions[plugin.name] = true\n    }\n\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i]\n        const extensionsRequired = json.extensionsRequired || []\n\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension()\n            break\n\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader)\n            break\n\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension()\n            break\n\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension()\n            break\n\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".')\n            }\n        }\n      }\n    }\n\n    parser.setExtensions(extensions)\n    parser.setPlugins(plugins)\n    parser.parse(onLoad, onError)\n  }\n\n  parseAsync(data, path) {\n    const scope = this\n\n    return new Promise(function (resolve, reject) {\n      scope.parse(data, path, resolve, reject)\n    })\n  }\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n  let objects = {}\n\n  return {\n    get: function (key) {\n      return objects[key]\n    },\n\n    add: function (key, object) {\n      objects[key] = object\n    },\n\n    remove: function (key) {\n      delete objects[key]\n    },\n\n    removeAll: function () {\n      objects = {}\n    },\n  }\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n  KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\n  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n  EXT_MATERIALS_BUMP: 'EXT_materials_bump',\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n  EXT_TEXTURE_AVIF: 'EXT_texture_avif',\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing',\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL\n\n    // Object3D instance caches\n    this.cache = { refs: {}, uses: {} }\n  }\n\n  _markDefs() {\n    const parser = this.parser\n    const nodeDefs = this.parser.json.nodes || []\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light)\n      }\n    }\n  }\n\n  _loadLight(lightIndex) {\n    const parser = this.parser\n    const cacheKey = 'light:' + lightIndex\n    let dependency = parser.cache.get(cacheKey)\n\n    if (dependency) return dependency\n\n    const json = parser.json\n    const extensions = (json.extensions && json.extensions[this.name]) || {}\n    const lightDefs = extensions.lights || []\n    const lightDef = lightDefs[lightIndex]\n    let lightNode\n\n    const color = new Color(0xffffff)\n\n    if (lightDef.color !== undefined)\n      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace)\n\n    const range = lightDef.range !== undefined ? lightDef.range : 0\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color)\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      case 'point':\n        lightNode = new PointLight(color)\n        lightNode.distance = range\n        break\n\n      case 'spot':\n        lightNode = new SpotLight(color)\n        lightNode.distance = range\n        // Handle spotlight properties.\n        lightDef.spot = lightDef.spot || {}\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0\n        lightDef.spot.outerConeAngle =\n          lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0\n        lightNode.angle = lightDef.spot.outerConeAngle\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type)\n    }\n\n    // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n    lightNode.position.set(0, 0, 0)\n\n    lightNode.decay = 2\n\n    assignExtrasToUserData(lightNode, lightDef)\n\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity\n\n    lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex)\n\n    dependency = Promise.resolve(lightNode)\n\n    parser.cache.add(cacheKey, dependency)\n\n    return dependency\n  }\n\n  getDependency(type, index) {\n    if (type !== 'light') return\n\n    return this._loadLight(index)\n  }\n\n  createNodeAttachment(nodeIndex) {\n    const self = this\n    const parser = this.parser\n    const json = parser.json\n    const nodeDef = json.nodes[nodeIndex]\n    const lightDef = (nodeDef.extensions && nodeDef.extensions[this.name]) || {}\n    const lightIndex = lightDef.light\n\n    if (lightIndex === undefined) return null\n\n    return this._loadLight(lightIndex).then(function (light) {\n      return parser._getNodeRef(self.cache, lightIndex, light)\n    })\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT\n  }\n\n  getMaterialType() {\n    return MeshBasicMaterial\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pending = []\n\n    materialParams.color = new Color(1.0, 1.0, 1.0)\n    materialParams.opacity = 1.0\n\n    const metallicRoughness = materialDef.pbrMetallicRoughness\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace))\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength\n\n    if (emissiveStrength !== undefined) {\n      materialParams.emissiveIntensity = emissiveStrength\n    }\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.clearcoatFactor !== undefined) {\n      materialParams.clearcoat = extension.clearcoatFactor\n    }\n\n    if (extension.clearcoatTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture))\n    }\n\n    if (extension.clearcoatRoughnessFactor !== undefined) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor\n    }\n\n    if (extension.clearcoatRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture))\n    }\n\n    if (extension.clearcoatNormalTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture))\n\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\n        const scale = extension.clearcoatNormalTexture.scale\n\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion\n */\nclass GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.iridescenceFactor !== undefined) {\n      materialParams.iridescence = extension.iridescenceFactor\n    }\n\n    if (extension.iridescenceTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'iridescenceMap', extension.iridescenceTexture))\n    }\n\n    if (extension.iridescenceIor !== undefined) {\n      materialParams.iridescenceIOR = extension.iridescenceIor\n    }\n\n    if (materialParams.iridescenceThicknessRange === undefined) {\n      materialParams.iridescenceThicknessRange = [100, 400]\n    }\n\n    if (extension.iridescenceThicknessMinimum !== undefined) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum\n    }\n\n    if (extension.iridescenceThicknessMaximum !== undefined) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum\n    }\n\n    if (extension.iridescenceThicknessTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    materialParams.sheenColor = new Color(0, 0, 0)\n    materialParams.sheenRoughness = 0\n    materialParams.sheen = 1\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.sheenColorFactor !== undefined) {\n      const colorFactor = extension.sheenColorFactor\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace)\n    }\n\n    if (extension.sheenRoughnessFactor !== undefined) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor\n    }\n\n    if (extension.sheenColorTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace))\n    }\n\n    if (extension.sheenRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.transmissionFactor !== undefined) {\n      materialParams.transmission = extension.transmissionFactor\n    }\n\n    if (extension.transmissionTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0\n\n    if (extension.thicknessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture))\n    }\n\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity\n\n    const colorArray = extension.attenuationColor || [1, 1, 1]\n    materialParams.attenuationColor = new Color().setRGB(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n      LinearSRGBColorSpace,\n    )\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0\n\n    if (extension.specularTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture))\n    }\n\n    const colorArray = extension.specularColorFactor || [1, 1, 1]\n    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace)\n\n    if (extension.specularColorTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n */\nclass GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0\n\n    if (extension.bumpTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'bumpMap', extension.bumpTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.anisotropyStrength !== undefined) {\n      materialParams.anisotropy = extension.anisotropyStrength\n    }\n\n    if (extension.anisotropyRotation !== undefined) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation\n    }\n\n    if (extension.anisotropyTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'anisotropyMap', extension.anisotropyTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU\n  }\n\n  loadTexture(textureIndex) {\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[this.name]\n    const loader = parser.options.ktx2Loader\n\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures')\n      } else {\n        // Assumes that the extension is optional and that a fallback texture is present\n        return null\n      }\n    }\n\n    return parser.loadTextureImage(textureIndex, extension.source, loader)\n  }\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image. Support for lossy images doesn't guarantee support for all\n        // WebP images, unfortunately.\n        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'\n\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: AVIF required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image.\n        image.src =\n          'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION\n    this.parser = parser\n  }\n\n  loadBufferView(index) {\n    const json = this.parser.json\n    const bufferView = json.bufferViews[index]\n\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name]\n\n      const buffer = this.parser.getDependency('buffer', extensionDef.buffer)\n      const decoder = this.parser.options.meshoptDecoder\n\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files')\n        } else {\n          // Assumes that the extension is optional and that fallback buffer data is present\n          return null\n        }\n      }\n\n      return buffer.then(function (res) {\n        const byteOffset = extensionDef.byteOffset || 0\n        const byteLength = extensionDef.byteLength || 0\n\n        const count = extensionDef.count\n        const stride = extensionDef.byteStride\n\n        const source = new Uint8Array(res, byteOffset, byteLength)\n\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder\n            .decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter)\n            .then(function (res) {\n              return res.buffer\n            })\n        } else {\n          // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n          return decoder.ready.then(function () {\n            const result = new ArrayBuffer(count * stride)\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter,\n            )\n            return result\n          })\n        }\n      })\n    } else {\n      return null\n    }\n  }\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING\n    this.parser = parser\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === undefined) {\n      return null\n    }\n\n    const meshDef = json.meshes[nodeDef.mesh]\n\n    // No Points or Lines + Instancing support yet\n\n    for (const primitive of meshDef.primitives) {\n      if (\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n        primitive.mode !== undefined\n      ) {\n        return null\n      }\n    }\n\n    const extensionDef = nodeDef.extensions[this.name]\n    const attributesDef = extensionDef.attributes\n\n    // @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n    const pending = []\n    const attributes = {}\n\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency('accessor', attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor\n          return attributes[key]\n        }),\n      )\n    }\n\n    if (pending.length < 1) {\n      return null\n    }\n\n    pending.push(this.parser.createNodeMesh(nodeIndex))\n\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop()\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject]\n      const count = results[0].count // All attribute counts should be same\n      const instancedMeshes = []\n\n      for (const mesh of meshes) {\n        // Temporal variables\n        const m = new Matrix4()\n        const p = new Vector3()\n        const q = new Quaternion()\n        const s = new Vector3(1, 1, 1)\n\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count)\n\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i)\n          }\n\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i)\n          }\n\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i)\n          }\n\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s))\n        }\n\n        // Add instance attributes to the geometry, excluding TRS.\n        for (const attributeName in attributes) {\n          if (attributeName === '_COLOR_0') {\n            const attr = attributes[attributeName]\n            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized)\n          } else if (attributeName !== 'TRANSLATION' && attributeName !== 'ROTATION' && attributeName !== 'SCALE') {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName])\n          }\n        }\n\n        // Just in case\n        Object3D.prototype.copy.call(instancedMesh, mesh)\n\n        this.parser.assignFinalMaterial(instancedMesh)\n\n        instancedMeshes.push(instancedMesh)\n      }\n\n      if (nodeObject.isGroup) {\n        nodeObject.clear()\n\n        nodeObject.add(...instancedMeshes)\n\n        return nodeObject\n      }\n\n      return instancedMeshes[0]\n    })\n  }\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF'\nconst BINARY_EXTENSION_HEADER_LENGTH = 12\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4e4f534a, BIN: 0x004e4942 }\n\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF\n    this.content = null\n    this.body = null\n\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH)\n\n    this.header = {\n      magic: decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true),\n    }\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.')\n    }\n\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH)\n    let chunkIndex = 0\n\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      const chunkType = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength)\n        this.content = decodeText(contentArray)\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex\n        this.body = data.slice(byteOffset, byteOffset + chunkLength)\n      }\n\n      // Clients must ignore chunks with unknown types.\n\n      chunkIndex += chunkLength\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.')\n    }\n  }\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION\n    this.json = json\n    this.dracoLoader = dracoLoader\n    this.dracoLoader.preload()\n  }\n\n  decodePrimitive(primitive, parser) {\n    const json = this.json\n    const dracoLoader = this.dracoLoader\n    const bufferViewIndex = primitive.extensions[this.name].bufferView\n    const gltfAttributeMap = primitive.extensions[this.name].attributes\n    const threeAttributeMap = {}\n    const attributeNormalizedMap = {}\n    const attributeTypeMap = {}\n\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName]\n    }\n\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]]\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n        attributeTypeMap[threeAttributeName] = componentType.name\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve, reject) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function (geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName]\n              const normalized = attributeNormalizedMap[attributeName]\n\n              if (normalized !== undefined) attribute.normalized = normalized\n            }\n\n            resolve(geometry)\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n          LinearSRGBColorSpace,\n          reject,\n        )\n      })\n    })\n  }\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM\n  }\n\n  extendTexture(texture, transform) {\n    if (\n      (transform.texCoord === undefined || transform.texCoord === texture.channel) &&\n      transform.offset === undefined &&\n      transform.rotation === undefined &&\n      transform.scale === undefined\n    ) {\n      // See https://github.com/mrdoob/three.js/issues/21819.\n      return texture\n    }\n\n    texture = texture.clone()\n\n    if (transform.texCoord !== undefined) {\n      texture.channel = transform.texCoord\n    }\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset)\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale)\n    }\n\n    texture.needsUpdate = true\n\n    return texture\n  }\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION\n  }\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer)\n  }\n\n  copySampleValue_(index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      valueSize = this.valueSize,\n      offset = index * valueSize * 3 + valueSize\n\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i]\n    }\n\n    return result\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer\n    const values = this.sampleValues\n    const stride = this.valueSize\n\n    const stride2 = stride * 2\n    const stride3 = stride * 3\n\n    const td = t1 - t0\n\n    const p = (t - t0) / td\n    const pp = p * p\n    const ppp = pp * p\n\n    const offset1 = i1 * stride3\n    const offset0 = offset1 - stride3\n\n    const s2 = -2 * ppp + 3 * pp\n    const s3 = ppp - pp\n    const s0 = 1 - s2\n    const s1 = s3 - pp + p\n\n    // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride] // splineVertex_k\n      const m0 = values[offset0 + i + stride2] * td // outTangent_k * (t_k+1 - t_k)\n      const p1 = values[offset1 + i + stride] // splineVertex_k+1\n      const m1 = values[offset1 + i] * td // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1\n    }\n\n    return result\n  }\n}\n\nconst _q = /* @__PURE__ */ new Quaternion()\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1)\n\n    _q.fromArray(result).normalize().toArray(result)\n\n    return result\n  }\n}\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123,\n}\n\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array,\n}\n\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter,\n}\n\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping,\n}\n\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n}\n\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ...(version >= 152\n    ? {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv1',\n        TEXCOORD_2: 'uv2',\n        TEXCOORD_3: 'uv3',\n      }\n    : {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv2',\n      }),\n\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex',\n}\n\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  translation: 'position',\n  rotation: 'quaternion',\n  weights: 'morphTargetInfluences',\n}\n\nconst INTERPOLATION = {\n  CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete,\n}\n\nconst ALPHA_MODES = {\n  OPAQUE: 'OPAQUE',\n  MASK: 'MASK',\n  BLEND: 'BLEND',\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial(cache) {\n  if (cache['DefaultMaterial'] === undefined) {\n    cache['DefaultMaterial'] = new MeshStandardMaterial({\n      color: 0xffffff,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide,\n    })\n  }\n\n  return cache['DefaultMaterial']\n}\n\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  // Add unknown glTF extensions to an object's userData.\n\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === undefined) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {}\n      object.userData.gltfExtensions[name] = objectDef.extensions[name]\n    }\n  }\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== undefined) {\n    if (typeof gltfDef.extras === 'object') {\n      Object.assign(object.userData, gltfDef.extras)\n    } else {\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras)\n    }\n  }\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false\n  let hasMorphNormal = false\n  let hasMorphColor = false\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (target.POSITION !== undefined) hasMorphPosition = true\n    if (target.NORMAL !== undefined) hasMorphNormal = true\n    if (target.COLOR_0 !== undefined) hasMorphColor = true\n\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break\n  }\n\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry)\n\n  const pendingPositionAccessors = []\n  const pendingNormalAccessors = []\n  const pendingColorAccessors = []\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (hasMorphPosition) {\n      const pendingAccessor =\n        target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position\n\n      pendingPositionAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphNormal) {\n      const pendingAccessor =\n        target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal\n\n      pendingNormalAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphColor) {\n      const pendingAccessor =\n        target.COLOR_0 !== undefined ? parser.getDependency('accessor', target.COLOR_0) : geometry.attributes.color\n\n      pendingColorAccessors.push(pendingAccessor)\n    }\n  }\n\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors),\n  ]).then(function (accessors) {\n    const morphPositions = accessors[0]\n    const morphNormals = accessors[1]\n    const morphColors = accessors[2]\n\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals\n    if (hasMorphColor) geometry.morphAttributes.color = morphColors\n    geometry.morphTargetsRelative = true\n\n    return geometry\n  })\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets()\n\n  if (meshDef.weights !== undefined) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i]\n    }\n  }\n\n  // .extras has user-defined data, so check that .extras.targetNames is an array.\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames\n\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {}\n\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.')\n    }\n  }\n}\n\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey\n\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n\n  if (dracoExtension) {\n    geometryKey =\n      'draco:' +\n      dracoExtension.bufferView +\n      ':' +\n      dracoExtension.indices +\n      ':' +\n      createAttributesKey(dracoExtension.attributes)\n  } else {\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode\n  }\n\n  if (primitiveDef.targets !== undefined) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += ':' + createAttributesKey(primitiveDef.targets[i])\n    }\n  }\n\n  return geometryKey\n}\n\nfunction createAttributesKey(attributes) {\n  let attributesKey = ''\n\n  const keys = Object.keys(attributes).sort()\n\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';'\n  }\n\n  return attributesKey\n}\n\nfunction getNormalizedComponentScale(constructor) {\n  // Reference:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127\n\n    case Uint8Array:\n      return 1 / 255\n\n    case Int16Array:\n      return 1 / 32767\n\n    case Uint16Array:\n      return 1 / 65535\n\n    default:\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.')\n  }\n}\n\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return 'image/jpeg'\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return 'image/webp'\n\n  return 'image/png'\n}\n\nconst _identityMatrix = /* @__PURE__ */ new Matrix4()\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json\n    this.extensions = {}\n    this.plugins = {}\n    this.options = options\n\n    // loader object cache\n    this.cache = new GLTFRegistry()\n\n    // associations between Three.js objects and glTF elements\n    this.associations = new Map()\n\n    // BufferGeometry caching\n    this.primitiveCache = {}\n\n    // Node cache\n    this.nodeCache = {}\n\n    // Object3D instance caches\n    this.meshCache = { refs: {}, uses: {} }\n    this.cameraCache = { refs: {}, uses: {} }\n    this.lightCache = { refs: {}, uses: {} }\n\n    this.sourceCache = {}\n    this.textureCache = {}\n\n    // Track node names, to ensure no duplicates\n    this.nodeNamesUsed = {}\n\n    // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n    // expensive work of uploading a texture to the GPU off the main thread.\n\n    let isSafari = false\n    let isFirefox = false\n    let firefoxVersion = -1\n\n    if (typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined') {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true\n      isFirefox = navigator.userAgent.indexOf('Firefox') > -1\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1\n    }\n\n    if (typeof createImageBitmap === 'undefined' || isSafari || (isFirefox && firefoxVersion < 98)) {\n      this.textureLoader = new TextureLoader(this.options.manager)\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager)\n    }\n\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin)\n    this.textureLoader.setRequestHeader(this.options.requestHeader)\n\n    this.fileLoader = new FileLoader(this.options.manager)\n    this.fileLoader.setResponseType('arraybuffer')\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true)\n    }\n  }\n\n  setExtensions(extensions) {\n    this.extensions = extensions\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins\n  }\n\n  parse(onLoad, onError) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    // Clear the loader cache\n    this.cache.removeAll()\n    this.nodeCache = {}\n\n    // Mark the special nodes/meshes in json for efficient parse\n    this._invokeAll(function (ext) {\n      return ext._markDefs && ext._markDefs()\n    })\n\n    Promise.all(\n      this._invokeAll(function (ext) {\n        return ext.beforeRoot && ext.beforeRoot()\n      }),\n    )\n      .then(function () {\n        return Promise.all([\n          parser.getDependencies('scene'),\n          parser.getDependencies('animation'),\n          parser.getDependencies('camera'),\n        ])\n      })\n      .then(function (dependencies) {\n        const result = {\n          scene: dependencies[0][json.scene || 0],\n          scenes: dependencies[0],\n          animations: dependencies[1],\n          cameras: dependencies[2],\n          asset: json.asset,\n          parser: parser,\n          userData: {},\n        }\n\n        addUnknownExtensionsToUserData(extensions, result, json)\n\n        assignExtrasToUserData(result, json)\n\n        return Promise.all(\n          parser._invokeAll(function (ext) {\n            return ext.afterRoot && ext.afterRoot(result)\n          }),\n        ).then(function () {\n          for (const scene of result.scenes) {\n            scene.updateMatrixWorld()\n          }\n\n          onLoad(result)\n        })\n      })\n      .catch(onError)\n  }\n\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || []\n    const skinDefs = this.json.skins || []\n    const meshDefs = this.json.meshes || []\n\n    // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints\n\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true\n      }\n    }\n\n    // Iterate over all nodes, marking references to shared resources,\n    // as well as skeleton joints.\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.mesh !== undefined) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh)\n\n        // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true\n        }\n      }\n\n      if (nodeDef.camera !== undefined) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera)\n      }\n    }\n  }\n\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === undefined) return\n\n    if (cache.refs[index] === undefined) {\n      cache.refs[index] = cache.uses[index] = 0\n    }\n\n    cache.refs[index]++\n  }\n\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1) return object\n\n    const ref = object.clone()\n\n    // Propagates mappings to the cloned object, prevents mappings on the\n    // original object from being lost.\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original)\n      if (mappings != null) {\n        this.associations.set(clone, mappings)\n      }\n\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i])\n      }\n    }\n\n    updateMappings(object, ref)\n\n    ref.name += '_instance_' + cache.uses[index]++\n\n    return ref\n  }\n\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.push(this)\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) return result\n    }\n\n    return null\n  }\n\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.unshift(this)\n\n    const pending = []\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) pending.push(result)\n    }\n\n    return pending\n  }\n\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + ':' + index\n    let dependency = this.cache.get(cacheKey)\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index)\n          break\n\n        case 'node':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadNode && ext.loadNode(index)\n          })\n          break\n\n        case 'mesh':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMesh && ext.loadMesh(index)\n          })\n          break\n\n        case 'accessor':\n          dependency = this.loadAccessor(index)\n          break\n\n        case 'bufferView':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadBufferView && ext.loadBufferView(index)\n          })\n          break\n\n        case 'buffer':\n          dependency = this.loadBuffer(index)\n          break\n\n        case 'material':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMaterial && ext.loadMaterial(index)\n          })\n          break\n\n        case 'texture':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadTexture && ext.loadTexture(index)\n          })\n          break\n\n        case 'skin':\n          dependency = this.loadSkin(index)\n          break\n\n        case 'animation':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadAnimation && ext.loadAnimation(index)\n          })\n          break\n\n        case 'camera':\n          dependency = this.loadCamera(index)\n          break\n\n        default:\n          dependency = this._invokeOne(function (ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index)\n          })\n\n          if (!dependency) {\n            throw new Error('Unknown type: ' + type)\n          }\n\n          break\n      }\n\n      this.cache.add(cacheKey, dependency)\n    }\n\n    return dependency\n  }\n\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type)\n\n    if (!dependencies) {\n      const parser = this\n      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || []\n\n      dependencies = Promise.all(\n        defs.map(function (def, index) {\n          return parser.getDependency(type, index)\n        }),\n      )\n\n      this.cache.add(type, dependencies)\n    }\n\n    return dependencies\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex]\n    const loader = this.fileLoader\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.')\n    }\n\n    // If present, GLB container is required to be the first buffer.\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body)\n    }\n\n    const options = this.options\n\n    return new Promise(function (resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'))\n      })\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex]\n\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      const byteLength = bufferViewDef.byteLength || 0\n      const byteOffset = bufferViewDef.byteOffset || 0\n      return buffer.slice(byteOffset, byteOffset + byteLength)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this\n    const json = this.json\n\n    const accessorDef = this.json.accessors[accessorIndex]\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n      const normalized = accessorDef.normalized === true\n\n      const array = new TypedArray(accessorDef.count * itemSize)\n      return Promise.resolve(new BufferAttribute(array, itemSize, normalized))\n    }\n\n    const pendingBufferViews = []\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView))\n    } else {\n      pendingBufferViews.push(null)\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView))\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView))\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      const bufferView = bufferViews[0]\n\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n      // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT\n      const itemBytes = elementBytes * itemSize\n      const byteOffset = accessorDef.byteOffset || 0\n      const byteStride =\n        accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined\n      const normalized = accessorDef.normalized === true\n      let array, bufferAttribute\n\n      // The buffer is not interleaved if the stride is the item size in bytes.\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        const ibSlice = Math.floor(byteOffset / byteStride)\n        const ibCacheKey =\n          'InterleavedBuffer:' +\n          accessorDef.bufferView +\n          ':' +\n          accessorDef.componentType +\n          ':' +\n          ibSlice +\n          ':' +\n          accessorDef.count\n        let ib = parser.cache.get(ibCacheKey)\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, (accessorDef.count * byteStride) / elementBytes)\n\n          // Integer parameters to IB/IBA are in array elements, not bytes.\n          ib = new InterleavedBuffer(array, byteStride / elementBytes)\n\n          parser.cache.add(ibCacheKey, ib)\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          (byteOffset % byteStride) / elementBytes,\n          normalized,\n        )\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize)\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize)\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized)\n      }\n\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n      if (accessorDef.sparse !== undefined) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType]\n\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0\n\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices,\n        )\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize)\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized,\n          )\n        }\n\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i]\n\n          bufferAttribute.setX(index, sparseValues[i * itemSize])\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1])\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2])\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3])\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')\n        }\n      }\n\n      return bufferAttribute\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json\n    const options = this.options\n    const textureDef = json.textures[textureIndex]\n    const sourceIndex = textureDef.source\n    const sourceDef = json.images[sourceIndex]\n\n    let loader = this.textureLoader\n\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.loadTextureImage(textureIndex, sourceIndex, loader)\n  }\n\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n\n    const textureDef = json.textures[textureIndex]\n    const sourceDef = json.images[sourceIndex]\n\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ':' + textureDef.sampler\n\n    if (this.textureCache[cacheKey]) {\n      // See https://github.com/mrdoob/three.js/issues/21559.\n      return this.textureCache[cacheKey]\n    }\n\n    const promise = this.loadImageSource(sourceIndex, loader)\n      .then(function (texture) {\n        texture.flipY = false\n\n        texture.name = textureDef.name || sourceDef.name || ''\n\n        if (\n          texture.name === '' &&\n          typeof sourceDef.uri === 'string' &&\n          sourceDef.uri.startsWith('data:image/') === false\n        ) {\n          texture.name = sourceDef.uri\n        }\n\n        const samplers = json.samplers || {}\n        const sampler = samplers[textureDef.sampler] || {}\n\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter\n        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping\n\n        parser.associations.set(texture, { textures: textureIndex })\n\n        return texture\n      })\n      .catch(function () {\n        return null\n      })\n\n    this.textureCache[cacheKey] = promise\n\n    return promise\n  }\n\n  loadImageSource(sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n    const options = this.options\n\n    if (this.sourceCache[sourceIndex] !== undefined) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone())\n    }\n\n    const sourceDef = json.images[sourceIndex]\n\n    const URL = self.URL || self.webkitURL\n\n    let sourceURI = sourceDef.uri || ''\n    let isObjectURL = false\n\n    if (sourceDef.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n\n      sourceURI = parser.getDependency('bufferView', sourceDef.bufferView).then(function (bufferView) {\n        isObjectURL = true\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType })\n        sourceURI = URL.createObjectURL(blob)\n        return sourceURI\n      })\n    } else if (sourceDef.uri === undefined) {\n      throw new Error('THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView')\n    }\n\n    const promise = Promise.resolve(sourceURI)\n      .then(function (sourceURI) {\n        return new Promise(function (resolve, reject) {\n          let onLoad = resolve\n\n          if (loader.isImageBitmapLoader === true) {\n            onLoad = function (imageBitmap) {\n              const texture = new Texture(imageBitmap)\n              texture.needsUpdate = true\n\n              resolve(texture)\n            }\n          }\n\n          loader.load(LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject)\n        })\n      })\n      .then(function (texture) {\n        // Clean up resources and configure Texture.\n\n        if (isObjectURL === true) {\n          URL.revokeObjectURL(sourceURI)\n        }\n\n        assignExtrasToUserData(texture, sourceDef)\n\n        texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri)\n\n        return texture\n      })\n      .catch(function (error) {\n        console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI)\n        throw error\n      })\n\n    this.sourceCache[sourceIndex] = promise\n    return promise\n  }\n\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this\n\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      if (!texture) return null\n\n      if (mapDef.texCoord !== undefined && mapDef.texCoord > 0) {\n        texture = texture.clone()\n        texture.channel = mapDef.texCoord\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform =\n          mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined\n\n        if (transform) {\n          const gltfReference = parser.associations.get(texture)\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform)\n          parser.associations.set(texture, gltfReference)\n        }\n      }\n\n      if (colorSpace !== undefined) {\n        // Convert from legacy encoding to colorSpace\n        if (typeof colorSpace === 'number')\n          colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace\n\n        // Set colorSpace if able, fallback to legacy encoding\n        if ('colorSpace' in texture) texture.colorSpace = colorSpace\n        else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n      }\n\n      materialParams[mapName] = texture\n\n      return texture\n    })\n  }\n\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry\n    let material = mesh.material\n\n    const useDerivativeTangents = geometry.attributes.tangent === undefined\n    const useVertexColors = geometry.attributes.color !== undefined\n    const useFlatShading = geometry.attributes.normal === undefined\n\n    if (mesh.isPoints) {\n      const cacheKey = 'PointsMaterial:' + material.uuid\n\n      let pointsMaterial = this.cache.get(cacheKey)\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial()\n        Material.prototype.copy.call(pointsMaterial, material)\n        pointsMaterial.color.copy(material.color)\n        pointsMaterial.map = material.map\n        pointsMaterial.sizeAttenuation = false // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial)\n      }\n\n      material = pointsMaterial\n    } else if (mesh.isLine) {\n      const cacheKey = 'LineBasicMaterial:' + material.uuid\n\n      let lineMaterial = this.cache.get(cacheKey)\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial()\n        Material.prototype.copy.call(lineMaterial, material)\n        lineMaterial.color.copy(material.color)\n        lineMaterial.map = material.map\n\n        this.cache.add(cacheKey, lineMaterial)\n      }\n\n      material = lineMaterial\n    }\n\n    // Clone the material if it will be modified\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = 'ClonedMaterial:' + material.uuid + ':'\n\n      if (useDerivativeTangents) cacheKey += 'derivative-tangents:'\n      if (useVertexColors) cacheKey += 'vertex-colors:'\n      if (useFlatShading) cacheKey += 'flat-shading:'\n\n      let cachedMaterial = this.cache.get(cacheKey)\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone()\n\n        if (useVertexColors) cachedMaterial.vertexColors = true\n        if (useFlatShading) cachedMaterial.flatShading = true\n\n        if (useDerivativeTangents) {\n          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1\n        }\n\n        this.cache.add(cacheKey, cachedMaterial)\n\n        this.associations.set(cachedMaterial, this.associations.get(material))\n      }\n\n      material = cachedMaterial\n    }\n\n    mesh.material = material\n  }\n\n  getMaterialType(/* materialIndex */) {\n    return MeshStandardMaterial\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n    const materialDef = json.materials[materialIndex]\n\n    let materialType\n    const materialParams = {}\n    const materialExtensions = materialDef.extensions || {}\n\n    const pending = []\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT]\n      materialType = kmuExtension.getMaterialType()\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser))\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {}\n\n      materialParams.color = new Color(1.0, 1.0, 1.0)\n      materialParams.opacity = 1.0\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace))\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0\n      materialParams.roughness =\n        metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture))\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture))\n      }\n\n      materialType = this._invokeOne(function (ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex)\n      })\n\n      pending.push(\n        Promise.all(\n          this._invokeAll(function (ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams)\n          }),\n        ),\n      )\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide\n    }\n\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true\n\n      // See: https://github.com/mrdoob/three.js/issues/17706\n      materialParams.depthWrite = false\n    } else {\n      materialParams.transparent = false\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture))\n\n      materialParams.normalScale = new Vector2(1, 1)\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        const scale = materialDef.normalTexture.scale\n\n        materialParams.normalScale.set(scale, scale)\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture))\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor\n      materialParams.emissive = new Color().setRGB(\n        emissiveFactor[0],\n        emissiveFactor[1],\n        emissiveFactor[2],\n        LinearSRGBColorSpace,\n      )\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace))\n    }\n\n    return Promise.all(pending).then(function () {\n      const material = new materialType(materialParams)\n\n      if (materialDef.name) material.name = materialDef.name\n\n      assignExtrasToUserData(material, materialDef)\n\n      parser.associations.set(material, { materials: materialIndex })\n\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef)\n\n      return material\n    })\n  }\n\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '')\n\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + '_' + ++this.nodeNamesUsed[sanitizedName]\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0\n\n      return sanitizedName\n    }\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this\n    const extensions = this.extensions\n    const cache = this.primitiveCache\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n        .decodePrimitive(primitive, parser)\n        .then(function (geometry) {\n          return addPrimitiveAttributes(geometry, primitive, parser)\n        })\n    }\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i]\n      const cacheKey = createPrimitiveKey(primitive)\n\n      // See if we've already created this geometry\n      const cached = cache[cacheKey]\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise)\n      } else {\n        let geometryPromise\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive)\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser)\n        }\n\n        // Cache this geometry\n        cache[cacheKey] = { primitive: primitive, promise: geometryPromise }\n\n        pending.push(geometryPromise)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    const meshDef = json.meshes[meshIndex]\n    const primitives = meshDef.primitives\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material =\n        primitives[i].material === undefined\n          ? createDefaultMaterial(this.cache)\n          : this.getDependency('material', primitives[i].material)\n\n      pending.push(material)\n    }\n\n    pending.push(parser.loadGeometries(primitives))\n\n    return Promise.all(pending).then(function (results) {\n      const materials = results.slice(0, results.length - 1)\n      const geometries = results[results.length - 1]\n\n      const meshes = []\n\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i]\n        const primitive = primitives[i]\n\n        // 1. create Mesh\n\n        let mesh\n\n        const material = materials[i]\n\n        if (\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n          primitive.mode === undefined\n        ) {\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material)\n\n          if (mesh.isSkinnedMesh === true) {\n            // normalize skin weights to fix malformed assets (see #15319)\n            mesh.normalizeSkinWeights()\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode)\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode)\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material)\n        } else {\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode)\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef)\n        }\n\n        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex)\n\n        assignExtrasToUserData(mesh, meshDef)\n\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive)\n\n        parser.assignFinalMaterial(mesh)\n\n        meshes.push(mesh)\n      }\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i,\n        })\n      }\n\n      if (meshes.length === 1) {\n        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef)\n\n        return meshes[0]\n      }\n\n      const group = new Group()\n\n      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef)\n\n      parser.associations.set(group, { meshes: meshIndex })\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i])\n      }\n\n      return group\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera\n    const cameraDef = this.json.cameras[cameraIndex]\n    const params = cameraDef[cameraDef.type]\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.')\n      return\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(\n        MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6,\n      )\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar)\n    }\n\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name)\n\n    assignExtrasToUserData(camera, cameraDef)\n\n    return Promise.resolve(camera)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex]\n\n    const pending = []\n\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]))\n    }\n\n    if (skinDef.inverseBindMatrices !== undefined) {\n      pending.push(this.getDependency('accessor', skinDef.inverseBindMatrices))\n    } else {\n      pending.push(null)\n    }\n\n    return Promise.all(pending).then(function (results) {\n      const inverseBindMatrices = results.pop()\n      const jointNodes = results\n\n      // Note that bones (joint nodes) may or may not be in the\n      // scene graph at this time.\n\n      const bones = []\n      const boneInverses = []\n\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i]\n\n        if (jointNode) {\n          bones.push(jointNode)\n\n          const mat = new Matrix4()\n\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16)\n          }\n\n          boneInverses.push(mat)\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i])\n        }\n      }\n\n      return new Skeleton(bones, boneInverses)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json\n    const parser = this\n\n    const animationDef = json.animations[animationIndex]\n    const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex\n\n    const pendingNodes = []\n    const pendingInputAccessors = []\n    const pendingOutputAccessors = []\n    const pendingSamplers = []\n    const pendingTargets = []\n\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i]\n      const sampler = animationDef.samplers[channel.sampler]\n      const target = channel.target\n      const name = target.node\n      const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input\n      const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output\n\n      if (target.node === undefined) continue\n\n      pendingNodes.push(this.getDependency('node', name))\n      pendingInputAccessors.push(this.getDependency('accessor', input))\n      pendingOutputAccessors.push(this.getDependency('accessor', output))\n      pendingSamplers.push(sampler)\n      pendingTargets.push(target)\n    }\n\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets),\n    ]).then(function (dependencies) {\n      const nodes = dependencies[0]\n      const inputAccessors = dependencies[1]\n      const outputAccessors = dependencies[2]\n      const samplers = dependencies[3]\n      const targets = dependencies[4]\n\n      const tracks = []\n\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i]\n        const inputAccessor = inputAccessors[i]\n        const outputAccessor = outputAccessors[i]\n        const sampler = samplers[i]\n        const target = targets[i]\n\n        if (node === undefined) continue\n\n        if (node.updateMatrix) {\n          node.updateMatrix()\n        }\n\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target)\n\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k])\n          }\n        }\n      }\n\n      return new AnimationClip(animationName, undefined, tracks)\n    })\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.json\n    const parser = this\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (nodeDef.mesh === undefined) return null\n\n    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh)\n\n      // if weights are provided on the node, override weights on the mesh.\n      if (nodeDef.weights !== undefined) {\n        node.traverse(function (o) {\n          if (!o.isMesh) return\n\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i]\n          }\n        })\n      }\n\n      return node\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json\n    const parser = this\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    const nodePending = parser._loadNodeShallow(nodeIndex)\n\n    const childPending = []\n    const childrenDef = nodeDef.children || []\n\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency('node', childrenDef[i]))\n    }\n\n    const skeletonPending =\n      nodeDef.skin === undefined ? Promise.resolve(null) : parser.getDependency('skin', nodeDef.skin)\n\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function (results) {\n      const node = results[0]\n      const children = results[1]\n      const skeleton = results[2]\n\n      if (skeleton !== null) {\n        // This full traverse should be fine because\n        // child glTF nodes have not been added to this node yet.\n        node.traverse(function (mesh) {\n          if (!mesh.isSkinnedMesh) return\n\n          mesh.bind(skeleton, _identityMatrix)\n        })\n      }\n\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i])\n      }\n\n      return node\n    })\n  }\n\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json\n    const extensions = this.extensions\n    const parser = this\n\n    // This method is called from .loadNode() and .loadSkin().\n    // Cache a node to avoid duplication.\n\n    if (this.nodeCache[nodeIndex] !== undefined) {\n      return this.nodeCache[nodeIndex]\n    }\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    // reserve node's name before its dependencies, so the root has the intended name.\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : ''\n\n    const pending = []\n\n    const meshPromise = parser._invokeOne(function (ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex)\n    })\n\n    if (meshPromise) {\n      pending.push(meshPromise)\n    }\n\n    if (nodeDef.camera !== undefined) {\n      pending.push(\n        parser.getDependency('camera', nodeDef.camera).then(function (camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera)\n        }),\n      )\n    }\n\n    parser\n      ._invokeAll(function (ext) {\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)\n      })\n      .forEach(function (promise) {\n        pending.push(promise)\n      })\n\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function (objects) {\n      let node\n\n      // .isBone isn't in glTF spec. See ._markDefs\n      if (nodeDef.isBone === true) {\n        node = new Bone()\n      } else if (objects.length > 1) {\n        node = new Group()\n      } else if (objects.length === 1) {\n        node = objects[0]\n      } else {\n        node = new Object3D()\n      }\n\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i])\n        }\n      }\n\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name\n        node.name = nodeName\n      }\n\n      assignExtrasToUserData(node, nodeDef)\n\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef)\n\n      if (nodeDef.matrix !== undefined) {\n        const matrix = new Matrix4()\n        matrix.fromArray(nodeDef.matrix)\n        node.applyMatrix4(matrix)\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation)\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation)\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale)\n        }\n      }\n\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {})\n      }\n\n      parser.associations.get(node).nodes = nodeIndex\n\n      return node\n    })\n\n    return this.nodeCache[nodeIndex]\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions\n    const sceneDef = this.json.scenes[sceneIndex]\n    const parser = this\n\n    // Loader returns Group, not Scene.\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n    const scene = new Group()\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name)\n\n    assignExtrasToUserData(scene, sceneDef)\n\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef)\n\n    const nodeIds = sceneDef.nodes || []\n\n    const pending = []\n\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency('node', nodeIds[i]))\n    }\n\n    return Promise.all(pending).then(function (nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i])\n      }\n\n      // Removes dangling associations, associations that reference a node that\n      // didn't make it into the scene.\n      const reduceAssociations = (node) => {\n        const reducedAssociations = new Map()\n\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value)\n          }\n        }\n\n        node.traverse((node) => {\n          const mappings = parser.associations.get(node)\n\n          if (mappings != null) {\n            reducedAssociations.set(node, mappings)\n          }\n        })\n\n        return reducedAssociations\n      }\n\n      parser.associations = reduceAssociations(scene)\n\n      return scene\n    })\n  }\n\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = []\n\n    const targetName = node.name ? node.name : node.uuid\n    const targetNames = []\n\n    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n      node.traverse(function (object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid)\n        }\n      })\n    } else {\n      targetNames.push(targetName)\n    }\n\n    let TypedKeyframeTrack\n\n    switch (PATH_PROPERTIES[target.path]) {\n      case PATH_PROPERTIES.weights:\n        TypedKeyframeTrack = NumberKeyframeTrack\n        break\n\n      case PATH_PROPERTIES.rotation:\n        TypedKeyframeTrack = QuaternionKeyframeTrack\n        break\n\n      case PATH_PROPERTIES.position:\n      case PATH_PROPERTIES.scale:\n        TypedKeyframeTrack = VectorKeyframeTrack\n        break\n\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = NumberKeyframeTrack\n            break\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack\n            break\n        }\n\n        break\n    }\n\n    const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear\n\n    const outputArray = this._getArrayFromAccessor(outputAccessor)\n\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(\n        targetNames[j] + '.' + PATH_PROPERTIES[target.path],\n        inputAccessor.array,\n        outputArray,\n        interpolation,\n      )\n\n      // Override interpolation with custom factory method.\n      if (sampler.interpolation === 'CUBICSPLINE') {\n        this._createCubicSplineTrackInterpolant(track)\n      }\n\n      tracks.push(track)\n    }\n\n    return tracks\n  }\n\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array\n\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor)\n      const scaled = new Float32Array(outputArray.length)\n\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale\n      }\n\n      outputArray = scaled\n    }\n\n    return outputArray\n  }\n\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n      // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n      // must be divided by three to get the interpolant's sampleSize argument.\n\n      const interpolantType =\n        this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant\n\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result)\n    }\n\n    // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true\n  }\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const box = new Box3()\n\n  if (attributes.POSITION !== undefined) {\n    const accessor = parser.json.accessors[attributes.POSITION]\n\n    const min = accessor.min\n    const max = accessor.max\n\n    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n    if (min !== undefined && max !== undefined) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]))\n\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n        box.min.multiplyScalar(boxScale)\n        box.max.multiplyScalar(boxScale)\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n\n      return\n    }\n  } else {\n    return\n  }\n\n  const targets = primitiveDef.targets\n\n  if (targets !== undefined) {\n    const maxDisplacement = new Vector3()\n    const vector = new Vector3()\n\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i]\n\n      if (target.POSITION !== undefined) {\n        const accessor = parser.json.accessors[target.POSITION]\n        const min = accessor.min\n        const max = accessor.max\n\n        // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n        if (min !== undefined && max !== undefined) {\n          // we need to get max of absolute components because target weight is [-1,1]\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])))\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])))\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])))\n\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n            vector.multiplyScalar(boxScale)\n          }\n\n          // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n          maxDisplacement.max(vector)\n        } else {\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n        }\n      }\n    }\n\n    // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n    box.expandByVector(maxDisplacement)\n  }\n\n  geometry.boundingBox = box\n\n  const sphere = new Sphere()\n\n  box.getCenter(sphere.center)\n  sphere.radius = box.min.distanceTo(box.max) / 2\n\n  geometry.boundingSphere = sphere\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const pending = []\n\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n      geometry.setAttribute(attributeName, accessor)\n    })\n  }\n\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase()\n\n    // Skip attributes already provided by e.g. Draco extension.\n    if (threeAttributeName in geometry.attributes) continue\n\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName))\n  }\n\n  if (primitiveDef.indices !== undefined && !geometry.index) {\n    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n      geometry.setIndex(accessor)\n    })\n\n    pending.push(accessor)\n  }\n\n  assignExtrasToUserData(geometry, primitiveDef)\n\n  computeBounds(geometry, primitiveDef, parser)\n\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry\n  })\n}\n\nexport { GLTFLoader }\n"],"names":["self","res","sourceURI","node","accessor"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoEA,IAAM,iBAAiB;AACvB,IAAM,uBAAuB;AAC7B,IAAM,eAAe;AACrB,IAAM,iBAAiB;+BAEvB;;;aAAM,WACQ,OAAA,EAAS;;;gBACnB;YAAM,OAAO;;QAEb,MAAK,WAAA,GAAc;QACnB,MAAK,UAAA,GAAa;QAClB,MAAK,cAAA,GAAiB;QAEtB,MAAK,eAAA,GAAkB,CAAE,CAAA;QAEzB,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,gCAAgC,MAAM;QACvD,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,iCAAiC,MAAM;QACxD,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,2BAA2B,MAAM;QAClD,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,yBAAyB,MAAM;QAChD,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,yBAAyB,MAAM;QAChD,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,4BAA4B,MAAM;QACnD,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,mCAAmC,MAAM;QAC1D,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,6BAA6B,MAAM;QACpD,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,0BAA0B,MAAM;QACjD,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,uCAAuC,MAAM;QAC9D,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,+BAA+B,MAAM;QACtD,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,kCAAkC,MAAM;QACzD,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,iCAAiC,MAAM;QACxD,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,2BAA2B,MAAM;QAClD,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,oBAAoB,MAAM;QAC3C,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,uBAAuB,MAAM;QAC9C,CAAK;QAED,MAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;YAC9B,OAAO,IAAI,sBAAsB,MAAM;QAC7C,CAAK;;;;;;4BAGH,KAAK,GAAA,EAAK,MAAA,EAAQ,UAAA,EAAY,OAAA,EAAS;gBACrC,IAAM,QAAQ,IAAA;gBAEd,IAAI;gBAEJ,IAAI,IAAA,CAAK,YAAA,KAAiB,IAAI;oBAC5B,eAAe,IAAA,CAAK,YAAA;gBAC1B,OAAA,IAAe,IAAA,CAAK,IAAA,KAAS,IAAI;oBAM3B,IAAM,cAAc,iKAAA,CAAY,cAAA,CAAe,GAAG;oBAClD,eAAe,iKAAA,CAAY,UAAA,CAAW,aAAa,IAAA,CAAK,IAAI;gBAClE,OAAW;oBACL,eAAe,iKAAA,CAAY,cAAA,CAAe,GAAG;gBAC9C;gBAKD,IAAA,CAAK,OAAA,CAAQ,SAAA,CAAU,GAAG;gBAE1B,IAAM,WAAW,kBAAU,CAAA,EAAG;oBAC5B,IAAI,SAAS;wBACX,QAAQ,CAAC;oBACjB,OAAa;wBACL,QAAQ,KAAA,CAAM,CAAC;oBAChB;oBAED,MAAM,OAAA,CAAQ,SAAA,CAAU,GAAG;oBAC3B,MAAM,OAAA,CAAQ,OAAA,CAAQ,GAAG;gBAC1B;gBAED,IAAM,SAAS,IAAI,gKAAA,CAAW,IAAA,CAAK,OAAO;gBAE1C,OAAO,OAAA,CAAQ,IAAA,CAAK,IAAI;gBACxB,OAAO,eAAA,CAAgB,aAAa;gBACpC,OAAO,gBAAA,CAAiB,IAAA,CAAK,aAAa;gBAC1C,OAAO,kBAAA,CAAmB,IAAA,CAAK,eAAe;gBAE9C,OAAO,IAAA,CACL,KACA,SAAU,IAAA,EAAM;oBACd,IAAI;wBACF,MAAM,KAAA,CACJ,MACA,cACA,SAAU,IAAA,EAAM;4BACd,OAAO,IAAI;4BAEX,MAAM,OAAA,CAAQ,OAAA,CAAQ,GAAG;wBAC1B,GACD;oBAEH,EAAA,OAAQ,GAAP;wBACA,SAAS,CAAC;oBACX;gBACF,GACD,YACA;YAEH;;;;4BAED,eAAe,WAAA,EAAa;gBAC1B,IAAA,CAAK,WAAA,GAAc;gBACnB,OAAO,IAAA;YACR;;;;4BAED,eAAe;gBACb,MAAM,IAAI,MAAM,kGAAkG;YACnH;;;;4BAED,cAAc,UAAA,EAAY;gBACxB,IAAA,CAAK,UAAA,GAAa;gBAClB,OAAO,IAAA;YACR;;;YAED;8CAAkB,cAAA,EAAgB;gBAChC,IAAA,CAAK,cAAA,GAAiB;gBACtB,OAAO,IAAA;YACR;;;;4BAED,SAAS,QAAA,EAAU;gBACjB,IAAI,IAAA,CAAK,eAAA,CAAgB,OAAA,CAAQ,QAAQ,MAAM,CAAA,GAAI;oBACjD,IAAA,CAAK,eAAA,CAAgB,IAAA,CAAK,QAAQ;gBACnC;gBAED,OAAO,IAAA;YACR;;;;4BAED,WAAW,QAAA,EAAU;gBACnB,IAAI,IAAA,CAAK,eAAA,CAAgB,OAAA,CAAQ,QAAQ,MAAM,CAAA,GAAI;oBACjD,IAAA,CAAK,eAAA,CAAgB,MAAA,CAAO,IAAA,CAAK,eAAA,CAAgB,OAAA,CAAQ,QAAQ,GAAG,CAAC;gBACtE;gBAED,OAAO,IAAA;YACR;;;YAED;kCAAM,IAAA,EAAM,IAAA,EAAM,MAAA,EAAQ,OAAA,EAAS;gBACjC,IAAI;gBACJ,IAAM,aAAa,CAAE;gBACrB,IAAM,UAAU,CAAE;gBAElB,IAAI,OAAO,SAAS,UAAU;oBAC5B,OAAO,KAAK,KAAA,CAAM,IAAI;gBAC5B,OAAA,QAAe,8JAAgB,EAAhB,oBAA6B;oBACtC,IAAM,YAAQ,4KAAA,EAAW,IAAI,WAAW,KAAK,KAAA,CAAM,GAAG,CAAC,CAAC,CAAC;oBAEzD,IAAI,UAAU,+BAA+B;wBAC3C,IAAI;4BACF,UAAA,CAAW,WAAW,eAAe,CAAA,GAAI,IAAI,oBAAoB,IAAI;wBACtE,EAAA,OAAQ,OAAP;4BACA,IAAI,SAAS,QAAQ,KAAK;4BAC1B;wBACD;wBAED,OAAO,KAAK,KAAA,CAAM,UAAA,CAAW,WAAW,eAAe,CAAA,CAAE,OAAO;oBACxE,OAAa;wBACL,OAAO,KAAK,KAAA,KAAM,4KAAA,EAAW,IAAI,WAAW,IAAI,CAAC,CAAC;oBACnD;gBACP,OAAW;oBACL,OAAO;gBACR;gBAED,IAAI,KAAK,KAAA,KAAU,KAAA,KAAa,KAAK,KAAA,CAAM,OAAA,CAAQ,CAAC,CAAA,GAAI,GAAG;oBACzD,IAAI,SAAS,QAAQ,IAAI,MAAM,yEAAyE,CAAC;oBACzG;gBACD;gBAED,IAAM,SAAS,IAAI,WAAW,MAAM;oBAClC,MAAM,QAAQ,IAAA,CAAK,YAAA,IAAgB;oBACnC,aAAa,IAAA,CAAK,WAAA;oBAClB,eAAe,IAAA,CAAK,aAAA;oBACpB,SAAS,IAAA,CAAK,OAAA;oBACd,YAAY,IAAA,CAAK,UAAA;oBACjB,gBAAgB,IAAA,CAAK,cAAA;gBAC3B,CAAK;gBAED,OAAO,UAAA,CAAW,gBAAA,CAAiB,IAAA,CAAK,aAAa;gBAErD,IAAA,IAAS,IAAI,GAAG,IAAI,IAAA,CAAK,eAAA,CAAgB,MAAA,EAAQ,IAAK;oBACpD,IAAM,SAAS,IAAA,CAAK,eAAA,CAAgB,CAAC,CAAA,CAAE,MAAM;oBAE7C,IAAI,CAAC,OAAO,IAAA,EAAM,QAAQ,KAAA,CAAM,sDAAsD;oBAEtF,OAAA,CAAQ,OAAO,IAAI,CAAA,GAAI;oBAMvB,UAAA,CAAW,OAAO,IAAI,CAAA,GAAI;gBAC3B;gBAED,IAAI,KAAK,cAAA,EAAgB;oBACvB,IAAA,IAAS,KAAI,GAAG,KAAI,KAAK,cAAA,CAAe,MAAA,EAAQ,EAAE,GAAG;wBACnD,IAAM,gBAAgB,KAAK,cAAA,CAAe,CAAC,EAAA;wBAC3C,IAAM,qBAAqB,KAAK,kBAAA,IAAsB,CAAE,CAAA;wBAExD,OAAQ,eAAa;4BACnB,KAAK,WAAW,mBAAA;gCACd,UAAA,CAAW,aAAa,CAAA,GAAI,IAAI,4BAA6B;gCAC7D;4BAEF,KAAK,WAAW,0BAAA;gCACd,UAAA,CAAW,aAAa,CAAA,GAAI,IAAI,kCAAkC,MAAM,IAAA,CAAK,WAAW;gCACxF;4BAEF,KAAK,WAAW,qBAAA;gCACd,UAAA,CAAW,aAAa,CAAA,GAAI,IAAI,8BAA+B;gCAC/D;4BAEF,KAAK,WAAW,qBAAA;gCACd,UAAA,CAAW,aAAa,CAAA,GAAI,IAAI,8BAA+B;gCAC/D;4BAEF;gCACE,IAAI,mBAAmB,OAAA,CAAQ,aAAa,KAAK,KAAK,OAAA,CAAQ,aAAa,CAAA,KAAM,KAAA,GAAW;oCAC1F,QAAQ,IAAA,CAAK,0CAA0C,gBAAgB,IAAI;gCAC5E;wBACJ;oBACF;gBACF;gBAED,OAAO,aAAA,CAAc,UAAU;gBAC/B,OAAO,UAAA,CAAW,OAAO;gBACzB,OAAO,KAAA,CAAM,QAAQ,OAAO;YAC7B;;;;4BAED,WAAW,IAAA,EAAM,IAAA,EAAM;gBACrB,IAAM,QAAQ,IAAA;gBAEd,OAAO,IAAI,QAAQ,SAAU,OAAA,EAAS,MAAA,EAAQ;oBAC5C,MAAM,KAAA,CAAM,MAAM,MAAM,SAAS,MAAM;gBAC7C,CAAK;YACF;;;;EApRsB,4JAAA,CAAO;AAyRhC,SAAS,eAAe;IACtB,IAAI,UAAU,CAAE;IAEhB,OAAO;aACA,SAAL,IAAe,GAAA,EAAK;YAClB,OAAO,OAAA,CAAQ,GAAG,CAAA;QACnB;aAEI,SAAL,IAAe,GAAA,EAAK,MAAA,EAAQ;YAC1B,OAAA,CAAQ,GAAG,CAAA,GAAI;QAChB;QAED,QAAQ,gBAAU,GAAA,EAAK;YACrB,OAAO,OAAA,CAAQ,GAAG,CAAA;QACnB;mBAEU,SAAX,EAAuB;YACrB,UAAU,CAAE;QACb;IACF;AACH;AAMA,IAAM,aAAa;IACjB,iBAAiB;IACjB,4BAA4B;IAC5B,qBAAqB;IACrB,yBAAyB;IACzB,0BAA0B;IAC1B,mBAAmB;IACnB,qBAAqB;IACrB,wBAAwB;IACxB,4BAA4B;IAC5B,2BAA2B;IAC3B,0BAA0B;IAC1B,qBAAqB;IACrB,sBAAsB;IACtB,oBAAoB;IACpB,uBAAuB;IACvB,uBAAuB;IACvB,iCAAiC;IACjC,oBAAoB;IACpB,kBAAkB;IAClB,kBAAkB;IAClB,yBAAyB;IACzB,yBAAyB;AAC3B;wCAOA;;aAAM,oBAAoB,AACZ,MAAA,EAAQ;;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,mBAAA;QAGvB,IAAA,CAAK,KAAA,GAAQ;YAAE,MAAM,CAAA;YAAI,MAAM,CAAA;QAAI;;;;;4BAGrC,YAAY;gBACV,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,WAAW,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,KAAA,IAAS,CAAE,CAAA;gBAE7C,IAAA,IAAS,YAAY,GAAG,aAAa,SAAS,MAAA,EAAQ,YAAY,YAAY,YAAa;oBACzF,IAAM,UAAU,QAAA,CAAS,SAAS,CAAA;oBAElC,IAAI,QAAQ,UAAA,IAAc,QAAQ,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,IAAK,QAAQ,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,CAAE,KAAA,KAAU,KAAA,GAAW;wBAC5G,OAAO,WAAA,CAAY,IAAA,CAAK,KAAA,EAAO,QAAQ,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,CAAE,KAAK;oBACnE;gBACF;YACF;;;YAED;uCAAW,UAAA,EAAY;gBACrB,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,WAAW,WAAW;gBAC5B,IAAI,aAAa,OAAO,KAAA,CAAM,GAAA,CAAI,QAAQ;gBAE1C,IAAI,YAAY,OAAO;gBAEvB,IAAM,OAAO,OAAO,IAAA;gBACpB,IAAM,aAAc,KAAK,UAAA,IAAc,KAAK,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,IAAM,CAAE;gBACxE,IAAM,YAAY,WAAW,MAAA,IAAU,CAAE,CAAA;gBACzC,IAAM,WAAW,SAAA,CAAU,UAAU,CAAA;gBACrC,IAAI;gBAEJ,IAAM,QAAQ,IAAI,2JAAA,CAAM,QAAQ;gBAEhC,IAAI,SAAS,KAAA,KAAU,KAAA,GACrB,MAAM,MAAA,CAAO,SAAS,KAAA,CAAM,CAAC,CAAA,EAAG,SAAS,KAAA,CAAM,CAAC,CAAA,EAAG,SAAS,KAAA,CAAM,CAAC,CAAA,EAAG,oBAAoB;gBAE5F,IAAM,QAAQ,SAAS,KAAA,KAAU,KAAA,IAAY,SAAS,KAAA,GAAQ;gBAE9D,OAAQ,SAAS,IAAA,EAAI;oBACnB,KAAK;wBACH,YAAY,IAAI,sKAAA,CAAiB,KAAK;wBACtC,UAAU,MAAA,CAAO,QAAA,CAAS,GAAA,CAAI,GAAG,GAAG,CAAA,CAAE;wBACtC,UAAU,GAAA,CAAI,UAAU,MAAM;wBAC9B;oBAEF,KAAK;wBACH,YAAY,IAAI,gKAAA,CAAW,KAAK;wBAChC,UAAU,QAAA,GAAW;wBACrB;oBAEF,KAAK;wBACH,YAAY,IAAI,+JAAA,CAAU,KAAK;wBAC/B,UAAU,QAAA,GAAW;wBAErB,SAAS,IAAA,GAAO,SAAS,IAAA,IAAQ,CAAE;wBACnC,SAAS,IAAA,CAAK,cAAA,GAAiB,SAAS,IAAA,CAAK,cAAA,KAAmB,KAAA,IAAY,SAAS,IAAA,CAAK,cAAA,GAAiB;wBAC3G,SAAS,IAAA,CAAK,cAAA,GACZ,SAAS,IAAA,CAAK,cAAA,KAAmB,KAAA,IAAY,SAAS,IAAA,CAAK,cAAA,GAAiB,KAAK,EAAA,GAAK;wBACxF,UAAU,KAAA,GAAQ,SAAS,IAAA,CAAK,cAAA;wBAChC,UAAU,QAAA,GAAW,IAAM,SAAS,IAAA,CAAK,cAAA,GAAiB,SAAS,IAAA,CAAK,cAAA;wBACxE,UAAU,MAAA,CAAO,QAAA,CAAS,GAAA,CAAI,GAAG,GAAG,CAAA,CAAE;wBACtC,UAAU,GAAA,CAAI,UAAU,MAAM;wBAC9B;oBAEF;wBACE,MAAM,IAAI,MAAM,8CAA8C,SAAS,IAAI;gBAC9E;gBAID,UAAU,QAAA,CAAS,GAAA,CAAI,GAAG,GAAG,CAAC;gBAE9B,UAAU,KAAA,GAAQ;gBAElB,uBAAuB,WAAW,QAAQ;gBAE1C,IAAI,SAAS,SAAA,KAAc,KAAA,GAAW,UAAU,SAAA,GAAY,SAAS,SAAA;gBAErE,UAAU,IAAA,GAAO,OAAO,gBAAA,CAAiB,SAAS,IAAA,IAAQ,WAAW,UAAU;gBAE/E,aAAa,QAAQ,OAAA,CAAQ,SAAS;gBAEtC,OAAO,KAAA,CAAM,GAAA,CAAI,UAAU,UAAU;gBAErC,OAAO;YACR;;;;4BAED,cAAc,IAAA,EAAM,KAAA,EAAO;gBACzB,IAAI,SAAS,SAAS;gBAEtB,OAAO,IAAA,CAAK,UAAA,CAAW,KAAK;YAC7B;;;;4BAED,qBAAqB,SAAA,EAAW;gBAC9B,IAAMA,QAAO,IAAA;gBACb,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,OAAO,OAAO,IAAA;gBACpB,IAAM,UAAU,KAAK,KAAA,CAAM,SAAS,CAAA;gBACpC,IAAM,WAAY,QAAQ,UAAA,IAAc,QAAQ,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,IAAM,CAAE;gBAC5E,IAAM,aAAa,SAAS,KAAA;gBAE5B,IAAI,eAAe,KAAA,GAAW,OAAO;gBAErC,OAAO,IAAA,CAAK,UAAA,CAAW,UAAU,EAAE,IAAA,CAAK,SAAU,KAAA,EAAO;oBACvD,OAAO,OAAO,WAAA,CAAYA,MAAK,KAAA,EAAO,YAAY,KAAK;gBAC7D,CAAK;YACF;;;;;gDAQH;;;wLAAM,4BAA4B;QAE9B,IAAA,CAAK,IAAA,GAAO,WAAW,mBAAA;;;;;4BAGzB,kBAAkB;gBAChB,OAAO,uKAAA;YACR;;;;4BAED,aAAa,cAAA,EAAgB,WAAA,EAAa,MAAA,EAAQ;gBAChD,IAAM,UAAU,CAAE,CAAA;gBAElB,eAAe,KAAA,GAAQ,IAAI,2JAAA,CAAM,GAAK,GAAK,CAAG;gBAC9C,eAAe,OAAA,GAAU;gBAEzB,IAAM,oBAAoB,YAAY,oBAAA;gBAEtC,IAAI,mBAAmB;oBACrB,IAAI,MAAM,OAAA,CAAQ,kBAAkB,eAAe,GAAG;wBACpD,IAAM,QAAQ,kBAAkB,eAAA;wBAEhC,eAAe,KAAA,CAAM,MAAA,CAAO,KAAA,CAAM,CAAC,CAAA,EAAG,KAAA,CAAM,CAAC,CAAA,EAAG,KAAA,CAAM,CAAC,CAAA,EAAG,oBAAoB;wBAC9E,eAAe,OAAA,GAAU,KAAA,CAAM,CAAC,CAAA;oBACjC;oBAED,IAAI,kBAAkB,gBAAA,KAAqB,KAAA,GAAW;wBACpD,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,OAAO,kBAAkB,gBAAA,EAAkB,cAAc,CAAC;oBAC7G;gBACF;gBAED,OAAO,QAAQ,GAAA,CAAI,OAAO;YAC3B;;;;;IAQH;;oDACc,MAAA,EAAQ;;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,+BAAA;;;;;4BAGzB,qBAAqB,aAAA,EAAe,cAAA,EAAgB;gBAClD,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;oBACjE,OAAO,QAAQ,OAAA,CAAS;gBACzB;gBAED,IAAM,mBAAmB,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,CAAE,gBAAA;gBAE3D,IAAI,qBAAqB,KAAA,GAAW;oBAClC,eAAe,iBAAA,GAAoB;gBACpC;gBAED,OAAO,QAAQ,OAAA,CAAS;YACzB;;;WArBG,uCAAuC;;AA6B7C;;6CACc,MAAA,EAAQ;;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,uBAAA;;;;;4BAGzB,gBAAgB,aAAA,EAAe;gBAC7B,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;gBAE1E,OAAO,0KAAA;YACR;;;;4BAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;gBAClD,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;oBACjE,OAAO,QAAQ,OAAA,CAAS;gBACzB;gBAED,IAAM,UAAU,CAAE,CAAA;gBAElB,IAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;gBAElD,IAAI,UAAU,eAAA,KAAoB,KAAA,GAAW;oBAC3C,eAAe,SAAA,GAAY,UAAU,eAAA;gBACtC;gBAED,IAAI,UAAU,gBAAA,KAAqB,KAAA,GAAW;oBAC5C,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,gBAAgB,UAAU,gBAAgB,CAAC;gBAC9F;gBAED,IAAI,UAAU,wBAAA,KAA6B,KAAA,GAAW;oBACpD,eAAe,kBAAA,GAAqB,UAAU,wBAAA;gBAC/C;gBAED,IAAI,UAAU,yBAAA,KAA8B,KAAA,GAAW;oBACrD,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,yBAAyB,UAAU,yBAAyB,CAAC;gBAChH;gBAED,IAAI,UAAU,sBAAA,KAA2B,KAAA,GAAW;oBAClD,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,sBAAsB,UAAU,sBAAsB,CAAC;oBAEzG,IAAI,UAAU,sBAAA,CAAuB,KAAA,KAAU,KAAA,GAAW;wBACxD,IAAM,QAAQ,UAAU,sBAAA,CAAuB,KAAA;wBAE/C,eAAe,oBAAA,GAAuB,IAAI,6JAAA,CAAQ,OAAO,KAAK;oBAC/D;gBACF;gBAED,OAAO,QAAQ,GAAA,CAAI,OAAO;YAC3B;;;WAtDG,gCAAgC;;IA8DhC,iCAAiC,gBAAvC;;8CACc,MAAA,EAAQ;;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,wBAAA;;;;;4BAGzB,gBAAgB,aAAA,EAAe;gBAC7B,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;gBAE1E,OAAO,0KAAA;YACR;;;iBAED;iDAAqB,aAAA,EAAe,cAAA,EAAgB;gBAClD,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;oBACjE,OAAO,QAAQ,OAAA,CAAS;gBACzB;gBAED,IAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;gBAElD,eAAe,UAAA,GAAa,UAAU,UAAA,KAAe,KAAA,IAAY,UAAU,UAAA,GAAa;gBAExF,OAAO,QAAQ,OAAA,CAAS;YACzB;;;;;AAQH;;aAAM,kCAAkC,AAC1B,MAAA,EAAQ;;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,yBAAA;;;;YAGzB;4CAAgB,aAAA,EAAe;gBAC7B,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;gBAE1E,OAAO,0KAAA;YACR;;;;4BAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;gBAClD,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;oBACjE,OAAO,QAAQ,OAAA,CAAS;gBACzB;gBAED,IAAM,UAAU,CAAE,CAAA;gBAElB,IAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;gBAElD,IAAI,UAAU,iBAAA,KAAsB,KAAA,GAAW;oBAC7C,eAAe,WAAA,GAAc,UAAU,iBAAA;gBACxC;gBAED,IAAI,UAAU,kBAAA,KAAuB,KAAA,GAAW;oBAC9C,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,kBAAkB,UAAU,kBAAkB,CAAC;gBAClG;gBAED,IAAI,UAAU,cAAA,KAAmB,KAAA,GAAW;oBAC1C,eAAe,cAAA,GAAiB,UAAU,cAAA;gBAC3C;gBAED,IAAI,eAAe,yBAAA,KAA8B,KAAA,GAAW;oBAC1D,eAAe,yBAAA,GAA4B;wBAAC;wBAAK,GAAG;qBAAA;gBACrD;gBAED,IAAI,UAAU,2BAAA,KAAgC,KAAA,GAAW;oBACvD,eAAe,yBAAA,CAA0B,CAAC,CAAA,GAAI,UAAU,2BAAA;gBACzD;gBAED,IAAI,UAAU,2BAAA,KAAgC,KAAA,GAAW;oBACvD,eAAe,yBAAA,CAA0B,CAAC,CAAA,GAAI,UAAU,2BAAA;gBACzD;gBAED,IAAI,UAAU,2BAAA,KAAgC,KAAA,GAAW;oBACvD,QAAQ,IAAA,CACN,OAAO,aAAA,CAAc,gBAAgB,2BAA2B,UAAU,2BAA2B;gBAExG;gBAED,OAAO,QAAQ,GAAA,CAAI,OAAO;YAC3B;;;;;gDAQH;;yCACc,MAAA,EAAQ;;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,mBAAA;;;;;4BAGzB,gBAAgB,aAAA,EAAe;gBAC7B,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;gBAE1E,OAAO,0KAAA;YACR;;;YAED;iDAAqB,aAAA,EAAe,cAAA,EAAgB;gBAClD,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;oBACjE,OAAO,QAAQ,OAAA,CAAS;gBACzB;gBAED,IAAM,UAAU,CAAE,CAAA;gBAElB,eAAe,UAAA,GAAa,IAAI,2JAAA,CAAM,GAAG,GAAG,CAAC;gBAC7C,eAAe,cAAA,GAAiB;gBAChC,eAAe,KAAA,GAAQ;gBAEvB,IAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;gBAElD,IAAI,UAAU,gBAAA,KAAqB,KAAA,GAAW;oBAC5C,IAAM,cAAc,UAAU,gBAAA;oBAC9B,eAAe,UAAA,CAAW,MAAA,CAAO,WAAA,CAAY,CAAC,CAAA,EAAG,WAAA,CAAY,CAAC,CAAA,EAAG,WAAA,CAAY,CAAC,CAAA,EAAG,oBAAoB;gBACtG;gBAED,IAAI,UAAU,oBAAA,KAAyB,KAAA,GAAW;oBAChD,eAAe,cAAA,GAAiB,UAAU,oBAAA;gBAC3C;gBAED,IAAI,UAAU,iBAAA,KAAsB,KAAA,GAAW;oBAC7C,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,iBAAiB,UAAU,iBAAA,EAAmB,cAAc,CAAC;gBAChH;gBAED,IAAI,UAAU,qBAAA,KAA0B,KAAA,GAAW;oBACjD,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,qBAAqB,UAAU,qBAAqB,CAAC;gBACxG;gBAED,OAAO,QAAQ,GAAA,CAAI,OAAO;YAC3B;;;WAjDG,4BAA4B;;uDA0DlC;;gDACc,MAAA,EAAQ;wLADhB,mCAAmC;QAErC,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,0BAAA;;;;;4BAGzB,gBAAgB,aAAA,EAAe;gBAC7B,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;gBAE1E,OAAO,0KAAA;YACR;;;;4BAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;gBAClD,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;oBACjE,OAAO,QAAQ,OAAA,CAAS;gBACzB;gBAED,IAAM,UAAU,CAAE,CAAA;gBAElB,IAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;gBAElD,IAAI,UAAU,kBAAA,KAAuB,KAAA,GAAW;oBAC9C,eAAe,YAAA,GAAe,UAAU,kBAAA;gBACzC;gBAED,IAAI,UAAU,mBAAA,KAAwB,KAAA,GAAW;oBAC/C,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,mBAAmB,UAAU,mBAAmB,CAAC;gBACpG;gBAED,OAAO,QAAQ,GAAA,CAAI,OAAO;YAC3B;;;;;iDAQH;;0CACc,MAAA,EAAQ;;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,oBAAA;;;;;4BAGzB,gBAAgB,aAAA,EAAe;gBAC7B,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;gBAE1E,OAAO,0KAAA;YACR;;;;4BAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;gBAClD,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;oBACjE,OAAO,QAAQ,OAAA,CAAS;gBACzB;gBAED,IAAM,UAAU,CAAE,CAAA;gBAElB,IAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;gBAElD,eAAe,SAAA,GAAY,UAAU,eAAA,KAAoB,KAAA,IAAY,UAAU,eAAA,GAAkB;gBAEjG,IAAI,UAAU,gBAAA,KAAqB,KAAA,GAAW;oBAC5C,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,gBAAgB,UAAU,gBAAgB,CAAC;gBAC9F;gBAED,eAAe,mBAAA,GAAsB,UAAU,mBAAA,IAAuB;gBAEtE,IAAM,aAAa,UAAU,gBAAA,IAAoB;oBAAC;oBAAG;oBAAG,CAAC;iBAAA;gBACzD,eAAe,gBAAA,GAAmB,IAAI,2JAAA,CAAK,EAAG,MAAA,CAC5C,UAAA,CAAW,CAAC,CAAA,EACZ,UAAA,CAAW,CAAC,CAAA,EACZ,UAAA,CAAW,CAAC,CAAA,EACZ;gBAGF,OAAO,QAAQ,GAAA,CAAI,OAAO;YAC3B;;;WA5CG,6BAA6B;;8CAoDnC;;uCACc,MAAA,EAAQ;;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,iBAAA;;;;;4BAGzB,gBAAgB,aAAA,EAAe;gBAC7B,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;gBAE1E,OAAO,0KAAA;YACR;;;;4BAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;gBAClD,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;oBACjE,OAAO,QAAQ,OAAA,CAAS;gBACzB;gBAED,IAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;gBAElD,eAAe,GAAA,GAAM,UAAU,GAAA,KAAQ,KAAA,IAAY,UAAU,GAAA,GAAM;gBAEnE,OAAO,QAAQ,OAAA,CAAS;YACzB;;;WA5BG,0BAA0B;;IAoChC,AAAM,+BAA+B;;4CACvB,MAAA,EAAQ;;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,sBAAA;;;;;4BAGzB,gBAAgB,aAAA,EAAe;gBAC7B,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;gBAE1E,OAAO,0KAAA;YACR;;;;4BAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;gBAClD,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;oBACjE,OAAO,QAAQ,OAAA,CAAS;gBACzB;gBAED,IAAM,UAAU,CAAE,CAAA;gBAElB,IAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;gBAElD,eAAe,iBAAA,GAAoB,UAAU,cAAA,KAAmB,KAAA,IAAY,UAAU,cAAA,GAAiB;gBAEvG,IAAI,UAAU,eAAA,KAAoB,KAAA,GAAW;oBAC3C,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,wBAAwB,UAAU,eAAe,CAAC;gBACrG;gBAED,IAAM,aAAa,UAAU,mBAAA,IAAuB;oBAAC;oBAAG;oBAAG,CAAC;iBAAA;gBAC5D,eAAe,aAAA,GAAgB,IAAI,2JAAA,CAAK,EAAG,MAAA,CAAO,UAAA,CAAW,CAAC,CAAA,EAAG,UAAA,CAAW,CAAC,CAAA,EAAG,UAAA,CAAW,CAAC,CAAA,EAAG,oBAAoB;gBAEnH,IAAI,UAAU,oBAAA,KAAyB,KAAA,GAAW;oBAChD,QAAQ,IAAA,CACN,OAAO,aAAA,CAAc,gBAAgB,oBAAoB,UAAU,oBAAA,EAAsB,cAAc;gBAE1G;gBAED,OAAO,QAAQ,GAAA,CAAI,OAAO;YAC3B;;;;;+CAQH;;wCACc,MAAA,EAAQ;;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,kBAAA;;;;;4BAGzB,gBAAgB,aAAA,EAAe;gBAC7B,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;gBAE1E,OAAO,0KAAA;YACR;;;YAED;iDAAqB,aAAA,EAAe,cAAA,EAAgB;gBAClD,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;oBACjE,OAAO,QAAQ,OAAA,CAAS;gBACzB;gBAED,IAAM,UAAU,CAAE,CAAA;gBAElB,IAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;gBAElD,eAAe,SAAA,GAAY,UAAU,UAAA,KAAe,KAAA,IAAY,UAAU,UAAA,GAAa;gBAEvF,IAAI,UAAU,WAAA,KAAgB,KAAA,GAAW;oBACvC,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,WAAW,UAAU,WAAW,CAAC;gBACpF;gBAED,OAAO,QAAQ,GAAA,CAAI,OAAO;YAC3B;;;WAlCG,2BAA2B;;qDA0CjC;;8CACc,MAAA,EAAQ;wLADhB,iCAAiC;QAEnC,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,wBAAA;;;;;4BAGzB,gBAAgB,aAAA,EAAe;gBAC7B,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG,OAAO;gBAE1E,OAAO,0KAAA;YACR;;;;4BAED,qBAAqB,aAAA,EAAe,cAAA,EAAgB;gBAClD,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,cAAc,OAAO,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAEvD,IAAI,CAAC,YAAY,UAAA,IAAc,CAAC,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;oBACjE,OAAO,QAAQ,OAAA,CAAS;gBACzB;gBAED,IAAM,UAAU,CAAE,CAAA;gBAElB,IAAM,YAAY,YAAY,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;gBAElD,IAAI,UAAU,kBAAA,KAAuB,KAAA,GAAW;oBAC9C,eAAe,UAAA,GAAa,UAAU,kBAAA;gBACvC;gBAED,IAAI,UAAU,kBAAA,KAAuB,KAAA,GAAW;oBAC9C,eAAe,kBAAA,GAAqB,UAAU,kBAAA;gBAC/C;gBAED,IAAI,UAAU,iBAAA,KAAsB,KAAA,GAAW;oBAC7C,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,iBAAiB,UAAU,iBAAiB,CAAC;gBAChG;gBAED,OAAO,QAAQ,GAAA,CAAI,OAAO;YAC3B;;;;;+CAQH;;wCACc,MAAA,EAAQ;;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,kBAAA;;;;;4BAGzB,YAAY,YAAA,EAAc;gBACxB,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,OAAO,OAAO,IAAA;gBAEpB,IAAM,aAAa,KAAK,QAAA,CAAS,YAAY,CAAA;gBAE7C,IAAI,CAAC,WAAW,UAAA,IAAc,CAAC,WAAW,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;oBAC/D,OAAO;gBACR;gBAED,IAAM,YAAY,WAAW,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;gBACjD,IAAM,SAAS,OAAO,OAAA,CAAQ,UAAA;gBAE9B,IAAI,CAAC,QAAQ;oBACX,IAAI,KAAK,kBAAA,IAAsB,KAAK,kBAAA,CAAmB,OAAA,CAAQ,IAAA,CAAK,IAAI,KAAK,GAAG;wBAC9E,MAAM,IAAI,MAAM,6EAA6E;oBACrG,OAAa;wBAEL,OAAO;oBACR;gBACF;gBAED,OAAO,OAAO,gBAAA,CAAiB,cAAc,UAAU,MAAA,EAAQ,MAAM;YACtE;;;WA7BG,2BAA2B;;AAqCjC;;aAAM,yBAAyB,AACjB,MAAA,EAAQ;;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,gBAAA;QACvB,IAAA,CAAK,WAAA,GAAc;;;;YAGrB;wCAAY,YAAA,EAAc;gBACxB,IAAM,OAAO,IAAA,CAAK,IAAA;gBAClB,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,OAAO,OAAO,IAAA;gBAEpB,IAAM,aAAa,KAAK,QAAA,CAAS,YAAY,CAAA;gBAE7C,IAAI,CAAC,WAAW,UAAA,IAAc,CAAC,WAAW,UAAA,CAAW,IAAI,CAAA,EAAG;oBAC1D,OAAO;gBACR;gBAED,IAAM,YAAY,WAAW,UAAA,CAAW,IAAI,CAAA;gBAC5C,IAAM,SAAS,KAAK,MAAA,CAAO,UAAU,MAAM,CAAA;gBAE3C,IAAI,SAAS,OAAO,aAAA;gBACpB,IAAI,OAAO,GAAA,EAAK;oBACd,IAAM,UAAU,OAAO,OAAA,CAAQ,OAAA,CAAQ,UAAA,CAAW,OAAO,GAAG;oBAC5D,IAAI,YAAY,MAAM,SAAS;gBAChC;gBAED,OAAO,IAAA,CAAK,aAAA,CAAa,EAAG,IAAA,CAAK,SAAU,WAAA,EAAa;oBACtD,IAAI,aAAa,OAAO,OAAO,gBAAA,CAAiB,cAAc,UAAU,MAAA,EAAQ,MAAM;oBAEtF,IAAI,KAAK,kBAAA,IAAsB,KAAK,kBAAA,CAAmB,OAAA,CAAQ,IAAI,KAAK,GAAG;wBACzE,MAAM,IAAI,MAAM,2DAA2D;oBAC5E;oBAGD,OAAO,OAAO,WAAA,CAAY,YAAY;gBAC5C,CAAK;YACF;;;;4BAED,gBAAgB;gBACd,IAAI,CAAC,IAAA,CAAK,WAAA,EAAa;oBACrB,IAAA,CAAK,WAAA,GAAc,IAAI,QAAQ,SAAU,OAAA,EAAS;wBAChD,IAAM,QAAQ,IAAI,MAAO;wBAIzB,MAAM,GAAA,GAAM;wBAEZ,MAAM,MAAA,GAAS,MAAM,OAAA,GAAU,WAAY;4BACzC,QAAQ,MAAM,MAAA,KAAW,CAAC;wBAC3B;oBACT,CAAO;gBACF;gBAED,OAAO,IAAA,CAAK,WAAA;YACb;;;;;6CAQH;;sCACc,MAAA,EAAQ;;QAClB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO,WAAW,gBAAA;QACvB,IAAA,CAAK,WAAA,GAAc;;;;;4BAGrB,YAAY,YAAA,EAAc;gBACxB,IAAM,OAAO,IAAA,CAAK,IAAA;gBAClB,IAAM,SAAS,IAAA,CAAK,MAAA;gBACpB,IAAM,OAAO,OAAO,IAAA;gBAEpB,IAAM,aAAa,KAAK,QAAA,CAAS,YAAY,CAAA;gBAE7C,IAAI,CAAC,WAAW,UAAA,IAAc,CAAC,WAAW,UAAA,CAAW,IAAI,CAAA,EAAG;oBAC1D,OAAO;gBACR;gBAED,IAAM,YAAY,WAAW,UAAA,CAAW,IAAI,CAAA;gBAC5C,IAAM,SAAS,KAAK,MAAA,CAAO,UAAU,MAAM,CAAA;gBAE3C,IAAI,SAAS,OAAO,aAAA;gBACpB,IAAI,OAAO,GAAA,EAAK;oBACd,IAAM,UAAU,OAAO,OAAA,CAAQ,OAAA,CAAQ,UAAA,CAAW,OAAO,GAAG;oBAC5D,IAAI,YAAY,MAAM,SAAS;gBAChC;gBAED,OAAO,IAAA,CAAK,aAAA,CAAa,EAAG,IAAA,CAAK,SAAU,WAAA,EAAa;oBACtD,IAAI,aAAa,OAAO,OAAO,gBAAA,CAAiB,cAAc,UAAU,MAAA,EAAQ,MAAM;oBAEtF,IAAI,KAAK,kBAAA,IAAsB,KAAK,kBAAA,CAAmB,OAAA,CAAQ,IAAI,KAAK,GAAG;wBACzE,MAAM,IAAI,MAAM,2DAA2D;oBAC5E;oBAGD,OAAO,OAAO,WAAA,CAAY,YAAY;gBAC5C,CAAK;YACF;;;YAED,gBAAgB;;gBACd,IAAI,CAAC,IAAA,CAAK,WAAA,EAAa;oBACrB,IAAA,CAAK,WAAA,GAAc,IAAI,QAAQ,SAAU,OAAA,EAAS;wBAChD,IAAM,QAAQ,IAAI,MAAO;wBAGzB,MAAM,GAAA,GACJ;wBACF,MAAM,MAAA,GAAS,MAAM,OAAA,GAAU,WAAY;4BACzC,QAAQ,MAAM,MAAA,KAAW,CAAC;wBAC3B;oBACT,CAAO;gBACF;gBAED,OAAO,IAAA,CAAK,WAAA;YACb;;;WAtDG,yBAAyB;;2CA8D/B;;oCACc,MAAA,EAAQ;;QAClB,IAAA,CAAK,IAAA,GAAO,WAAW,uBAAA;QACvB,IAAA,CAAK,MAAA,GAAS;;;;;4BAGhB,eAAe,KAAA,EAAO;gBACpB,IAAM,OAAO,IAAA,CAAK,MAAA,CAAO,IAAA;gBACzB,IAAM,aAAa,KAAK,WAAA,CAAY,KAAK,CAAA;gBAEzC,IAAI,WAAW,UAAA,IAAc,WAAW,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,EAAG;oBAC7D,IAAM,eAAe,WAAW,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;oBAEpD,IAAM,SAAS,IAAA,CAAK,MAAA,CAAO,aAAA,CAAc,UAAU,aAAa,MAAM;oBACtE,IAAM,UAAU,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,cAAA;oBAEpC,IAAI,CAAC,WAAW,CAAC,QAAQ,SAAA,EAAW;wBAClC,IAAI,KAAK,kBAAA,IAAsB,KAAK,kBAAA,CAAmB,OAAA,CAAQ,IAAA,CAAK,IAAI,KAAK,GAAG;4BAC9E,MAAM,IAAI,MAAM,oFAAoF;wBAC9G,OAAe;4BAEL,OAAO;wBACR;oBACF;oBAED,OAAO,OAAO,IAAA,CAAK,SAAU,GAAA,EAAK;wBAChC,IAAM,aAAa,aAAa,UAAA,IAAc;wBAC9C,IAAM,aAAa,aAAa,UAAA,IAAc;wBAE9C,IAAM,QAAQ,aAAa,KAAA;wBAC3B,IAAM,SAAS,aAAa,UAAA;wBAE5B,IAAM,SAAS,IAAI,WAAW,KAAK,YAAY,UAAU;wBAEzD,IAAI,QAAQ,qBAAA,EAAuB;4BACjC,OAAO,QACJ,qBAAA,CAAsB,OAAO,QAAQ,QAAQ,aAAa,IAAA,EAAM,aAAa,MAAM,EACnF,IAAA,CAAK,SAAUC,IAAAA,EAAK;gCACnB,OAAOA,KAAI,MAAA;4BACzB,CAAa;wBACb,OAAe;4BAEL,OAAO,QAAQ,KAAA,CAAM,IAAA,CAAK,WAAY;gCACpC,IAAM,SAAS,IAAI,YAAY,QAAQ,MAAM;gCAC7C,QAAQ,gBAAA,CACN,IAAI,WAAW,MAAM,GACrB,OACA,QACA,QACA,aAAa,IAAA,EACb,aAAa,MAAA;gCAEf,OAAO;4BACnB,CAAW;wBACF;oBACT,CAAO;gBACP,OAAW;oBACL,OAAO;gBACR;YACF;;;WA3DG,uBAAuB;;0CAoE7B;;mCACc,MAAA,EAAQ;wLADhB,sBAAsB;QAExB,IAAA,CAAK,IAAA,GAAO,WAAW,uBAAA;QACvB,IAAA,CAAK,MAAA,GAAS;;;;;4BAGhB,eAAe,SAAA,EAAW;;oBAgCtB,QAAQ,IAAA,CACN,MAAK,MAAA,CAAO,aAAA,CAAc,YAAY,aAAA,CAAc,GAAG,CAAC,EAAE,IAAA,CAAK,SAAC,aAAa;wBAC3E,UAAA,CAAW,GAAG,CAAA,GAAI;wBAClB,OAAO,UAAA,CAAW,GAAG,CAAA;oBAC/B,CAAS;gBAEJ;;gBArCD,IAAM,OAAO,IAAA,CAAK,MAAA,CAAO,IAAA;gBACzB,IAAM,UAAU,KAAK,KAAA,CAAM,SAAS,CAAA;gBAEpC,IAAI,CAAC,QAAQ,UAAA,IAAc,CAAC,QAAQ,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,IAAK,QAAQ,IAAA,KAAS,KAAA,GAAW;oBACvF,OAAO;gBACR;gBAED,IAAM,UAAU,KAAK,MAAA,CAAO,QAAQ,IAAI,CAAA;oBAIxC,kCAAA,2BAAA;;oBAAA,QAAA,YAAwB,QAAQ,UAAA,qBAAhC,SAAA,6BAAA,QAAA,yBAAA,iCAA4C;wBAA5C,IAAW,YAAX;wBACE,IACE,UAAU,IAAA,KAAS,gBAAgB,SAAA,IACnC,UAAU,IAAA,KAAS,gBAAgB,cAAA,IACnC,UAAU,IAAA,KAAS,gBAAgB,YAAA,IACnC,UAAU,IAAA,KAAS,KAAA,GACnB;4BACA,OAAO;wBACR;oBACF;;oBATD;oBAAA;;;6BAAA,6BAAA;4BAAA;;;4BAAA;kCAAA;;;;gBAWA,IAAM,eAAe,QAAQ,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;gBACjD,IAAM,gBAAgB,aAAa,UAAA;gBAInC,IAAM,UAAU,CAAE,CAAA;gBAClB,IAAM,aAAa,CAAE;gBAErB,IAAA,IAAW,OAAO,eAAe;gBASjC,IAAI,QAAQ,MAAA,GAAS,GAAG;oBACtB,OAAO;gBACR;gBAED,QAAQ,IAAA,CAAK,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,SAAS,CAAC;gBAElD,OAAO,QAAQ,GAAA,CAAI,OAAO,EAAE,IAAA,CAAK,SAAC,YAAY;oBAC5C,IAAM,aAAa,QAAQ,GAAA,CAAK;oBAChC,IAAM,SAAS,WAAW,OAAA,GAAU,WAAW,QAAA,GAAW;wBAAC,UAAU;qBAAA;oBACrE,IAAM,QAAQ,OAAA,CAAQ,CAAC,CAAA,CAAE,KAAA;oBACzB,IAAM,kBAAkB,CAAE,CAAA;wBAE1B,kCAAA,2BAAA;;wBAAA,QAAA,YAAmB,2BAAnB,SAAA,6BAAA,QAAA,yBAAA,iCAA2B;4BAA3B,IAAW,OAAX;4BAEE,IAAM,IAAI,IAAI,6JAAA,CAAS;4BACvB,IAAM,IAAI,IAAI,6JAAA,CAAS;4BACvB,IAAM,IAAI,IAAI,gKAAA,CAAY;4BAC1B,IAAM,IAAI,IAAI,6JAAA,CAAQ,GAAG,GAAG,CAAC;4BAE7B,IAAM,gBAAgB,IAAI,mKAAA,CAAc,KAAK,QAAA,EAAU,KAAK,QAAA,EAAU,KAAK;4BAE3E,IAAA,IAAS,IAAI,GAAG,IAAI,OAAO,IAAK;gCAC9B,IAAI,WAAW,WAAA,EAAa;oCAC1B,EAAE,mBAAA,CAAoB,WAAW,WAAA,EAAa,CAAC;gCAChD;gCAED,IAAI,WAAW,QAAA,EAAU;oCACvB,EAAE,mBAAA,CAAoB,WAAW,QAAA,EAAU,CAAC;gCAC7C;gCAED,IAAI,WAAW,KAAA,EAAO;oCACpB,EAAE,mBAAA,CAAoB,WAAW,KAAA,EAAO,CAAC;gCAC1C;gCAED,cAAc,WAAA,CAAY,GAAG,EAAE,OAAA,CAAQ,GAAG,GAAG,CAAC,CAAC;4BAChD;4BAGD,IAAA,IAAW,iBAAiB,WAAY;gCACtC,IAAI,kBAAkB,YAAY;oCAChC,IAAM,OAAO,UAAA,CAAW,aAAa,CAAA;oCACrC,cAAc,aAAA,GAAgB,IAAI,8KAAA,CAAyB,KAAK,KAAA,EAAO,KAAK,QAAA,EAAU,KAAK,UAAU;gCACjH,OAAA,IAAqB,kBAAkB,iBAAiB,kBAAkB,cAAc,kBAAkB,SAAS;oCACvG,KAAK,QAAA,CAAS,YAAA,CAAa,eAAe,UAAA,CAAW,aAAa,CAAC;gCACpE;4BACF;4BAGD,8JAAA,CAAS,SAAA,CAAU,IAAA,CAAK,IAAA,CAAK,eAAe,IAAI;4BAEhD,OAAK,MAAA,CAAO,mBAAA,CAAoB,aAAa;4BAE7C,gBAAgB,IAAA,CAAK,aAAa;wBACnC;;wBAzCD;wBAAA;;;iCAAA,6BAAA;gCAAA;;;gCAAA;sCAAA;;;;oBA2CA,IAAI,WAAW,OAAA,EAAS;4BAGtB;wBAFA,WAAW,KAAA,CAAO;wBAElB,CAAA,cAAA,YAAW,GAAA,OAAX,aAAe,6KAAG,eAAe;wBAEjC,OAAO;oBACR;oBAED,OAAO,eAAA,CAAgB,CAAC,CAAA;gBAC9B,CAAK;YACF;;;;;AAIH,IAAM,gCAAgC;AACtC,IAAM,iCAAiC;AACvC,IAAM,+BAA+B;IAAE,MAAM;IAAY,KAAK;AAAY;0BAE1E,6BACc,IAAA,EAAM;;oLADd,oBAAoB;IAEtB,IAAA,CAAK,IAAA,GAAO,WAAW,eAAA;IACvB,IAAA,CAAK,OAAA,GAAU;IACf,IAAA,CAAK,IAAA,GAAO;IAEZ,IAAM,aAAa,IAAI,SAAS,MAAM,GAAG,8BAA8B;IAEvE,IAAA,CAAK,MAAA,GAAS;QACZ,WAAO,4KAAA,EAAW,IAAI,WAAW,KAAK,KAAA,CAAM,GAAG,CAAC,CAAC,CAAC;QAClD,SAAS,WAAW,SAAA,CAAU,GAAG,IAAI;QACrC,QAAQ,WAAW,SAAA,CAAU,GAAG,IAAI;IACrC;IAED,IAAI,IAAA,CAAK,MAAA,CAAO,KAAA,KAAU,+BAA+B;QACvD,MAAM,IAAI,MAAM,mDAAmD;IACpE,OAAA,IAAU,IAAA,CAAK,MAAA,CAAO,OAAA,GAAU,GAAK;QACpC,MAAM,IAAI,MAAM,gDAAgD;IACjE;IAED,IAAM,sBAAsB,IAAA,CAAK,MAAA,CAAO,MAAA,GAAS;IACjD,IAAM,YAAY,IAAI,SAAS,MAAM,8BAA8B;IACnE,IAAI,aAAa;IAEjB,MAAO,aAAa,oBAAqB;QACvC,IAAM,cAAc,UAAU,SAAA,CAAU,YAAY,IAAI;QACxD,cAAc;QAEd,IAAM,YAAY,UAAU,SAAA,CAAU,YAAY,IAAI;QACtD,cAAc;QAEd,IAAI,cAAc,6BAA6B,IAAA,EAAM;YACnD,IAAM,eAAe,IAAI,WAAW,MAAM,iCAAiC,YAAY,WAAW;YAClG,IAAA,CAAK,OAAA,OAAU,4KAAA,EAAW,YAAY;QAC9C,OAAA,IAAiB,cAAc,6BAA6B,GAAA,EAAK;YACzD,IAAM,aAAa,iCAAiC;YACpD,IAAA,CAAK,IAAA,GAAO,KAAK,KAAA,CAAM,YAAY,aAAa,WAAW;QAC5D;QAID,cAAc;IACf;IAED,IAAI,IAAA,CAAK,OAAA,KAAY,MAAM;QACzB,MAAM,IAAI,MAAM,2CAA2C;IAC5D;;AASL;;aAAM,kCAAkC,AAC1B,IAAA,EAAM,WAAA,EAAa;;QAC7B,IAAI,CAAC,aAAa;YAChB,MAAM,IAAI,MAAM,qDAAqD;QACtE;QAED,IAAA,CAAK,IAAA,GAAO,WAAW,0BAAA;QACvB,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,WAAA,GAAc;QACnB,IAAA,CAAK,WAAA,CAAY,OAAA,CAAS;;;;;4BAG5B,gBAAgB,SAAA,EAAW,MAAA,EAAQ;gBACjC,IAAM,OAAO,IAAA,CAAK,IAAA;gBAClB,IAAM,cAAc,IAAA,CAAK,WAAA;gBACzB,IAAM,kBAAkB,UAAU,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,CAAE,UAAA;gBACxD,IAAM,mBAAmB,UAAU,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,CAAE,UAAA;gBACzD,IAAM,oBAAoB,CAAE;gBAC5B,IAAM,yBAAyB,CAAE;gBACjC,IAAM,mBAAmB,CAAE;gBAE3B,IAAA,IAAW,iBAAiB,iBAAkB;oBAC5C,IAAM,qBAAqB,UAAA,CAAW,aAAa,CAAA,IAAK,cAAc,WAAA,CAAa;oBAEnF,iBAAA,CAAkB,kBAAkB,CAAA,GAAI,gBAAA,CAAiB,aAAa,CAAA;gBACvE;gBAED,IAAA,IAAW,kBAAiB,UAAU,UAAA,CAAY;oBAChD,IAAM,sBAAqB,UAAA,CAAW,aAAa,EAAA,IAAK,eAAc,WAAA,CAAa;oBAEnF,IAAI,gBAAA,CAAiB,aAAa,EAAA,KAAM,KAAA,GAAW;wBACjD,IAAM,cAAc,KAAK,SAAA,CAAU,UAAU,UAAA,CAAW,aAAa,EAAC,CAAA;wBACtE,IAAM,gBAAgB,qBAAA,CAAsB,YAAY,aAAa,CAAA;wBAErE,gBAAA,CAAiB,kBAAkB,EAAA,GAAI,cAAc,IAAA;wBACrD,sBAAA,CAAuB,kBAAkB,EAAA,GAAI,YAAY,UAAA,KAAe;oBACzE;gBACF;gBAED,OAAO,OAAO,aAAA,CAAc,cAAc,eAAe,EAAE,IAAA,CAAK,SAAU,UAAA,EAAY;oBACpF,OAAO,IAAI,QAAQ,SAAU,OAAA,EAAS,MAAA,EAAQ;wBAC5C,YAAY,eAAA,CACV,YACA,SAAU,QAAA,EAAU;4BAClB,IAAA,IAAW,iBAAiB,SAAS,UAAA,CAAY;gCAC/C,IAAM,YAAY,SAAS,UAAA,CAAW,aAAa,CAAA;gCACnD,IAAM,aAAa,sBAAA,CAAuB,aAAa,CAAA;gCAEvD,IAAI,eAAe,KAAA,GAAW,UAAU,UAAA,GAAa;4BACtD;4BAED,QAAQ,QAAQ;wBACjB,GACD,mBACA,kBACA,sBACA;oBAEV,CAAO;gBACP,CAAK;YACF;;;;;kDAQH;;;;QAEI,IAAA,CAAK,IAAA,GAAO,WAAW,qBAAA;;;;;4BAGzB,cAAc,OAAA,EAAS,SAAA,EAAW;gBAChC,IAAA,CACG,UAAU,QAAA,KAAa,KAAA,KAAa,UAAU,QAAA,KAAa,QAAQ,OAAA,KACpE,UAAU,MAAA,KAAW,KAAA,KACrB,UAAU,QAAA,KAAa,KAAA,KACvB,UAAU,KAAA,KAAU,KAAA,GACpB;oBAEA,OAAO;gBACR;gBAED,UAAU,QAAQ,KAAA,CAAO;gBAEzB,IAAI,UAAU,QAAA,KAAa,KAAA,GAAW;oBACpC,QAAQ,OAAA,GAAU,UAAU,QAAA;gBAC7B;gBAED,IAAI,UAAU,MAAA,KAAW,KAAA,GAAW;oBAClC,QAAQ,MAAA,CAAO,SAAA,CAAU,UAAU,MAAM;gBAC1C;gBAED,IAAI,UAAU,QAAA,KAAa,KAAA,GAAW;oBACpC,QAAQ,QAAA,GAAW,UAAU,QAAA;gBAC9B;gBAED,IAAI,UAAU,KAAA,KAAU,KAAA,GAAW;oBACjC,QAAQ,MAAA,CAAO,SAAA,CAAU,UAAU,KAAK;gBACzC;gBAED,QAAQ,WAAA,GAAc;gBAEtB,OAAO;YACR;;;WArCG,8BAA8B;;oCA6CpC;;oLAAM,8BAA8B;IAEhC,IAAA,CAAK,IAAA,GAAO,WAAW,qBAAA;;IAUrB,2CAAN;;;wCACc,kBAAA,EAAoB,YAAA,EAAc,UAAA,EAAY,YAAA,EAAc;;QACtE,OAAA;YAAM;YAAoB;YAAc;YAAY,YAAY;;;;;;4BAGlE,iBAAiB,KAAA,EAAO;gBAItB,IAAM,SAAS,IAAA,CAAK,YAAA,EAClB,SAAS,IAAA,CAAK,YAAA,EACd,YAAY,IAAA,CAAK,SAAA,EACjB,SAAS,QAAQ,YAAY,IAAI;gBAEnC,IAAA,IAAS,IAAI,GAAG,MAAM,WAAW,IAAK;oBACpC,MAAA,CAAO,CAAC,CAAA,GAAI,MAAA,CAAO,SAAS,CAAC,CAAA;gBAC9B;gBAED,OAAO;YACR;;;;4BAED,aAAa,EAAA,EAAI,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI;gBAC1B,IAAM,SAAS,IAAA,CAAK,YAAA;gBACpB,IAAM,SAAS,IAAA,CAAK,YAAA;gBACpB,IAAM,SAAS,IAAA,CAAK,SAAA;gBAEpB,IAAM,UAAU,SAAS;gBACzB,IAAM,UAAU,SAAS;gBAEzB,IAAM,KAAK,KAAK;gBAEhB,IAAM,IAAA,CAAK,IAAI,EAAA,IAAM;gBACrB,IAAM,KAAK,IAAI;gBACf,IAAM,MAAM,KAAK;gBAEjB,IAAM,UAAU,KAAK;gBACrB,IAAM,UAAU,UAAU;gBAE1B,IAAM,KAAK,CAAA,IAAK,MAAM,IAAI;gBAC1B,IAAM,KAAK,MAAM;gBACjB,IAAM,KAAK,IAAI;gBACf,IAAM,KAAK,KAAK,KAAK;gBAIrB,IAAA,IAAS,IAAI,GAAG,MAAM,QAAQ,IAAK;oBACjC,IAAM,KAAK,MAAA,CAAO,UAAU,IAAI,MAAM,CAAA;oBACtC,IAAM,KAAK,MAAA,CAAO,UAAU,IAAI,OAAO,CAAA,GAAI;oBAC3C,IAAM,KAAK,MAAA,CAAO,UAAU,IAAI,MAAM,CAAA;oBACtC,IAAM,KAAK,MAAA,CAAO,UAAU,CAAC,CAAA,GAAI;oBAEjC,MAAA,CAAO,CAAC,CAAA,GAAI,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK;gBAChD;gBAED,OAAO;YACR;;;;EAvDsC,iKAAA,CAAY;AA0DrD,IAAM,KAAqB,aAAA,GAAA,IAAI,gKAAA,CAAY;;;;;;eAE3C;;;;;4BACE,aAAa,EAAA,EAAI,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI;gBAC1B,IAAM,iYAAe,gBAAN,IAAA,aAAmB,IAAI,IAAI,GAAG,EAAE;gBAE/C,GAAG,SAAA,CAAU,MAAM,EAAE,SAAA,CAAW,EAAC,OAAA,CAAQ,MAAM;gBAE/C,OAAO;YACR;;;WAPG;EAA6C,2BAA2B;AAgB9E,IAAM,kBAAkB;IACtB,OAAO;IAAA,oBAAA;IAEP,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,QAAQ;IACR,QAAQ;IACR,YAAY;IACZ,QAAQ;IACR,OAAO;IACP,WAAW;IACX,YAAY;IACZ,WAAW;IACX,gBAAgB;IAChB,cAAc;IACd,eAAe;IACf,gBAAgB;AAClB;AAEA,IAAM,wBAAwB;IAC5B,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;AACR;AAEA,IAAM,gBAAgB;IACpB,MAAM,mKAAA;IACN,MAAM,kKAAA;IACN,MAAM,gLAAA;IACN,MAAM,+KAAA;IACN,MAAM,+KAAA;IACN,MAAM,8KAAA;AACR;AAEA,IAAM,kBAAkB;IACtB,OAAO,yKAAA;IACP,OAAO,4KAAA;IACP,OAAO,oKAAA;AACT;AAEA,IAAM,mBAAmB;IACvB,QAAQ;IACR,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;AACR;AAEA,IAAM,aAAa;IACjB,UAAU;IACV,QAAQ;IACR,SAAS;GAIL,uKAAA,IAAW,MACX;IACE,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;AACb,IACD;IACE,YAAY;IACZ,YAAY;AACpB;IAEE,SAAS;IACT,WAAW;IACX,UAAU;;AAGZ,IAAM,kBAAkB;IACtB,OAAO;IACP,aAAa;IACb,UAAU;IACV,SAAS;AACX;AAEA,IAAM,gBAAgB;IACpB,aAAa,KAAA;IAAA,0FAAA;IAAA,uFAAA;IAEb,QAAQ,uKAAA;IACR,MAAM,yKAAA;AACR;AAEA,IAAM,cAAc;IAClB,QAAQ;IACR,MAAM;IACN,OAAO;AACT;AAKA,SAAS,sBAAsB,KAAA,EAAO;IACpC,IAAI,KAAA,CAAM,iBAAiB,CAAA,KAAM,KAAA,GAAW;QAC1C,KAAA,CAAM,iBAAiB,CAAA,GAAI,IAAI,0KAAA,CAAqB;YAClD,OAAO;YACP,UAAU;YACV,WAAW;YACX,WAAW;YACX,aAAa;YACb,WAAW;YACX,MAAM,+JAAA;QACZ,CAAK;IACF;IAED,OAAO,KAAA,CAAM,iBAAiB,CAAA;AAChC;AAEA,SAAS,+BAA+B,eAAA,EAAiB,MAAA,EAAQ,SAAA,EAAW;IAG1E,IAAA,IAAW,QAAQ,UAAU,UAAA,CAAY;QACvC,IAAI,eAAA,CAAgB,IAAI,CAAA,KAAM,KAAA,GAAW;YACvC,OAAO,QAAA,CAAS,cAAA,GAAiB,OAAO,QAAA,CAAS,cAAA,IAAkB,CAAE;YACrE,OAAO,QAAA,CAAS,cAAA,CAAe,IAAI,CAAA,GAAI,UAAU,UAAA,CAAW,IAAI,CAAA;QACjE;IACF;AACH;AAMA,SAAS,uBAAuB,MAAA,EAAQ,OAAA,EAAS;IAC/C,IAAI,QAAQ,MAAA,KAAW,KAAA,GAAW;QAChC,QAAI,2JAAe,EAAR,QAAQ,MAAA,MAAW,UAAU;YACtC,OAAO,MAAA,CAAO,OAAO,QAAA,EAAU,QAAQ,MAAM;QACnD,OAAW;YACL,QAAQ,IAAA,CAAK,wDAAwD,QAAQ,MAAM;QACpF;IACF;AACH;AAUA,SAAS,gBAAgB,QAAA,EAAU,OAAA,EAAS,MAAA,EAAQ;IAClD,IAAI,mBAAmB;IACvB,IAAI,iBAAiB;IACrB,IAAI,gBAAgB;IAEpB,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;QAChD,IAAM,SAAS,OAAA,CAAQ,CAAC,CAAA;QAExB,IAAI,OAAO,QAAA,KAAa,KAAA,GAAW,mBAAmB;QACtD,IAAI,OAAO,MAAA,KAAW,KAAA,GAAW,iBAAiB;QAClD,IAAI,OAAO,OAAA,KAAY,KAAA,GAAW,gBAAgB;QAElD,IAAI,oBAAoB,kBAAkB,eAAe;IAC1D;IAED,IAAI,CAAC,oBAAoB,CAAC,kBAAkB,CAAC,eAAe,OAAO,QAAQ,OAAA,CAAQ,QAAQ;IAE3F,IAAM,2BAA2B,CAAE,CAAA;IACnC,IAAM,yBAAyB,CAAE,CAAA;IACjC,IAAM,wBAAwB,CAAE,CAAA;IAEhC,IAAA,IAAS,KAAI,GAAG,MAAK,QAAQ,MAAA,EAAQ,KAAI,KAAI,KAAK;QAChD,IAAM,UAAS,OAAA,CAAQ,CAAC,EAAA;QAExB,IAAI,kBAAkB;YACpB,IAAM,kBACJ,QAAO,QAAA,KAAa,KAAA,IAAY,OAAO,aAAA,CAAc,YAAY,QAAO,QAAQ,IAAI,SAAS,UAAA,CAAW,QAAA;YAE1G,yBAAyB,IAAA,CAAK,eAAe;QAC9C;QAED,IAAI,gBAAgB;YAClB,IAAM,mBACJ,QAAO,MAAA,KAAW,KAAA,IAAY,OAAO,aAAA,CAAc,YAAY,QAAO,MAAM,IAAI,SAAS,UAAA,CAAW,MAAA;YAEtG,uBAAuB,IAAA,CAAK,eAAe;QAC5C;QAED,IAAI,eAAe;YACjB,IAAM,mBACJ,QAAO,OAAA,KAAY,KAAA,IAAY,OAAO,aAAA,CAAc,YAAY,QAAO,OAAO,IAAI,SAAS,UAAA,CAAW,KAAA;YAExG,sBAAsB,IAAA,CAAK,eAAe;QAC3C;IACF;IAED,OAAO,QAAQ,GAAA,CAAI;QACjB,QAAQ,GAAA,CAAI,wBAAwB;QACpC,QAAQ,GAAA,CAAI,sBAAsB;QAClC,QAAQ,GAAA,CAAI,qBAAqB;KAClC,EAAE,IAAA,CAAK,SAAU,SAAA,EAAW;QAC3B,IAAM,iBAAiB,SAAA,CAAU,CAAC,CAAA;QAClC,IAAM,eAAe,SAAA,CAAU,CAAC,CAAA;QAChC,IAAM,cAAc,SAAA,CAAU,CAAC,CAAA;QAE/B,IAAI,kBAAkB,SAAS,eAAA,CAAgB,QAAA,GAAW;QAC1D,IAAI,gBAAgB,SAAS,eAAA,CAAgB,MAAA,GAAS;QACtD,IAAI,eAAe,SAAS,eAAA,CAAgB,KAAA,GAAQ;QACpD,SAAS,oBAAA,GAAuB;QAEhC,OAAO;IACX,CAAG;AACH;AAMA,SAAS,mBAAmB,IAAA,EAAM,OAAA,EAAS;IACzC,KAAK,kBAAA,CAAoB;IAEzB,IAAI,QAAQ,OAAA,KAAY,KAAA,GAAW;QACjC,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,OAAA,CAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;YACxD,KAAK,qBAAA,CAAsB,CAAC,CAAA,GAAI,QAAQ,OAAA,CAAQ,CAAC,CAAA;QAClD;IACF;IAGD,IAAI,QAAQ,MAAA,IAAU,MAAM,OAAA,CAAQ,QAAQ,MAAA,CAAO,WAAW,GAAG;QAC/D,IAAM,cAAc,QAAQ,MAAA,CAAO,WAAA;QAEnC,IAAI,KAAK,qBAAA,CAAsB,MAAA,KAAW,YAAY,MAAA,EAAQ;YAC5D,KAAK,qBAAA,GAAwB,CAAE;YAE/B,IAAA,IAAS,KAAI,GAAG,MAAK,YAAY,MAAA,EAAQ,KAAI,KAAI,KAAK;gBACpD,KAAK,qBAAA,CAAsB,WAAA,CAAY,CAAC,EAAC,CAAA,GAAI;YAC9C;QACP,OAAW;YACL,QAAQ,IAAA,CAAK,sEAAsE;QACpF;IACF;AACH;AAEA,SAAS,mBAAmB,YAAA,EAAc;IACxC,IAAI;IAEJ,IAAM,iBAAiB,aAAa,UAAA,IAAc,aAAa,UAAA,CAAW,WAAW,0BAA0B,CAAA;IAE/G,IAAI,gBAAgB;QAClB,cACE,WACA,eAAe,UAAA,GACf,MACA,eAAe,OAAA,GACf,MACA,oBAAoB,eAAe,UAAU;IACnD,OAAS;QACL,cAAc,aAAa,OAAA,GAAU,MAAM,oBAAoB,aAAa,UAAU,IAAI,MAAM,aAAa,IAAA;IAC9G;IAED,IAAI,aAAa,OAAA,KAAY,KAAA,GAAW;QACtC,IAAA,IAAS,IAAI,GAAG,KAAK,aAAa,OAAA,CAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;YAC7D,eAAe,MAAM,oBAAoB,aAAa,OAAA,CAAQ,CAAC,CAAC;QACjE;IACF;IAED,OAAO;AACT;AAEA,SAAS,oBAAoB,UAAA,EAAY;IACvC,IAAI,gBAAgB;IAEpB,IAAM,OAAO,OAAO,IAAA,CAAK,UAAU,EAAE,IAAA,CAAM;IAE3C,IAAA,IAAS,IAAI,GAAG,KAAK,KAAK,MAAA,EAAQ,IAAI,IAAI,IAAK;QAC7C,iBAAiB,IAAA,CAAK,CAAC,CAAA,GAAI,MAAM,UAAA,CAAW,IAAA,CAAK,CAAC,CAAC,CAAA,GAAI;IACxD;IAED,OAAO;AACT;AAEA,SAAS,4BAA4B,WAAA,EAAa;IAIhD,OAAQ,aAAW;QACjB,KAAK;YACH,OAAO,IAAI;QAEb,KAAK;YACH,OAAO,IAAI;QAEb,KAAK;YACH,OAAO,IAAI;QAEb,KAAK;YACH,OAAO,IAAI;QAEb;YACE,MAAM,IAAI,MAAM,mEAAmE;IACtF;AACH;AAEA,SAAS,oBAAoB,GAAA,EAAK;IAChC,IAAI,IAAI,MAAA,CAAO,gBAAgB,IAAI,KAAK,IAAI,MAAA,CAAO,oBAAoB,MAAM,GAAG,OAAO;IACvF,IAAI,IAAI,MAAA,CAAO,eAAe,IAAI,KAAK,IAAI,MAAA,CAAO,oBAAoB,MAAM,GAAG,OAAO;IAEtF,OAAO;AACT;AAEA,IAAM,kBAAkC,aAAA,GAAA,IAAI,6JAAA,CAAS;AAIrD;;;mBACc,iEAAO,CAAA,aAAI,iEAAU,CAAA,GAAI;;QACnC,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,UAAA,GAAa,CAAE;QACpB,IAAA,CAAK,OAAA,GAAU,CAAE;QACjB,IAAA,CAAK,OAAA,GAAU;QAGf,IAAA,CAAK,KAAA,GAAQ,IAAI,aAAc;QAG/B,IAAA,CAAK,YAAA,GAAe,aAAA,GAAA,IAAI,IAAK;QAG7B,IAAA,CAAK,cAAA,GAAiB,CAAE;QAGxB,IAAA,CAAK,SAAA,GAAY,CAAE;QAGnB,IAAA,CAAK,SAAA,GAAY;YAAE,MAAM,CAAA;YAAI,MAAM,CAAA;QAAI;QACvC,IAAA,CAAK,WAAA,GAAc;YAAE,MAAM,CAAA;YAAI,MAAM,CAAA;QAAI;QACzC,IAAA,CAAK,UAAA,GAAa;YAAE,MAAM,CAAA;YAAI,MAAM,CAAA;QAAI;QAExC,IAAA,CAAK,WAAA,GAAc,CAAE;QACrB,IAAA,CAAK,YAAA,GAAe,CAAE;QAGtB,IAAA,CAAK,aAAA,GAAgB,CAAE;QAKvB,IAAI,WAAW;QACf,IAAI,YAAY;QAChB,IAAI,iBAAiB,CAAA;QAErB,IAAI,OAAO,cAAc,eAAe,OAAO,UAAU,SAAA,KAAc,aAAa;YAClF,WAAW,iCAAiC,IAAA,CAAK,UAAU,SAAS,MAAM;YAC1E,YAAY,UAAU,SAAA,CAAU,OAAA,CAAQ,SAAS,IAAI,CAAA;YACrD,iBAAiB,YAAY,UAAU,SAAA,CAAU,KAAA,CAAM,qBAAqB,CAAA,CAAE,CAAC,CAAA,GAAI,CAAA;QACpF;QAED,IAAI,OAAO,sBAAsB,eAAe,YAAa,aAAa,iBAAiB,IAAK;YAC9F,IAAA,CAAK,aAAA,GAAgB,IAAI,mKAAA,CAAc,IAAA,CAAK,OAAA,CAAQ,OAAO;QACjE,OAAW;YACL,IAAA,CAAK,aAAA,GAAgB,IAAI,uKAAA,CAAkB,IAAA,CAAK,OAAA,CAAQ,OAAO;QAChE;QAED,IAAA,CAAK,aAAA,CAAc,cAAA,CAAe,IAAA,CAAK,OAAA,CAAQ,WAAW;QAC1D,IAAA,CAAK,aAAA,CAAc,gBAAA,CAAiB,IAAA,CAAK,OAAA,CAAQ,aAAa;QAE9D,IAAA,CAAK,UAAA,GAAa,IAAI,gKAAA,CAAW,IAAA,CAAK,OAAA,CAAQ,OAAO;QACrD,IAAA,CAAK,UAAA,CAAW,eAAA,CAAgB,aAAa;QAE7C,IAAI,IAAA,CAAK,OAAA,CAAQ,WAAA,KAAgB,mBAAmB;YAClD,IAAA,CAAK,UAAA,CAAW,kBAAA,CAAmB,IAAI;QACxC;;;;YAGH;0CAAc,UAAA,EAAY;gBACxB,IAAA,CAAK,UAAA,GAAa;YACnB;;;;4BAED,WAAW,OAAA,EAAS;gBAClB,IAAA,CAAK,OAAA,GAAU;YAChB;;;;4BAED,MAAM,MAAA,EAAQ,OAAA,EAAS;gBACrB,IAAM,SAAS,IAAA;gBACf,IAAM,OAAO,IAAA,CAAK,IAAA;gBAClB,IAAM,aAAa,IAAA,CAAK,UAAA;gBAGxB,IAAA,CAAK,KAAA,CAAM,SAAA,CAAW;gBACtB,IAAA,CAAK,SAAA,GAAY,CAAE;gBAGnB,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;oBAC7B,OAAO,IAAI,SAAA,IAAa,IAAI,SAAA,CAAW;gBAC7C,CAAK;gBAED,QAAQ,GAAA,CACN,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;oBAC7B,OAAO,IAAI,UAAA,IAAc,IAAI,UAAA,CAAY;gBACjD,CAAO,GAEA,IAAA,CAAK,WAAY;oBAChB,OAAO,QAAQ,GAAA,CAAI;wBACjB,OAAO,eAAA,CAAgB,OAAO;wBAC9B,OAAO,eAAA,CAAgB,WAAW;wBAClC,OAAO,eAAA,CAAgB,QAAQ;qBAChC;gBACT,CAAO,EACA,IAAA,CAAK,SAAU,YAAA,EAAc;oBAC5B,IAAM,SAAS;wBACb,OAAO,YAAA,CAAa,CAAC,CAAA,CAAE,KAAK,KAAA,IAAS,CAAC,CAAA;wBACtC,QAAQ,YAAA,CAAa,CAAC,CAAA;wBACtB,YAAY,YAAA,CAAa,CAAC,CAAA;wBAC1B,SAAS,YAAA,CAAa,CAAC,CAAA;wBACvB,OAAO,KAAK,KAAA;gCACZ;wBACA,UAAU,CAAE;oBACb;oBAED,+BAA+B,YAAY,QAAQ,IAAI;oBAEvD,uBAAuB,QAAQ,IAAI;oBAEnC,OAAO,QAAQ,GAAA,CACb,OAAO,UAAA,CAAW,SAAU,GAAA,EAAK;wBAC/B,OAAO,IAAI,SAAA,IAAa,IAAI,SAAA,CAAU,MAAM;oBACxD,CAAW,GACD,IAAA,CAAK,WAAY;4BACjB,kCAAA,2BAAA;;4BAAA,QAAA,YAAoB,OAAO,MAAA,qBAA3B,SAAA,6BAAA,QAAA,yBAAA,iCAAmC;gCAAnC,IAAW,QAAX;gCACE,MAAM,iBAAA,CAAmB;4BAC1B;;4BAFD;4BAAA;;;qCAAA,6BAAA;oCAAA;;;oCAAA;0CAAA;;;;wBAIA,OAAO,MAAM;oBACvB,CAAS;gBACT,CAAO,CACA,SAAA,CAAM,OAAO;YACjB;;;YAAA;;GAAA;4BAKD,YAAY;gBACV,IAAM,WAAW,IAAA,CAAK,IAAA,CAAK,KAAA,IAAS,CAAE,CAAA;gBACtC,IAAM,WAAW,IAAA,CAAK,IAAA,CAAK,KAAA,IAAS,CAAE,CAAA;gBACtC,IAAM,WAAW,IAAA,CAAK,IAAA,CAAK,MAAA,IAAU,CAAE,CAAA;gBAIvC,IAAA,IAAS,YAAY,GAAG,aAAa,SAAS,MAAA,EAAQ,YAAY,YAAY,YAAa;oBACzF,IAAM,SAAS,QAAA,CAAS,SAAS,CAAA,CAAE,MAAA;oBAEnC,IAAA,IAAS,IAAI,GAAG,KAAK,OAAO,MAAA,EAAQ,IAAI,IAAI,IAAK;wBAC/C,QAAA,CAAS,MAAA,CAAO,CAAC,CAAC,CAAA,CAAE,MAAA,GAAS;oBAC9B;gBACF;gBAID,IAAA,IAAS,YAAY,GAAG,aAAa,SAAS,MAAA,EAAQ,YAAY,YAAY,YAAa;oBACzF,IAAM,UAAU,QAAA,CAAS,SAAS,CAAA;oBAElC,IAAI,QAAQ,IAAA,KAAS,KAAA,GAAW;wBAC9B,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,SAAA,EAAW,QAAQ,IAAI;wBAK7C,IAAI,QAAQ,IAAA,KAAS,KAAA,GAAW;4BAC9B,QAAA,CAAS,QAAQ,IAAI,CAAA,CAAE,aAAA,GAAgB;wBACxC;oBACF;oBAED,IAAI,QAAQ,MAAA,KAAW,KAAA,GAAW;wBAChC,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,WAAA,EAAa,QAAQ,MAAM;oBAClD;gBACF;YACF;;;YAAA;;;;;;;;GAAA,GAWD;wCAAY,KAAA,EAAO,KAAA,EAAO;gBACxB,IAAI,UAAU,KAAA,GAAW;gBAEzB,IAAI,MAAM,IAAA,CAAK,KAAK,CAAA,KAAM,KAAA,GAAW;oBACnC,MAAM,IAAA,CAAK,KAAK,CAAA,GAAI,MAAM,IAAA,CAAK,KAAK,CAAA,GAAI;gBACzC;gBAED,MAAM,IAAA,CAAK,KAAK,CAAA;YACjB;;;YAAA,uEAAA;4BAGD,YAAY,KAAA,EAAO,KAAA,EAAO,MAAA,EAAQ;;gBAChC,IAAI,MAAM,IAAA,CAAK,KAAK,CAAA,IAAK,GAAG,OAAO;gBAEnC,IAAM,MAAM,OAAO,KAAA,CAAO;gBAI1B,IAAM,iBAAiB,SAAC,UAAU,UAAU;oBAC1C,IAAM,WAAW,MAAK,YAAA,CAAa,GAAA,CAAI,QAAQ;oBAC/C,IAAI,YAAY,MAAM;wBACpB,MAAK,YAAA,CAAa,GAAA,CAAI,OAAO,QAAQ;oBACtC;wBAED,kCAAA,2BAAA;;wBAAA,QAAA,YAAyB,SAAS,QAAA,CAAS,OAAA,uBAA3C,SAAA,6BAAA,QAAA,yBAAA,iCAAsD;4BAAtD,2LAAA,iBAAY,oBAAG,KAAK;4BAClB,eAAe,OAAO,MAAM,QAAA,CAAS,CAAC,CAAC;wBACxC;;wBAFD;wBAAA;;;iCAAA,6BAAA;gCAAA;;;gCAAA;sCAAA,MAAW;;;;gBAGZ;gBAED,eAAe,QAAQ,GAAG;gBAE1B,IAAI,IAAA,IAAQ,eAAe,MAAM,IAAA,CAAK,KAAK,CAAA;gBAE3C,OAAO;YACR;;;iBAED;uCAAW,IAAA,EAAM;gBACf,IAAM,aAAa,OAAO,MAAA,CAAO,IAAA,CAAK,OAAO;gBAC7C,WAAW,IAAA,CAAK,IAAI;gBAEpB,IAAA,IAAS,IAAI,GAAG,IAAI,WAAW,MAAA,EAAQ,IAAK;oBAC1C,IAAM,SAAS,KAAK,UAAA,CAAW,CAAC,CAAC;oBAEjC,IAAI,QAAQ,OAAO;gBACpB;gBAED,OAAO;YACR;;;;4BAED,WAAW,IAAA,EAAM;gBACf,IAAM,aAAa,OAAO,MAAA,CAAO,IAAA,CAAK,OAAO;gBAC7C,WAAW,OAAA,CAAQ,IAAI;gBAEvB,IAAM,UAAU,CAAE,CAAA;gBAElB,IAAA,IAAS,IAAI,GAAG,IAAI,WAAW,MAAA,EAAQ,IAAK;oBAC1C,IAAM,SAAS,KAAK,UAAA,CAAW,CAAC,CAAC;oBAEjC,IAAI,QAAQ,QAAQ,IAAA,CAAK,MAAM;gBAChC;gBAED,OAAO;YACR;;;YAAA;;;;;GAAA;4BAQD,cAAc,IAAA,EAAM,KAAA,EAAO;gBACzB,IAAM,WAAW,OAAO,MAAM;gBAC9B,IAAI,aAAa,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,QAAQ;gBAExC,IAAI,CAAC,YAAY;oBACf,OAAQ,MAAI;wBACV,KAAK;4BACH,aAAa,IAAA,CAAK,SAAA,CAAU,KAAK;4BACjC;wBAEF,KAAK;4BACH,aAAa,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;gCAC1C,OAAO,IAAI,QAAA,IAAY,IAAI,QAAA,CAAS,KAAK;4BACrD,CAAW;4BACD;wBAEF,KAAK;4BACH,aAAa,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;gCAC1C,OAAO,IAAI,QAAA,IAAY,IAAI,QAAA,CAAS,KAAK;4BACrD,CAAW;4BACD;wBAEF,KAAK;4BACH,aAAa,IAAA,CAAK,YAAA,CAAa,KAAK;4BACpC;wBAEF,KAAK;4BACH,aAAa,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;gCAC1C,OAAO,IAAI,cAAA,IAAkB,IAAI,cAAA,CAAe,KAAK;4BACjE,CAAW;4BACD;wBAEF,KAAK;4BACH,aAAa,IAAA,CAAK,UAAA,CAAW,KAAK;4BAClC;wBAEF,KAAK;4BACH,aAAa,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;gCAC1C,OAAO,IAAI,YAAA,IAAgB,IAAI,YAAA,CAAa,KAAK;4BAC7D,CAAW;4BACD;wBAEF,KAAK;4BACH,aAAa,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;gCAC1C,OAAO,IAAI,WAAA,IAAe,IAAI,WAAA,CAAY,KAAK;4BAC3D,CAAW;4BACD;wBAEF,KAAK;4BACH,aAAa,IAAA,CAAK,QAAA,CAAS,KAAK;4BAChC;wBAEF,KAAK;4BACH,aAAa,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;gCAC1C,OAAO,IAAI,aAAA,IAAiB,IAAI,aAAA,CAAc,KAAK;4BAC/D,CAAW;4BACD;wBAEF,KAAK;4BACH,aAAa,IAAA,CAAK,UAAA,CAAW,KAAK;4BAClC;wBAEF;4BACE,aAAa,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;gCAC1C,OAAO,OAAO,IAAA,IAAQ,IAAI,aAAA,IAAiB,IAAI,aAAA,CAAc,MAAM,KAAK;4BACpF,CAAW;4BAED,IAAI,CAAC,YAAY;gCACf,MAAM,IAAI,MAAM,mBAAmB,IAAI;4BACxC;4BAED;oBACH;oBAED,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,UAAU,UAAU;gBACpC;gBAED,OAAO;YACR;;;YAAA;;;;GAAA;4BAOD,gBAAgB,IAAA,EAAM;gBACpB,IAAI,eAAe,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,IAAI;gBAEtC,IAAI,CAAC,cAAc;oBACjB,IAAM,SAAS,IAAA;oBACf,IAAM,OAAO,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,SAAS,SAAS,OAAO,GAAA,CAAI,CAAA,IAAK,CAAE,CAAA;oBAEnE,eAAe,QAAQ,GAAA,CACrB,KAAK,GAAA,CAAI,SAAU,GAAA,EAAK,KAAA,EAAO;wBAC7B,OAAO,OAAO,aAAA,CAAc,MAAM,KAAK;oBACjD,CAAS;oBAGH,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,MAAM,YAAY;gBAClC;gBAED,OAAO;YACR;;;YAAA;;;;GAAA;4BAOD,WAAW,WAAA,EAAa;gBACtB,IAAM,YAAY,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,WAAW,CAAA;gBAC/C,IAAM,SAAS,IAAA,CAAK,UAAA;gBAEpB,IAAI,UAAU,IAAA,IAAQ,UAAU,IAAA,KAAS,eAAe;oBACtD,MAAM,IAAI,MAAM,uBAAuB,UAAU,IAAA,GAAO,gCAAgC;gBACzF;gBAGD,IAAI,UAAU,GAAA,KAAQ,KAAA,KAAa,gBAAgB,GAAG;oBACpD,OAAO,QAAQ,OAAA,CAAQ,IAAA,CAAK,UAAA,CAAW,WAAW,eAAe,CAAA,CAAE,IAAI;gBACxE;gBAED,IAAM,UAAU,IAAA,CAAK,OAAA;gBAErB,OAAO,IAAI,QAAQ,SAAU,OAAA,EAAS,MAAA,EAAQ;oBAC5C,OAAO,IAAA,CAAK,iKAAA,CAAY,UAAA,CAAW,UAAU,GAAA,EAAK,QAAQ,IAAI,GAAG,SAAS,KAAA,GAAW,WAAY;wBAC/F,OAAO,IAAI,MAAM,8CAA8C,UAAU,GAAA,GAAM,IAAI,CAAC;oBAC5F,CAAO;gBACP,CAAK;YACF;;;YAAA;;;;GAAA;4BAOD,eAAe,eAAA,EAAiB;gBAC9B,IAAM,gBAAgB,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,eAAe,CAAA;gBAE3D,OAAO,IAAA,CAAK,aAAA,CAAc,UAAU,cAAc,MAAM,EAAE,IAAA,CAAK,SAAU,MAAA,EAAQ;oBAC/E,IAAM,aAAa,cAAc,UAAA,IAAc;oBAC/C,IAAM,aAAa,cAAc,UAAA,IAAc;oBAC/C,OAAO,OAAO,KAAA,CAAM,YAAY,aAAa,UAAU;gBAC7D,CAAK;YACF;;;YAAA;;;;GAAA;4BAOD,aAAa,aAAA,EAAe;gBAC1B,IAAM,SAAS,IAAA;gBACf,IAAM,OAAO,IAAA,CAAK,IAAA;gBAElB,IAAM,cAAc,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,aAAa,CAAA;gBAErD,IAAI,YAAY,UAAA,KAAe,KAAA,KAAa,YAAY,MAAA,KAAW,KAAA,GAAW;oBAC5E,IAAM,WAAW,gBAAA,CAAiB,YAAY,IAAI,CAAA;oBAClD,IAAM,aAAa,qBAAA,CAAsB,YAAY,aAAa,CAAA;oBAClE,IAAM,aAAa,YAAY,UAAA,KAAe;oBAE9C,IAAM,QAAQ,IAAI,WAAW,YAAY,KAAA,GAAQ,QAAQ;oBACzD,OAAO,QAAQ,OAAA,CAAQ,IAAI,qKAAA,CAAgB,OAAO,UAAU,UAAU,CAAC;gBACxE;gBAED,IAAM,qBAAqB,CAAE,CAAA;gBAE7B,IAAI,YAAY,UAAA,KAAe,KAAA,GAAW;oBACxC,mBAAmB,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,cAAc,YAAY,UAAU,CAAC;gBACtF,OAAW;oBACL,mBAAmB,IAAA,CAAK,IAAI;gBAC7B;gBAED,IAAI,YAAY,MAAA,KAAW,KAAA,GAAW;oBACpC,mBAAmB,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,cAAc,YAAY,MAAA,CAAO,OAAA,CAAQ,UAAU,CAAC;oBAC/F,mBAAmB,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,cAAc,YAAY,MAAA,CAAO,MAAA,CAAO,UAAU,CAAC;gBAC/F;gBAED,OAAO,QAAQ,GAAA,CAAI,kBAAkB,EAAE,IAAA,CAAK,SAAU,WAAA,EAAa;oBACjE,IAAM,aAAa,WAAA,CAAY,CAAC,CAAA;oBAEhC,IAAM,WAAW,gBAAA,CAAiB,YAAY,IAAI,CAAA;oBAClD,IAAM,aAAa,qBAAA,CAAsB,YAAY,aAAa,CAAA;oBAGlE,IAAM,eAAe,WAAW,iBAAA;oBAChC,IAAM,YAAY,eAAe;oBACjC,IAAM,aAAa,YAAY,UAAA,IAAc;oBAC7C,IAAM,aACJ,YAAY,UAAA,KAAe,KAAA,IAAY,KAAK,WAAA,CAAY,YAAY,UAAU,CAAA,CAAE,UAAA,GAAa,KAAA;oBAC/F,IAAM,aAAa,YAAY,UAAA,KAAe;oBAC9C,IAAI,OAAO;oBAGX,IAAI,cAAc,eAAe,WAAW;wBAG1C,IAAM,UAAU,KAAK,KAAA,CAAM,aAAa,UAAU;wBAClD,IAAM,aACJ,uBACA,YAAY,UAAA,GACZ,MACA,YAAY,aAAA,GACZ,MACA,UACA,MACA,YAAY,KAAA;wBACd,IAAI,KAAK,OAAO,KAAA,CAAM,GAAA,CAAI,UAAU;wBAEpC,IAAI,CAAC,IAAI;4BACP,QAAQ,IAAI,WAAW,YAAY,UAAU,YAAa,YAAY,KAAA,GAAQ,aAAc,YAAY;4BAGxG,KAAK,IAAI,uKAAA,CAAkB,OAAO,aAAa,YAAY;4BAE3D,OAAO,KAAA,CAAM,GAAA,CAAI,YAAY,EAAE;wBAChC;wBAED,kBAAkB,IAAI,gLAAA,CACpB,IACA,UACC,aAAa,aAAc,cAC5B;oBAEV,OAAa;wBACL,IAAI,eAAe,MAAM;4BACvB,QAAQ,IAAI,WAAW,YAAY,KAAA,GAAQ,QAAQ;wBAC7D,OAAe;4BACL,QAAQ,IAAI,WAAW,YAAY,YAAY,YAAY,KAAA,GAAQ,QAAQ;wBAC5E;wBAED,kBAAkB,IAAI,qKAAA,CAAgB,OAAO,UAAU,UAAU;oBAClE;oBAGD,IAAI,YAAY,MAAA,KAAW,KAAA,GAAW;wBACpC,IAAM,kBAAkB,iBAAiB,MAAA;wBACzC,IAAM,oBAAoB,qBAAA,CAAsB,YAAY,MAAA,CAAO,OAAA,CAAQ,aAAa,CAAA;wBAExF,IAAM,oBAAoB,YAAY,MAAA,CAAO,OAAA,CAAQ,UAAA,IAAc;wBACnE,IAAM,mBAAmB,YAAY,MAAA,CAAO,MAAA,CAAO,UAAA,IAAc;wBAEjE,IAAM,gBAAgB,IAAI,kBACxB,WAAA,CAAY,CAAC,CAAA,EACb,mBACA,YAAY,MAAA,CAAO,KAAA,GAAQ;wBAE7B,IAAM,eAAe,IAAI,WAAW,WAAA,CAAY,CAAC,CAAA,EAAG,kBAAkB,YAAY,MAAA,CAAO,KAAA,GAAQ,QAAQ;wBAEzG,IAAI,eAAe,MAAM;4BAEvB,kBAAkB,IAAI,qKAAA,CACpB,gBAAgB,KAAA,CAAM,KAAA,CAAO,GAC7B,gBAAgB,QAAA,EAChB,gBAAgB,UAAA;wBAEnB;wBAED,IAAA,IAAS,IAAI,GAAG,KAAK,cAAc,MAAA,EAAQ,IAAI,IAAI,IAAK;4BACtD,IAAM,QAAQ,aAAA,CAAc,CAAC,CAAA;4BAE7B,gBAAgB,IAAA,CAAK,OAAO,YAAA,CAAa,IAAI,QAAQ,CAAC;4BACtD,IAAI,YAAY,GAAG,gBAAgB,IAAA,CAAK,OAAO,YAAA,CAAa,IAAI,WAAW,CAAC,CAAC;4BAC7E,IAAI,YAAY,GAAG,gBAAgB,IAAA,CAAK,OAAO,YAAA,CAAa,IAAI,WAAW,CAAC,CAAC;4BAC7E,IAAI,YAAY,GAAG,gBAAgB,IAAA,CAAK,OAAO,YAAA,CAAa,IAAI,WAAW,CAAC,CAAC;4BAC7E,IAAI,YAAY,GAAG,MAAM,IAAI,MAAM,mEAAmE;wBACvG;oBACF;oBAED,OAAO;gBACb,CAAK;YACF;;;YAAA;;;;GAAA;4BAOD,YAAY,YAAA,EAAc;gBACxB,IAAM,OAAO,IAAA,CAAK,IAAA;gBAClB,IAAM,UAAU,IAAA,CAAK,OAAA;gBACrB,IAAM,aAAa,KAAK,QAAA,CAAS,YAAY,CAAA;gBAC7C,IAAM,cAAc,WAAW,MAAA;gBAC/B,IAAM,YAAY,KAAK,MAAA,CAAO,WAAW,CAAA;gBAEzC,IAAI,SAAS,IAAA,CAAK,aAAA;gBAElB,IAAI,UAAU,GAAA,EAAK;oBACjB,IAAM,UAAU,QAAQ,OAAA,CAAQ,UAAA,CAAW,UAAU,GAAG;oBACxD,IAAI,YAAY,MAAM,SAAS;gBAChC;gBAED,OAAO,IAAA,CAAK,gBAAA,CAAiB,cAAc,aAAa,MAAM;YAC/D;;;;4BAED,iBAAiB,YAAA,EAAc,WAAA,EAAa,MAAA,EAAQ;gBAClD,IAAM,SAAS,IAAA;gBACf,IAAM,OAAO,IAAA,CAAK,IAAA;gBAElB,IAAM,aAAa,KAAK,QAAA,CAAS,YAAY,CAAA;gBAC7C,IAAM,YAAY,KAAK,MAAA,CAAO,WAAW,CAAA;gBAEzC,IAAM,WAAA,CAAY,UAAU,GAAA,IAAO,UAAU,UAAA,IAAc,MAAM,WAAW,OAAA;gBAE5E,IAAI,IAAA,CAAK,YAAA,CAAa,QAAQ,CAAA,EAAG;oBAE/B,OAAO,IAAA,CAAK,YAAA,CAAa,QAAQ,CAAA;gBAClC;gBAED,IAAM,UAAU,IAAA,CAAK,eAAA,CAAgB,aAAa,MAAM,EACrD,IAAA,CAAK,SAAU,OAAA,EAAS;oBACvB,QAAQ,KAAA,GAAQ;oBAEhB,QAAQ,IAAA,GAAO,WAAW,IAAA,IAAQ,UAAU,IAAA,IAAQ;oBAEpD,IACE,QAAQ,IAAA,KAAS,MACjB,OAAO,UAAU,GAAA,KAAQ,YACzB,UAAU,GAAA,CAAI,UAAA,CAAW,aAAa,MAAM,OAC5C;wBACA,QAAQ,IAAA,GAAO,UAAU,GAAA;oBAC1B;oBAED,IAAM,WAAW,KAAK,QAAA,IAAY,CAAE;oBACpC,IAAM,UAAU,QAAA,CAAS,WAAW,OAAO,CAAA,IAAK,CAAE;oBAElD,QAAQ,SAAA,GAAY,aAAA,CAAc,QAAQ,SAAS,CAAA,IAAK,kKAAA;oBACxD,QAAQ,SAAA,GAAY,aAAA,CAAc,QAAQ,SAAS,CAAA,IAAK,8KAAA;oBACxD,QAAQ,KAAA,GAAQ,eAAA,CAAgB,QAAQ,KAAK,CAAA,IAAK,oKAAA;oBAClD,QAAQ,KAAA,GAAQ,eAAA,CAAgB,QAAQ,KAAK,CAAA,IAAK,oKAAA;oBAElD,OAAO,YAAA,CAAa,GAAA,CAAI,SAAS;wBAAE,UAAU;oBAAA,CAAc;oBAE3D,OAAO;gBACf,CAAO,EACA,QAAA,CAAM,WAAY;oBACjB,OAAO;gBACf,CAAO;gBAEH,IAAA,CAAK,YAAA,CAAa,QAAQ,CAAA,GAAI;gBAE9B,OAAO;YACR;;;YAED;4CAAgB,WAAA,EAAa,MAAA,EAAQ;gBACnC,IAAM,SAAS,IAAA;gBACf,IAAM,OAAO,IAAA,CAAK,IAAA;gBAClB,IAAM,UAAU,IAAA,CAAK,OAAA;gBAErB,IAAI,IAAA,CAAK,WAAA,CAAY,WAAW,CAAA,KAAM,KAAA,GAAW;oBAC/C,OAAO,IAAA,CAAK,WAAA,CAAY,WAAW,CAAA,CAAE,IAAA,CAAK,SAAC;+BAAY,QAAQ,KAAA,EAAO;;gBACvE;gBAED,IAAM,YAAY,KAAK,MAAA,CAAO,WAAW,CAAA;gBAEzC,IAAM,MAAM,KAAK,GAAA,IAAO,KAAK,SAAA;gBAE7B,IAAI,YAAY,UAAU,GAAA,IAAO;gBACjC,IAAI,cAAc;gBAElB,IAAI,UAAU,UAAA,KAAe,KAAA,GAAW;oBAGtC,YAAY,OAAO,aAAA,CAAc,cAAc,UAAU,UAAU,EAAE,IAAA,CAAK,SAAU,UAAA,EAAY;wBAC9F,cAAc;wBACd,IAAM,OAAO,IAAI,KAAK;4BAAC,UAAU;yBAAA,EAAG;4BAAE,MAAM,UAAU,QAAA;wBAAA,CAAU;wBAChE,YAAY,IAAI,eAAA,CAAgB,IAAI;wBACpC,OAAO;oBACf,CAAO;gBACP,OAAA,IAAe,UAAU,GAAA,KAAQ,KAAA,GAAW;oBACtC,MAAM,IAAI,MAAM,6BAA6B,cAAc,gCAAgC;gBAC5F;gBAED,IAAM,UAAU,QAAQ,OAAA,CAAQ,SAAS,EACtC,IAAA,CAAK,SAAUC,UAAAA,EAAW;oBACzB,OAAO,IAAI,QAAQ,SAAU,OAAA,EAAS,MAAA,EAAQ;wBAC5C,IAAI,SAAS;wBAEb,IAAI,OAAO,mBAAA,KAAwB,MAAM;4BACvC,SAAS,gBAAU,WAAA,EAAa;gCAC9B,IAAM,UAAU,IAAI,6JAAA,CAAQ,WAAW;gCACvC,QAAQ,WAAA,GAAc;gCAEtB,QAAQ,OAAO;4BAChB;wBACF;wBAED,OAAO,IAAA,CAAK,iKAAA,CAAY,UAAA,CAAWA,YAAW,QAAQ,IAAI,GAAG,QAAQ,KAAA,GAAW,MAAM;oBAChG,CAAS;gBACT,CAAO,EACA,IAAA,CAAK,SAAU,OAAA,EAAS;oBAGvB,IAAI,gBAAgB,MAAM;wBACxB,IAAI,eAAA,CAAgB,SAAS;oBAC9B;oBAED,uBAAuB,SAAS,SAAS;oBAEzC,QAAQ,QAAA,CAAS,QAAA,GAAW,UAAU,QAAA,IAAY,oBAAoB,UAAU,GAAG;oBAEnF,OAAO;gBACf,CAAO,EACA,QAAA,CAAM,SAAU,KAAA,EAAO;oBACtB,QAAQ,KAAA,CAAM,2CAA2C,SAAS;oBAClE,MAAM;gBACd,CAAO;gBAEH,IAAA,CAAK,WAAA,CAAY,WAAW,CAAA,GAAI;gBAChC,OAAO;YACR;;;YAAA;;;;;;GAAA;4BASD,cAAc,cAAA,EAAgB,OAAA,EAAS,MAAA,EAAQ,UAAA,EAAY;gBACzD,IAAM,SAAS,IAAA;gBAEf,OAAO,IAAA,CAAK,aAAA,CAAc,WAAW,OAAO,KAAK,EAAE,IAAA,CAAK,SAAU,OAAA,EAAS;oBACzE,IAAI,CAAC,SAAS,OAAO;oBAErB,IAAI,OAAO,QAAA,KAAa,KAAA,KAAa,OAAO,QAAA,GAAW,GAAG;wBACxD,UAAU,QAAQ,KAAA,CAAO;wBACzB,QAAQ,OAAA,GAAU,OAAO,QAAA;oBAC1B;oBAED,IAAI,OAAO,UAAA,CAAW,WAAW,qBAAqB,CAAA,EAAG;wBACvD,IAAM,YACJ,OAAO,UAAA,KAAe,KAAA,IAAY,OAAO,UAAA,CAAW,WAAW,qBAAqB,CAAA,GAAI,KAAA;wBAE1F,IAAI,WAAW;4BACb,IAAM,gBAAgB,OAAO,YAAA,CAAa,GAAA,CAAI,OAAO;4BACrD,UAAU,OAAO,UAAA,CAAW,WAAW,qBAAqB,CAAA,CAAE,aAAA,CAAc,SAAS,SAAS;4BAC9F,OAAO,YAAA,CAAa,GAAA,CAAI,SAAS,aAAa;wBAC/C;oBACF;oBAED,IAAI,eAAe,KAAA,GAAW;wBAE5B,IAAI,OAAO,eAAe,UACxB,aAAa,eAAe,eAAe,iBAAiB;wBAG9D,IAAI,gBAAgB,SAAS,QAAQ,UAAA,GAAa;6BAC7C,QAAQ,QAAA,GAAW,eAAe,iBAAiB,eAAe;oBACxE;oBAED,cAAA,CAAe,OAAO,CAAA,GAAI;oBAE1B,OAAO;gBACb,CAAK;YACF;;;YAAA;;;;;;;GAAA,GAUD;gDAAoB,IAAA,EAAM;gBACxB,IAAM,WAAW,KAAK,QAAA;gBACtB,IAAI,WAAW,KAAK,QAAA;gBAEpB,IAAM,wBAAwB,SAAS,UAAA,CAAW,OAAA,KAAY,KAAA;gBAC9D,IAAM,kBAAkB,SAAS,UAAA,CAAW,KAAA,KAAU,KAAA;gBACtD,IAAM,iBAAiB,SAAS,UAAA,CAAW,MAAA,KAAW,KAAA;gBAEtD,IAAI,KAAK,QAAA,EAAU;oBACjB,IAAM,WAAW,oBAAoB,SAAS,IAAA;oBAE9C,IAAI,iBAAiB,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,QAAQ;oBAE5C,IAAI,CAAC,gBAAgB;wBACnB,iBAAiB,IAAI,oKAAA,CAAgB;wBACrC,8JAAA,CAAS,SAAA,CAAU,IAAA,CAAK,IAAA,CAAK,gBAAgB,QAAQ;wBACrD,eAAe,KAAA,CAAM,IAAA,CAAK,SAAS,KAAK;wBACxC,eAAe,GAAA,GAAM,SAAS,GAAA;wBAC9B,eAAe,eAAA,GAAkB;wBAEjC,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,UAAU,cAAc;oBACxC;oBAED,WAAW;gBACjB,OAAA,IAAe,KAAK,MAAA,EAAQ;oBACtB,IAAM,YAAW,uBAAuB,SAAS,IAAA;oBAEjD,IAAI,eAAe,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,QAAQ;oBAE1C,IAAI,CAAC,cAAc;wBACjB,eAAe,IAAI,uKAAA,CAAmB;wBACtC,8JAAA,CAAS,SAAA,CAAU,IAAA,CAAK,IAAA,CAAK,cAAc,QAAQ;wBACnD,aAAa,KAAA,CAAM,IAAA,CAAK,SAAS,KAAK;wBACtC,aAAa,GAAA,GAAM,SAAS,GAAA;wBAE5B,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,WAAU,YAAY;oBACtC;oBAED,WAAW;gBACZ;gBAGD,IAAI,yBAAyB,mBAAmB,gBAAgB;oBAC9D,IAAI,YAAW,oBAAoB,SAAS,IAAA,GAAO;oBAEnD,IAAI,uBAAuB,aAAY;oBACvC,IAAI,iBAAiB,aAAY;oBACjC,IAAI,gBAAgB,aAAY;oBAEhC,IAAI,iBAAiB,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,QAAQ;oBAE5C,IAAI,CAAC,gBAAgB;wBACnB,iBAAiB,SAAS,KAAA,CAAO;wBAEjC,IAAI,iBAAiB,eAAe,YAAA,GAAe;wBACnD,IAAI,gBAAgB,eAAe,WAAA,GAAc;wBAEjD,IAAI,uBAAuB;4BAEzB,IAAI,eAAe,WAAA,EAAa,eAAe,WAAA,CAAY,CAAA,IAAK,CAAA;4BAChE,IAAI,eAAe,oBAAA,EAAsB,eAAe,oBAAA,CAAqB,CAAA,IAAK,CAAA;wBACnF;wBAED,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,WAAU,cAAc;wBAEvC,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,gBAAgB,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,QAAQ,CAAC;oBACtE;oBAED,WAAW;gBACZ;gBAED,KAAK,QAAA,GAAW;YACjB;;;;4BAED,kBAAqC;gBACnC,OAAO,0KAAA;YACR;;;YAAA;;;;GAAA;4BAOD,aAAa,aAAA,EAAe;gBAC1B,IAAM,SAAS,IAAA;gBACf,IAAM,OAAO,IAAA,CAAK,IAAA;gBAClB,IAAM,aAAa,IAAA,CAAK,UAAA;gBACxB,IAAM,cAAc,KAAK,SAAA,CAAU,aAAa,CAAA;gBAEhD,IAAI;gBACJ,IAAM,iBAAiB,CAAE;gBACzB,IAAM,qBAAqB,YAAY,UAAA,IAAc,CAAE;gBAEvD,IAAM,UAAU,CAAE,CAAA;gBAElB,IAAI,kBAAA,CAAmB,WAAW,mBAAmB,CAAA,EAAG;oBACtD,IAAM,eAAe,UAAA,CAAW,WAAW,mBAAmB,CAAA;oBAC9D,eAAe,aAAa,eAAA,CAAiB;oBAC7C,QAAQ,IAAA,CAAK,aAAa,YAAA,CAAa,gBAAgB,aAAa,MAAM,CAAC;gBACjF,OAAW;oBAIL,IAAM,oBAAoB,YAAY,oBAAA,IAAwB,CAAE;oBAEhE,eAAe,KAAA,GAAQ,IAAI,2JAAA,CAAM,GAAK,GAAK,CAAG;oBAC9C,eAAe,OAAA,GAAU;oBAEzB,IAAI,MAAM,OAAA,CAAQ,kBAAkB,eAAe,GAAG;wBACpD,IAAM,QAAQ,kBAAkB,eAAA;wBAEhC,eAAe,KAAA,CAAM,MAAA,CAAO,KAAA,CAAM,CAAC,CAAA,EAAG,KAAA,CAAM,CAAC,CAAA,EAAG,KAAA,CAAM,CAAC,CAAA,EAAG,oBAAoB;wBAC9E,eAAe,OAAA,GAAU,KAAA,CAAM,CAAC,CAAA;oBACjC;oBAED,IAAI,kBAAkB,gBAAA,KAAqB,KAAA,GAAW;wBACpD,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,OAAO,kBAAkB,gBAAA,EAAkB,cAAc,CAAC;oBAC7G;oBAED,eAAe,SAAA,GAAY,kBAAkB,cAAA,KAAmB,KAAA,IAAY,kBAAkB,cAAA,GAAiB;oBAC/G,eAAe,SAAA,GACb,kBAAkB,eAAA,KAAoB,KAAA,IAAY,kBAAkB,eAAA,GAAkB;oBAExF,IAAI,kBAAkB,wBAAA,KAA6B,KAAA,GAAW;wBAC5D,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,gBAAgB,kBAAkB,wBAAwB,CAAC;wBAC7G,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,gBAAgB,kBAAkB,wBAAwB,CAAC;oBAC9G;oBAED,eAAe,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;wBAC5C,OAAO,IAAI,eAAA,IAAmB,IAAI,eAAA,CAAgB,aAAa;oBACvE,CAAO;oBAED,QAAQ,IAAA,CACN,QAAQ,GAAA,CACN,IAAA,CAAK,UAAA,CAAW,SAAU,GAAA,EAAK;wBAC7B,OAAO,IAAI,oBAAA,IAAwB,IAAI,oBAAA,CAAqB,eAAe,cAAc;oBACrG,CAAW;gBAGN;gBAED,IAAI,YAAY,WAAA,KAAgB,MAAM;oBACpC,eAAe,IAAA,GAAO,gKAAA;gBACvB;gBAED,IAAM,YAAY,YAAY,SAAA,IAAa,YAAY,MAAA;gBAEvD,IAAI,cAAc,YAAY,KAAA,EAAO;oBACnC,eAAe,WAAA,GAAc;oBAG7B,eAAe,UAAA,GAAa;gBAClC,OAAW;oBACL,eAAe,WAAA,GAAc;oBAE7B,IAAI,cAAc,YAAY,IAAA,EAAM;wBAClC,eAAe,SAAA,GAAY,YAAY,WAAA,KAAgB,KAAA,IAAY,YAAY,WAAA,GAAc;oBAC9F;gBACF;gBAED,IAAI,YAAY,aAAA,KAAkB,KAAA,KAAa,iBAAiB,uKAAA,EAAmB;oBACjF,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,aAAa,YAAY,aAAa,CAAC;oBAEzF,eAAe,WAAA,GAAc,IAAI,6JAAA,CAAQ,GAAG,CAAC;oBAE7C,IAAI,YAAY,aAAA,CAAc,KAAA,KAAU,KAAA,GAAW;wBACjD,IAAM,QAAQ,YAAY,aAAA,CAAc,KAAA;wBAExC,eAAe,WAAA,CAAY,GAAA,CAAI,OAAO,KAAK;oBAC5C;gBACF;gBAED,IAAI,YAAY,gBAAA,KAAqB,KAAA,KAAa,iBAAiB,uKAAA,EAAmB;oBACpF,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,SAAS,YAAY,gBAAgB,CAAC;oBAExF,IAAI,YAAY,gBAAA,CAAiB,QAAA,KAAa,KAAA,GAAW;wBACvD,eAAe,cAAA,GAAiB,YAAY,gBAAA,CAAiB,QAAA;oBAC9D;gBACF;gBAED,IAAI,YAAY,cAAA,KAAmB,KAAA,KAAa,iBAAiB,uKAAA,EAAmB;oBAClF,IAAM,iBAAiB,YAAY,cAAA;oBACnC,eAAe,QAAA,GAAW,IAAI,2JAAA,CAAK,EAAG,MAAA,CACpC,cAAA,CAAe,CAAC,CAAA,EAChB,cAAA,CAAe,CAAC,CAAA,EAChB,cAAA,CAAe,CAAC,CAAA,EAChB;gBAEH;gBAED,IAAI,YAAY,eAAA,KAAoB,KAAA,KAAa,iBAAiB,uKAAA,EAAmB;oBACnF,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,gBAAgB,eAAe,YAAY,eAAA,EAAiB,cAAc,CAAC;gBAC9G;gBAED,OAAO,QAAQ,GAAA,CAAI,OAAO,EAAE,IAAA,CAAK,WAAY;oBAC3C,IAAM,WAAW,IAAI,aAAa,cAAc;oBAEhD,IAAI,YAAY,IAAA,EAAM,SAAS,IAAA,GAAO,YAAY,IAAA;oBAElD,uBAAuB,UAAU,WAAW;oBAE5C,OAAO,YAAA,CAAa,GAAA,CAAI,UAAU;wBAAE,WAAW;oBAAA,CAAe;oBAE9D,IAAI,YAAY,UAAA,EAAY,+BAA+B,YAAY,UAAU,WAAW;oBAE5F,OAAO;gBACb,CAAK;YACF;;;YAAA,+EAAA;mBAGD,0BAAiB,YAAA,EAAc;gBAC7B,IAAM,gBAAgB,qKAAA,CAAgB,gBAAA,CAAiB,gBAAgB,EAAE;gBAEzE,IAAI,iBAAiB,IAAA,CAAK,aAAA,EAAe;oBACvC,OAAO,gBAAgB,MAAM,EAAE,IAAA,CAAK,aAAA,CAAc,aAAa,CAAA;gBACrE,OAAW;oBACL,IAAA,CAAK,aAAA,CAAc,aAAa,CAAA,GAAI;oBAEpC,OAAO;gBACR;YACF;;;YAAA;;;;;;;GAAA,GAUD;2CAAe,UAAA,EAAY;gBACzB,IAAM,SAAS,IAAA;gBACf,IAAM,aAAa,IAAA,CAAK,UAAA;gBACxB,IAAM,QAAQ,IAAA,CAAK,cAAA;gBAEnB,SAAS,qBAAqB,SAAA,EAAW;oBACvC,OAAO,UAAA,CAAW,WAAW,0BAA0B,CAAA,CACpD,eAAA,CAAgB,WAAW,MAAM,EACjC,IAAA,CAAK,SAAU,QAAA,EAAU;wBACxB,OAAO,uBAAuB,UAAU,WAAW,MAAM;oBACnE,CAAS;gBACJ;gBAED,IAAM,UAAU,CAAE,CAAA;gBAElB,IAAA,IAAS,IAAI,GAAG,KAAK,WAAW,MAAA,EAAQ,IAAI,IAAI,IAAK;oBACnD,IAAM,YAAY,UAAA,CAAW,CAAC,CAAA;oBAC9B,IAAM,WAAW,mBAAmB,SAAS;oBAG7C,IAAM,SAAS,KAAA,CAAM,QAAQ,CAAA;oBAE7B,IAAI,QAAQ;wBAEV,QAAQ,IAAA,CAAK,OAAO,OAAO;oBACnC,OAAa;wBACL,sBAAI;wBAEJ,IAAI,UAAU,UAAA,IAAc,UAAU,UAAA,CAAW,WAAW,0BAA0B,CAAA,EAAG;4BAEvF,kBAAkB,qBAAqB,SAAS;wBAC1D,OAAe;4BAEL,kBAAkB,uBAAuB,IAAI,oKAAA,CAAc,GAAI,WAAW,MAAM;wBACjF;wBAGD,KAAA,CAAM,QAAQ,CAAA,GAAI;uCAAE;4BAAsB,SAAS;wBAAiB;wBAEpE,QAAQ,IAAA,CAAK,eAAe;oBAC7B;gBACF;gBAED,OAAO,QAAQ,GAAA,CAAI,OAAO;YAC3B;;;YAAA;;;;GAAA;4BAOD,SAAS,SAAA,EAAW;gBAClB,IAAM,SAAS,IAAA;gBACf,IAAM,OAAO,IAAA,CAAK,IAAA;gBAClB,IAAM,aAAa,IAAA,CAAK,UAAA;gBAExB,IAAM,UAAU,KAAK,MAAA,CAAO,SAAS,CAAA;gBACrC,IAAM,aAAa,QAAQ,UAAA;gBAE3B,IAAM,UAAU,CAAE,CAAA;gBAElB,IAAA,IAAS,IAAI,GAAG,KAAK,WAAW,MAAA,EAAQ,IAAI,IAAI,IAAK;oBACnD,IAAM,WACJ,UAAA,CAAW,CAAC,CAAA,CAAE,QAAA,KAAa,KAAA,IACvB,sBAAsB,IAAA,CAAK,KAAK,IAChC,IAAA,CAAK,aAAA,CAAc,YAAY,UAAA,CAAW,CAAC,CAAA,CAAE,QAAQ;oBAE3D,QAAQ,IAAA,CAAK,QAAQ;gBACtB;gBAED,QAAQ,IAAA,CAAK,OAAO,cAAA,CAAe,UAAU,CAAC;gBAE9C,OAAO,QAAQ,GAAA,CAAI,OAAO,EAAE,IAAA,CAAK,SAAU,OAAA,EAAS;oBAClD,IAAM,YAAY,QAAQ,KAAA,CAAM,GAAG,QAAQ,MAAA,GAAS,CAAC;oBACrD,IAAM,aAAa,OAAA,CAAQ,QAAQ,MAAA,GAAS,CAAC,CAAA;oBAE7C,IAAM,SAAS,CAAE,CAAA;oBAEjB,IAAA,IAAS,IAAI,GAAG,KAAK,WAAW,MAAA,EAAQ,IAAI,IAAI,IAAK;wBACnD,IAAM,WAAW,UAAA,CAAW,CAAC,CAAA;wBAC7B,IAAM,YAAY,UAAA,CAAW,CAAC,CAAA;wBAI9B,gBAAI;wBAEJ,IAAM,WAAW,SAAA,CAAU,CAAC,CAAA;wBAE5B,IACE,UAAU,IAAA,KAAS,gBAAgB,SAAA,IACnC,UAAU,IAAA,KAAS,gBAAgB,cAAA,IACnC,UAAU,IAAA,KAAS,gBAAgB,YAAA,IACnC,UAAU,IAAA,KAAS,KAAA,GACnB;4BAEA,OAAO,QAAQ,aAAA,KAAkB,OAAO,IAAI,iKAAA,CAAY,UAAU,QAAQ,IAAI,IAAI,0JAAA,CAAK,UAAU,QAAQ;4BAEzG,IAAI,KAAK,aAAA,KAAkB,MAAM;gCAE/B,KAAK,oBAAA,CAAsB;4BAC5B;4BAED,IAAI,UAAU,IAAA,KAAS,gBAAgB,cAAA,EAAgB;gCACrD,KAAK,QAAA,GAAW,6LAAA,EAAoB,KAAK,QAAA,EAAU,2KAAqB;4BACzE,OAAA,IAAU,UAAU,IAAA,KAAS,gBAAgB,YAAA,EAAc;gCAC1D,KAAK,QAAA,OAAW,yLAAA,EAAoB,KAAK,QAAA,EAAU,yKAAmB;4BACvE;wBACF,OAAA,IAAU,UAAU,IAAA,KAAS,gBAAgB,KAAA,EAAO;4BACnD,OAAO,IAAI,kKAAA,CAAa,UAAU,QAAQ;wBAC3C,OAAA,IAAU,UAAU,IAAA,KAAS,gBAAgB,UAAA,EAAY;4BACxD,OAAO,IAAI,0JAAA,CAAK,UAAU,QAAQ;wBACnC,OAAA,IAAU,UAAU,IAAA,KAAS,gBAAgB,SAAA,EAAW;4BACvD,OAAO,IAAI,8JAAA,CAAS,UAAU,QAAQ;wBACvC,OAAA,IAAU,UAAU,IAAA,KAAS,gBAAgB,MAAA,EAAQ;4BACpD,OAAO,IAAI,4JAAA,CAAO,UAAU,QAAQ;wBAC9C,OAAe;4BACL,MAAM,IAAI,MAAM,mDAAmD,UAAU,IAAI;wBAClF;wBAED,IAAI,OAAO,IAAA,CAAK,KAAK,QAAA,CAAS,eAAe,EAAE,MAAA,GAAS,GAAG;4BACzD,mBAAmB,MAAM,OAAO;wBACjC;wBAED,KAAK,IAAA,GAAO,OAAO,gBAAA,CAAiB,QAAQ,IAAA,IAAQ,UAAU,SAAS;wBAEvE,uBAAuB,MAAM,OAAO;wBAEpC,IAAI,UAAU,UAAA,EAAY,+BAA+B,YAAY,MAAM,SAAS;wBAEpF,OAAO,mBAAA,CAAoB,IAAI;wBAE/B,OAAO,IAAA,CAAK,IAAI;oBACjB;oBAED,IAAA,IAAS,KAAI,GAAG,MAAK,OAAO,MAAA,EAAQ,KAAI,KAAI,KAAK;wBAC/C,OAAO,YAAA,CAAa,GAAA,CAAI,MAAA,CAAO,CAAC,EAAA,EAAG;4BACjC,QAAQ;4BACR,YAAY;wBACtB,CAAS;oBACF;oBAED,IAAI,OAAO,MAAA,KAAW,GAAG;wBACvB,IAAI,QAAQ,UAAA,EAAY,+BAA+B,YAAY,MAAA,CAAO,CAAC,CAAA,EAAG,OAAO;wBAErF,OAAO,MAAA,CAAO,CAAC,CAAA;oBAChB;oBAED,IAAM,QAAQ,IAAI,2JAAA,CAAO;oBAEzB,IAAI,QAAQ,UAAA,EAAY,+BAA+B,YAAY,OAAO,OAAO;oBAEjF,OAAO,YAAA,CAAa,GAAA,CAAI,OAAO;wBAAE,QAAQ;oBAAA,CAAW;oBAEpD,IAAA,IAAS,KAAI,GAAG,MAAK,OAAO,MAAA,EAAQ,KAAI,KAAI,KAAK;wBAC/C,MAAM,GAAA,CAAI,MAAA,CAAO,CAAC,EAAC;oBACpB;oBAED,OAAO;gBACb,CAAK;YACF;;;YAAA;;;;GAAA;4BAOD,WAAW,WAAA,EAAa;gBACtB,IAAI;gBACJ,IAAM,YAAY,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,WAAW,CAAA;gBAC/C,IAAM,SAAS,SAAA,CAAU,UAAU,IAAI,CAAA;gBAEvC,IAAI,CAAC,QAAQ;oBACX,QAAQ,IAAA,CAAK,8CAA8C;oBAC3D;gBACD;gBAED,IAAI,UAAU,IAAA,KAAS,eAAe;oBACpC,SAAS,IAAI,uKAAA,CACX,+JAAA,CAAU,QAAA,CAAS,OAAO,IAAI,GAC9B,OAAO,WAAA,IAAe,GACtB,OAAO,KAAA,IAAS,GAChB,OAAO,IAAA,IAAQ;gBAEvB,OAAA,IAAe,UAAU,IAAA,KAAS,gBAAgB;oBAC5C,SAAS,IAAI,wKAAA,CAAmB,CAAC,OAAO,IAAA,EAAM,OAAO,IAAA,EAAM,OAAO,IAAA,EAAM,CAAC,OAAO,IAAA,EAAM,OAAO,KAAA,EAAO,OAAO,IAAI;gBAChH;gBAED,IAAI,UAAU,IAAA,EAAM,OAAO,IAAA,GAAO,IAAA,CAAK,gBAAA,CAAiB,UAAU,IAAI;gBAEtE,uBAAuB,QAAQ,SAAS;gBAExC,OAAO,QAAQ,OAAA,CAAQ,MAAM;YAC9B;;;YAAA;;;;GAAA;mBAOD,kBAAS,SAAA,EAAW;gBAClB,IAAM,UAAU,IAAA,CAAK,IAAA,CAAK,KAAA,CAAM,SAAS,CAAA;gBAEzC,IAAM,UAAU,CAAE,CAAA;gBAElB,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,MAAA,CAAO,MAAA,EAAQ,IAAI,IAAI,IAAK;oBACvD,QAAQ,IAAA,CAAK,IAAA,CAAK,gBAAA,CAAiB,QAAQ,MAAA,CAAO,CAAC,CAAC,CAAC;gBACtD;gBAED,IAAI,QAAQ,mBAAA,KAAwB,KAAA,GAAW;oBAC7C,QAAQ,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,YAAY,QAAQ,mBAAmB,CAAC;gBAC9E,OAAW;oBACL,QAAQ,IAAA,CAAK,IAAI;gBAClB;gBAED,OAAO,QAAQ,GAAA,CAAI,OAAO,EAAE,IAAA,CAAK,SAAU,OAAA,EAAS;oBAClD,IAAM,sBAAsB,QAAQ,GAAA,CAAK;oBACzC,IAAM,aAAa;oBAKnB,IAAM,QAAQ,CAAE,CAAA;oBAChB,IAAM,eAAe,CAAE,CAAA;oBAEvB,IAAA,IAAS,IAAI,GAAG,KAAK,WAAW,MAAA,EAAQ,IAAI,IAAI,IAAK;wBACnD,IAAM,YAAY,UAAA,CAAW,CAAC,CAAA;wBAE9B,IAAI,WAAW;4BACb,MAAM,IAAA,CAAK,SAAS;4BAEpB,IAAM,MAAM,IAAI,6JAAA,CAAS;4BAEzB,IAAI,wBAAwB,MAAM;gCAChC,IAAI,SAAA,CAAU,oBAAoB,KAAA,EAAO,IAAI,EAAE;4BAChD;4BAED,aAAa,IAAA,CAAK,GAAG;wBAC/B,OAAe;4BACL,QAAQ,IAAA,CAAK,oDAAoD,QAAQ,MAAA,CAAO,CAAC,CAAC;wBACnF;oBACF;oBAED,OAAO,IAAI,8JAAA,CAAS,OAAO,YAAY;gBAC7C,CAAK;YACF;;;YAAA;;;;GAAA;4BAOD,cAAc,cAAA,EAAgB;gBAC5B,IAAM,OAAO,IAAA,CAAK,IAAA;gBAClB,IAAM,SAAS,IAAA;gBAEf,IAAM,eAAe,KAAK,UAAA,CAAW,cAAc,CAAA;gBACnD,IAAM,gBAAgB,aAAa,IAAA,GAAO,aAAa,IAAA,GAAO,eAAe;gBAE7E,IAAM,eAAe,CAAE,CAAA;gBACvB,IAAM,wBAAwB,CAAE,CAAA;gBAChC,IAAM,yBAAyB,CAAE,CAAA;gBACjC,IAAM,kBAAkB,CAAE,CAAA;gBAC1B,IAAM,iBAAiB,CAAE,CAAA;gBAEzB,IAAA,IAAS,IAAI,GAAG,KAAK,aAAa,QAAA,CAAS,MAAA,EAAQ,IAAI,IAAI,IAAK;oBAC9D,IAAM,UAAU,aAAa,QAAA,CAAS,CAAC,CAAA;oBACvC,IAAM,UAAU,aAAa,QAAA,CAAS,QAAQ,OAAO,CAAA;oBACrD,IAAM,SAAS,QAAQ,MAAA;oBACvB,IAAM,OAAO,OAAO,IAAA;oBACpB,IAAM,QAAQ,aAAa,UAAA,KAAe,KAAA,IAAY,aAAa,UAAA,CAAW,QAAQ,KAAK,CAAA,GAAI,QAAQ,KAAA;oBACvG,IAAM,SAAS,aAAa,UAAA,KAAe,KAAA,IAAY,aAAa,UAAA,CAAW,QAAQ,MAAM,CAAA,GAAI,QAAQ,MAAA;oBAEzG,IAAI,OAAO,IAAA,KAAS,KAAA,GAAW;oBAE/B,aAAa,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,QAAQ,IAAI,CAAC;oBAClD,sBAAsB,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,YAAY,KAAK,CAAC;oBAChE,uBAAuB,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,YAAY,MAAM,CAAC;oBAClE,gBAAgB,IAAA,CAAK,OAAO;oBAC5B,eAAe,IAAA,CAAK,MAAM;gBAC3B;gBAED,OAAO,QAAQ,GAAA,CAAI;oBACjB,QAAQ,GAAA,CAAI,YAAY;oBACxB,QAAQ,GAAA,CAAI,qBAAqB;oBACjC,QAAQ,GAAA,CAAI,sBAAsB;oBAClC,QAAQ,GAAA,CAAI,eAAe;oBAC3B,QAAQ,GAAA,CAAI,cAAc;iBAC3B,EAAE,IAAA,CAAK,SAAU,YAAA,EAAc;oBAC9B,IAAM,QAAQ,YAAA,CAAa,CAAC,CAAA;oBAC5B,IAAM,iBAAiB,YAAA,CAAa,CAAC,CAAA;oBACrC,IAAM,kBAAkB,YAAA,CAAa,CAAC,CAAA;oBACtC,IAAM,WAAW,YAAA,CAAa,CAAC,CAAA;oBAC/B,IAAM,UAAU,YAAA,CAAa,CAAC,CAAA;oBAE9B,IAAM,SAAS,CAAE,CAAA;oBAEjB,IAAA,IAAS,IAAI,GAAG,KAAK,MAAM,MAAA,EAAQ,IAAI,IAAI,IAAK;wBAC9C,IAAM,OAAO,KAAA,CAAM,CAAC,CAAA;wBACpB,IAAM,gBAAgB,cAAA,CAAe,CAAC,CAAA;wBACtC,IAAM,iBAAiB,eAAA,CAAgB,CAAC,CAAA;wBACxC,IAAM,UAAU,QAAA,CAAS,CAAC,CAAA;wBAC1B,IAAM,SAAS,OAAA,CAAQ,CAAC,CAAA;wBAExB,IAAI,SAAS,KAAA,GAAW;wBAExB,IAAI,KAAK,YAAA,EAAc;4BACrB,KAAK,YAAA,CAAc;wBACpB;wBAED,IAAM,gBAAgB,OAAO,sBAAA,CAAuB,MAAM,eAAe,gBAAgB,SAAS,MAAM;wBAExG,IAAI,eAAe;4BACjB,IAAA,IAAS,IAAI,GAAG,IAAI,cAAc,MAAA,EAAQ,IAAK;gCAC7C,OAAO,IAAA,CAAK,aAAA,CAAc,CAAC,CAAC;4BAC7B;wBACF;oBACF;oBAED,OAAO,IAAI,mKAAA,CAAc,eAAe,KAAA,GAAW,MAAM;gBAC/D,CAAK;YACF;;;;4BAED,eAAe,SAAA,EAAW;gBACxB,IAAM,OAAO,IAAA,CAAK,IAAA;gBAClB,IAAM,SAAS,IAAA;gBACf,IAAM,UAAU,KAAK,KAAA,CAAM,SAAS,CAAA;gBAEpC,IAAI,QAAQ,IAAA,KAAS,KAAA,GAAW,OAAO;gBAEvC,OAAO,OAAO,aAAA,CAAc,QAAQ,QAAQ,IAAI,EAAE,IAAA,CAAK,SAAU,IAAA,EAAM;oBACrE,IAAM,OAAO,OAAO,WAAA,CAAY,OAAO,SAAA,EAAW,QAAQ,IAAA,EAAM,IAAI;oBAGpE,IAAI,QAAQ,OAAA,KAAY,KAAA,GAAW;wBACjC,KAAK,QAAA,CAAS,SAAU,CAAA,EAAG;4BACzB,IAAI,CAAC,EAAE,MAAA,EAAQ;4BAEf,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,OAAA,CAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;gCACxD,EAAE,qBAAA,CAAsB,CAAC,CAAA,GAAI,QAAQ,OAAA,CAAQ,CAAC,CAAA;4BAC/C;wBACX,CAAS;oBACF;oBAED,OAAO;gBACb,CAAK;YACF;;;YAAA;;;;GAAA,GAOD;qCAAS,SAAA,EAAW;gBAClB,IAAM,OAAO,IAAA,CAAK,IAAA;gBAClB,IAAM,SAAS,IAAA;gBAEf,IAAM,UAAU,KAAK,KAAA,CAAM,SAAS,CAAA;gBAEpC,IAAM,cAAc,OAAO,gBAAA,CAAiB,SAAS;gBAErD,IAAM,eAAe,CAAE,CAAA;gBACvB,IAAM,cAAc,QAAQ,QAAA,IAAY,CAAE,CAAA;gBAE1C,IAAA,IAAS,IAAI,GAAG,KAAK,YAAY,MAAA,EAAQ,IAAI,IAAI,IAAK;oBACpD,aAAa,IAAA,CAAK,OAAO,aAAA,CAAc,QAAQ,WAAA,CAAY,CAAC,CAAC,CAAC;gBAC/D;gBAED,IAAM,kBACJ,QAAQ,IAAA,KAAS,KAAA,IAAY,QAAQ,OAAA,CAAQ,IAAI,IAAI,OAAO,aAAA,CAAc,QAAQ,QAAQ,IAAI;gBAEhG,OAAO,QAAQ,GAAA,CAAI;oBAAC;oBAAa,QAAQ,GAAA,CAAI,YAAY;oBAAG,eAAe;iBAAC,EAAE,IAAA,CAAK,SAAU,OAAA,EAAS;oBACpG,IAAM,OAAO,OAAA,CAAQ,CAAC,CAAA;oBACtB,IAAM,WAAW,OAAA,CAAQ,CAAC,CAAA;oBAC1B,IAAM,WAAW,OAAA,CAAQ,CAAC,CAAA;oBAE1B,IAAI,aAAa,MAAM;wBAGrB,KAAK,QAAA,CAAS,SAAU,IAAA,EAAM;4BAC5B,IAAI,CAAC,KAAK,aAAA,EAAe;4BAEzB,KAAK,IAAA,CAAK,UAAU,eAAe;wBAC7C,CAAS;oBACF;oBAED,IAAA,IAAS,IAAI,GAAG,KAAK,SAAS,MAAA,EAAQ,IAAI,IAAI,IAAK;wBACjD,KAAK,GAAA,CAAI,QAAA,CAAS,CAAC,CAAC;oBACrB;oBAED,OAAO;gBACb,CAAK;YACF;;;YAAA,4CAAA;YAAA,6EAAA;iBAID;6CAAiB,SAAA,EAAW;gBAC1B,IAAM,OAAO,IAAA,CAAK,IAAA;gBAClB,IAAM,aAAa,IAAA,CAAK,UAAA;gBACxB,IAAM,SAAS,IAAA;gBAKf,IAAI,IAAA,CAAK,SAAA,CAAU,SAAS,CAAA,KAAM,KAAA,GAAW;oBAC3C,OAAO,IAAA,CAAK,SAAA,CAAU,SAAS,CAAA;gBAChC;gBAED,IAAM,UAAU,KAAK,KAAA,CAAM,SAAS,CAAA;gBAGpC,IAAM,WAAW,QAAQ,IAAA,GAAO,OAAO,gBAAA,CAAiB,QAAQ,IAAI,IAAI;gBAExE,IAAM,UAAU,CAAE,CAAA;gBAElB,IAAM,cAAc,OAAO,UAAA,CAAW,SAAU,GAAA,EAAK;oBACnD,OAAO,IAAI,cAAA,IAAkB,IAAI,cAAA,CAAe,SAAS;gBAC/D,CAAK;gBAED,IAAI,aAAa;oBACf,QAAQ,IAAA,CAAK,WAAW;gBACzB;gBAED,IAAI,QAAQ,MAAA,KAAW,KAAA,GAAW;oBAChC,QAAQ,IAAA,CACN,OAAO,aAAA,CAAc,UAAU,QAAQ,MAAM,EAAE,IAAA,CAAK,SAAU,MAAA,EAAQ;wBACpE,OAAO,OAAO,WAAA,CAAY,OAAO,WAAA,EAAa,QAAQ,MAAA,EAAQ,MAAM;oBAC9E,CAAS;gBAEJ;gBAED,OACG,UAAA,CAAW,SAAU,GAAA,EAAK;oBACzB,OAAO,IAAI,oBAAA,IAAwB,IAAI,oBAAA,CAAqB,SAAS;gBAC7E,CAAO,EACA,OAAA,CAAQ,SAAU,OAAA,EAAS;oBAC1B,QAAQ,IAAA,CAAK,OAAO;gBAC5B,CAAO;gBAEH,IAAA,CAAK,SAAA,CAAU,SAAS,CAAA,GAAI,QAAQ,GAAA,CAAI,OAAO,EAAE,IAAA,CAAK,SAAU,OAAA,EAAS;oBACvE,IAAI;oBAGJ,IAAI,QAAQ,MAAA,KAAW,MAAM;wBAC3B,OAAO,IAAI,0JAAA,CAAM;oBACzB,OAAA,IAAiB,QAAQ,MAAA,GAAS,GAAG;wBAC7B,OAAO,IAAI,2JAAA,CAAO;oBAC1B,OAAA,IAAiB,QAAQ,MAAA,KAAW,GAAG;wBAC/B,OAAO,OAAA,CAAQ,CAAC,CAAA;oBACxB,OAAa;wBACL,OAAO,IAAI,8JAAA,CAAU;oBACtB;oBAED,IAAI,SAAS,OAAA,CAAQ,CAAC,CAAA,EAAG;wBACvB,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;4BAChD,KAAK,GAAA,CAAI,OAAA,CAAQ,CAAC,CAAC;wBACpB;oBACF;oBAED,IAAI,QAAQ,IAAA,EAAM;wBAChB,KAAK,QAAA,CAAS,IAAA,GAAO,QAAQ,IAAA;wBAC7B,KAAK,IAAA,GAAO;oBACb;oBAED,uBAAuB,MAAM,OAAO;oBAEpC,IAAI,QAAQ,UAAA,EAAY,+BAA+B,YAAY,MAAM,OAAO;oBAEhF,IAAI,QAAQ,MAAA,KAAW,KAAA,GAAW;wBAChC,IAAM,SAAS,IAAI,6JAAA,CAAS;wBAC5B,OAAO,SAAA,CAAU,QAAQ,MAAM;wBAC/B,KAAK,YAAA,CAAa,MAAM;oBAChC,OAAa;wBACL,IAAI,QAAQ,WAAA,KAAgB,KAAA,GAAW;4BACrC,KAAK,QAAA,CAAS,SAAA,CAAU,QAAQ,WAAW;wBAC5C;wBAED,IAAI,QAAQ,QAAA,KAAa,KAAA,GAAW;4BAClC,KAAK,UAAA,CAAW,SAAA,CAAU,QAAQ,QAAQ;wBAC3C;wBAED,IAAI,QAAQ,KAAA,KAAU,KAAA,GAAW;4BAC/B,KAAK,KAAA,CAAM,SAAA,CAAU,QAAQ,KAAK;wBACnC;oBACF;oBAED,IAAI,CAAC,OAAO,YAAA,CAAa,GAAA,CAAI,IAAI,GAAG;wBAClC,OAAO,YAAA,CAAa,GAAA,CAAI,MAAM,CAAA,CAAE;oBACjC;oBAED,OAAO,YAAA,CAAa,GAAA,CAAI,IAAI,EAAE,KAAA,GAAQ;oBAEtC,OAAO;gBACb,CAAK;gBAED,OAAO,IAAA,CAAK,SAAA,CAAU,SAAS,CAAA;YAChC;;;YAAA;;;;GAAA;4BAOD,UAAU,UAAA,EAAY;gBACpB,IAAM,aAAa,IAAA,CAAK,UAAA;gBACxB,IAAM,WAAW,IAAA,CAAK,IAAA,CAAK,MAAA,CAAO,UAAU,CAAA;gBAC5C,IAAM,SAAS,IAAA;gBAIf,IAAM,QAAQ,IAAI,2JAAA,CAAO;gBACzB,IAAI,SAAS,IAAA,EAAM,MAAM,IAAA,GAAO,OAAO,gBAAA,CAAiB,SAAS,IAAI;gBAErE,uBAAuB,OAAO,QAAQ;gBAEtC,IAAI,SAAS,UAAA,EAAY,+BAA+B,YAAY,OAAO,QAAQ;gBAEnF,IAAM,UAAU,SAAS,KAAA,IAAS,CAAE,CAAA;gBAEpC,IAAM,UAAU,CAAE,CAAA;gBAElB,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;oBAChD,QAAQ,IAAA,CAAK,OAAO,aAAA,CAAc,QAAQ,OAAA,CAAQ,CAAC,CAAC,CAAC;gBACtD;gBAED,OAAO,QAAQ,GAAA,CAAI,OAAO,EAAE,IAAA,CAAK,SAAU,KAAA,EAAO;oBAChD,IAAA,IAAS,IAAI,GAAG,KAAK,MAAM,MAAA,EAAQ,IAAI,IAAI,IAAK;wBAC9C,MAAM,GAAA,CAAI,KAAA,CAAM,CAAC,CAAC;oBACnB;oBAID,IAAM,qBAAqB,SAAC,SAAS;wBACnC,IAAM,sBAAsB,aAAA,GAAA,IAAI,IAAK;4BAErC,kCAAA,2BAAA;;4BAAA,QAAA,MAAW,MAAgB,OAAO,YAAA,qBAAlC,SAAA,6BAAA,QAAA,yBAAA,iCAAgD;gCAAhD,2LAAA,iBAAY,sBAAK,KAAK;gCACpB,QAAI,gKAAA,KAAe,8JAAA,KAAY,IAAA,8JAAe,oKAAA,GAAS;oCACrD,oBAAoB,GAAA,CAAI,KAAK,KAAK;gCACnC;4BACF;;4BAJD;4BAAA;;;qCAAA,6BAAA;oCAAA;;;oCAAA;0CAAA;;;;wBAMA,KAAK,QAAA,CAAS,SAACC,UAAS;4BACtB,IAAM,WAAW,OAAO,YAAA,CAAa,GAAA,CAAIA,KAAI;4BAE7C,IAAI,YAAY,MAAM;gCACpB,oBAAoB,GAAA,CAAIA,OAAM,QAAQ;4BACvC;wBACX,CAAS;wBAED,OAAO;oBACR;oBAED,OAAO,YAAA,GAAe,mBAAmB,KAAK;oBAE9C,OAAO;gBACb,CAAK;YACF;;;;4BAED,uBAAuB,IAAA,EAAM,aAAA,EAAe,cAAA,EAAgB,OAAA,EAAS,MAAA,EAAQ;gBAC3E,IAAM,SAAS,CAAE,CAAA;gBAEjB,IAAM,aAAa,KAAK,IAAA,GAAO,KAAK,IAAA,GAAO,KAAK,IAAA;gBAChD,IAAM,cAAc,CAAE,CAAA;gBAEtB,IAAI,eAAA,CAAgB,OAAO,IAAI,CAAA,KAAM,gBAAgB,OAAA,EAAS;oBAC5D,KAAK,QAAA,CAAS,SAAU,MAAA,EAAQ;wBAC9B,IAAI,OAAO,qBAAA,EAAuB;4BAChC,YAAY,IAAA,CAAK,OAAO,IAAA,GAAO,OAAO,IAAA,GAAO,OAAO,IAAI;wBACzD;oBACT,CAAO;gBACP,OAAW;oBACL,YAAY,IAAA,CAAK,UAAU;gBAC5B;gBAED,IAAI;gBAEJ,OAAQ,eAAA,CAAgB,OAAO,IAAI,CAAA,EAAC;oBAClC,KAAK,gBAAgB,OAAA;wBACnB,qBAAqB,yKAAA;wBACrB;oBAEF,KAAK,gBAAgB,QAAA;wBACnB,qBAAqB,6KAAA;wBACrB;oBAEF,KAAK,gBAAgB,QAAA;oBACrB,KAAK,gBAAgB,KAAA;wBACnB,qBAAqB,yKAAA;wBACrB;oBAEF;wBACE,OAAQ,eAAe,QAAA,EAAQ;4BAC7B,KAAK;gCACH,qBAAqB,yKAAA;gCACrB;4BACF,KAAK;4BACL,KAAK;4BACL;gCACE,qBAAqB,yKAAA;gCACrB;wBACH;wBAED;gBACH;gBAED,IAAM,gBAAgB,QAAQ,aAAA,KAAkB,KAAA,IAAY,aAAA,CAAc,QAAQ,aAAa,CAAA,GAAI,uKAAA;gBAEnG,IAAM,cAAc,IAAA,CAAK,qBAAA,CAAsB,cAAc;gBAE7D,IAAA,IAAS,IAAI,GAAG,KAAK,YAAY,MAAA,EAAQ,IAAI,IAAI,IAAK;oBACpD,IAAM,QAAQ,IAAI,mBAChB,WAAA,CAAY,CAAC,CAAA,GAAI,MAAM,eAAA,CAAgB,OAAO,IAAI,CAAA,EAClD,cAAc,KAAA,EACd,aACA;oBAIF,IAAI,QAAQ,aAAA,KAAkB,eAAe;wBAC3C,IAAA,CAAK,kCAAA,CAAmC,KAAK;oBAC9C;oBAED,OAAO,IAAA,CAAK,KAAK;gBAClB;gBAED,OAAO;YACR;;;;4BAED,sBAAsB,QAAA,EAAU;gBAC9B,IAAI,cAAc,SAAS,KAAA;gBAE3B,IAAI,SAAS,UAAA,EAAY;oBACvB,IAAM,QAAQ,4BAA4B,YAAY,WAAW;oBACjE,IAAM,SAAS,IAAI,aAAa,YAAY,MAAM;oBAElD,IAAA,IAAS,IAAI,GAAG,KAAK,YAAY,MAAA,EAAQ,IAAI,IAAI,IAAK;wBACpD,MAAA,CAAO,CAAC,CAAA,GAAI,WAAA,CAAY,CAAC,CAAA,GAAI;oBAC9B;oBAED,cAAc;gBACf;gBAED,OAAO;YACR;;;;4BAED,mCAAmC,KAAA,EAAO;gBACxC,MAAM,iBAAA,GAAoB,SAAS,wCAAwC,MAAA,EAAQ;oBAKjF,IAAM,kBACJ,IAAA,8JAAgB,MAAhB,+KAAgB,IAA0B,uCAAuC;oBAEnF,OAAO,IAAI,gBAAgB,IAAA,CAAK,KAAA,EAAO,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,YAAA,CAAY,IAAK,GAAG,MAAM;gBACpF;gBAGD,MAAM,iBAAA,CAAkB,yCAAA,GAA4C;YACrE;;;WA7jDG,WAAW;;AAqkDjB,SAAS,cAAc,QAAA,EAAU,YAAA,EAAc,MAAA,EAAQ;IACrD,IAAM,aAAa,aAAa,UAAA;IAEhC,IAAM,MAAM,IAAI,0JAAA,CAAM;IAEtB,IAAI,WAAW,QAAA,KAAa,KAAA,GAAW;QACrC,IAAM,WAAW,OAAO,IAAA,CAAK,SAAA,CAAU,WAAW,QAAQ,CAAA;QAE1D,IAAM,MAAM,SAAS,GAAA;QACrB,IAAM,MAAM,SAAS,GAAA;QAIrB,IAAI,QAAQ,KAAA,KAAa,QAAQ,KAAA,GAAW;YAC1C,IAAI,GAAA,CAAI,IAAI,6JAAA,CAAQ,GAAA,CAAI,CAAC,CAAA,EAAG,GAAA,CAAI,CAAC,CAAA,EAAG,GAAA,CAAI,CAAC,CAAC,GAAG,IAAI,6JAAA,CAAQ,GAAA,CAAI,CAAC,CAAA,EAAG,GAAA,CAAI,CAAC,CAAA,EAAG,GAAA,CAAI,CAAC,CAAC,CAAC;YAEhF,IAAI,SAAS,UAAA,EAAY;gBACvB,IAAM,WAAW,4BAA4B,qBAAA,CAAsB,SAAS,aAAa,CAAC;gBAC1F,IAAI,GAAA,CAAI,cAAA,CAAe,QAAQ;gBAC/B,IAAI,GAAA,CAAI,cAAA,CAAe,QAAQ;YAChC;QACP,OAAW;YACL,QAAQ,IAAA,CAAK,qEAAqE;YAElF;QACD;IACL,OAAS;QACL;IACD;IAED,IAAM,UAAU,aAAa,OAAA;IAE7B,IAAI,YAAY,KAAA,GAAW;QACzB,IAAM,kBAAkB,IAAI,6JAAA,CAAS;QACrC,IAAM,SAAS,IAAI,6JAAA,CAAS;QAE5B,IAAA,IAAS,IAAI,GAAG,KAAK,QAAQ,MAAA,EAAQ,IAAI,IAAI,IAAK;YAChD,IAAM,SAAS,OAAA,CAAQ,CAAC,CAAA;YAExB,IAAI,OAAO,QAAA,KAAa,KAAA,GAAW;gBACjC,IAAM,YAAW,OAAO,IAAA,CAAK,SAAA,CAAU,OAAO,QAAQ,CAAA;gBACtD,IAAM,OAAM,UAAS,GAAA;gBACrB,IAAM,OAAM,UAAS,GAAA;gBAIrB,IAAI,SAAQ,KAAA,KAAa,SAAQ,KAAA,GAAW;oBAE1C,OAAO,IAAA,CAAK,KAAK,GAAA,CAAI,KAAK,GAAA,CAAI,IAAA,CAAI,CAAC,CAAC,GAAG,KAAK,GAAA,CAAI,IAAA,CAAI,CAAC,CAAC,CAAC,CAAC;oBACxD,OAAO,IAAA,CAAK,KAAK,GAAA,CAAI,KAAK,GAAA,CAAI,IAAA,CAAI,CAAC,CAAC,GAAG,KAAK,GAAA,CAAI,IAAA,CAAI,CAAC,CAAC,CAAC,CAAC;oBACxD,OAAO,IAAA,CAAK,KAAK,GAAA,CAAI,KAAK,GAAA,CAAI,IAAA,CAAI,CAAC,CAAC,GAAG,KAAK,GAAA,CAAI,IAAA,CAAI,CAAC,CAAC,CAAC,CAAC;oBAExD,IAAI,UAAS,UAAA,EAAY;wBACvB,IAAM,YAAW,4BAA4B,qBAAA,CAAsB,UAAS,aAAa,CAAC;wBAC1F,OAAO,cAAA,CAAe,QAAQ;oBAC/B;oBAMD,gBAAgB,GAAA,CAAI,MAAM;gBACpC,OAAe;oBACL,QAAQ,IAAA,CAAK,qEAAqE;gBACnF;YACF;QACF;QAGD,IAAI,cAAA,CAAe,eAAe;IACnC;IAED,SAAS,WAAA,GAAc;IAEvB,IAAM,SAAS,IAAI,4JAAA,CAAQ;IAE3B,IAAI,SAAA,CAAU,OAAO,MAAM;IAC3B,OAAO,MAAA,GAAS,IAAI,GAAA,CAAI,UAAA,CAAW,IAAI,GAAG,IAAI;IAE9C,SAAS,cAAA,GAAiB;AAC5B;AAQA,SAAS,uBAAuB,QAAA,EAAU,YAAA,EAAc,MAAA,EAAQ;IAC9D,IAAM,aAAa,aAAa,UAAA;IAEhC,IAAM,UAAU,CAAE,CAAA;IAElB,SAAS,wBAAwB,aAAA,EAAe,aAAA,EAAe;QAC7D,OAAO,OAAO,aAAA,CAAc,YAAY,aAAa,EAAE,IAAA,CAAK,SAAU,QAAA,EAAU;YAC9E,SAAS,YAAA,CAAa,eAAe,QAAQ;QACnD,CAAK;IACF;IAED,IAAA,IAAW,qBAAqB,WAAY;QAC1C,IAAM,qBAAqB,UAAA,CAAW,iBAAiB,CAAA,IAAK,kBAAkB,WAAA,CAAa;QAG3F,IAAI,sBAAsB,SAAS,UAAA,EAAY;QAE/C,QAAQ,IAAA,CAAK,wBAAwB,UAAA,CAAW,iBAAiB,CAAA,EAAG,kBAAkB,CAAC;IACxF;IAED,IAAI,aAAa,OAAA,KAAY,KAAA,KAAa,CAAC,SAAS,KAAA,EAAO;QACzD,IAAM,WAAW,OAAO,aAAA,CAAc,YAAY,aAAa,OAAO,EAAE,IAAA,CAAK,SAAUC,SAAAA,EAAU;YAC/F,SAAS,QAAA,CAASA,SAAQ;QAChC,CAAK;QAED,QAAQ,IAAA,CAAK,QAAQ;IACtB;IAED,uBAAuB,UAAU,YAAY;IAE7C,cAAc,UAAU,cAAc,MAAM;IAE5C,OAAO,QAAQ,GAAA,CAAI,OAAO,EAAE,IAAA,CAAK,WAAY;QAC3C,OAAO,aAAa,OAAA,KAAY,KAAA,IAAY,gBAAgB,UAAU,aAAa,OAAA,EAAS,MAAM,IAAI;IAC1G,CAAG;AACH"}},
    {"offset": {"line": 6239, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/DRACOLoader.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/loaders/DRACOLoader.js"],"sourcesContent":["import { BufferAttribute, BufferGeometry, FileLoader, Loader } from 'three'\n\nconst _taskCache = new WeakMap()\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.decoderPath = ''\n    this.decoderConfig = {}\n    this.decoderBinary = null\n    this.decoderPending = null\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD',\n    }\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array',\n    }\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path\n\n    return this\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false,\n        }\n\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs,\n    }\n\n    this.decodeGeometry(buffer, taskConfig).then(callback)\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute]\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name\n      }\n    }\n\n    //\n\n    const taskKey = JSON.stringify(taskConfig)\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer)\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n            'settings. Buffer has already been transferred.',\n        )\n      }\n    }\n\n    //\n\n    let worker\n    const taskID = this.workerNextTaskID++\n    const taskCost = buffer.byteLength\n\n    // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n    const geometryPending = this._getWorker(taskID, taskCost)\n      .then((_worker) => {\n        worker = _worker\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'decode', id: taskID, taskConfig, buffer }, [buffer])\n\n          // this.debug();\n        })\n      })\n      .then((message) => this._createGeometry(message.geometry))\n\n    // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    geometryPending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          this._releaseTask(worker, taskID)\n\n          // this.debug();\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending,\n    })\n\n    return geometryPending\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry()\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1))\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i]\n      const name = attribute.name\n      const array = attribute.array\n      const itemSize = attribute.itemSize\n\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize))\n    }\n\n    return geometry\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.decoderPath)\n    loader.setResponseType(responseType)\n    loader.setWithCredentials(this.withCredentials)\n\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject)\n    })\n  }\n\n  preload() {\n    this._initDecoder()\n\n    return this\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending\n\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js'\n    const librariesPending = []\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'))\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'))\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0]\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1]\n      }\n\n      const fn = DRACOWorker.toString()\n\n      const body = [\n        '/* draco decoder */',\n        jsContent,\n        '',\n        '/* worker */',\n        fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n      ].join('\\n')\n\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n    })\n\n    return this.decoderPending\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskCosts = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({ type: 'init', decoderConfig: this.decoderConfig })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n      worker._taskCosts[taskID] = taskCost\n      worker._taskLoad += taskCost\n      return worker\n    })\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID]\n    delete worker._callbacks[taskID]\n    delete worker._taskCosts[taskID]\n  }\n\n  debug() {\n    console.log(\n      'Task load: ',\n      this.workerPool.map((worker) => worker._taskLoad),\n    )\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n  let decoderConfig\n  let decoderPending\n\n  onmessage = function (e) {\n    const message = e.data\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig\n        decoderPending = new Promise(function (resolve /*, reject*/) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({ draco: draco })\n          }\n\n          DracoDecoderModule(decoderConfig)\n        })\n        break\n\n      case 'decode':\n        const buffer = message.buffer\n        const taskConfig = message.taskConfig\n        decoderPending.then((module) => {\n          const draco = module.draco\n          const decoder = new draco.Decoder()\n          const decoderBuffer = new draco.DecoderBuffer()\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength)\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig)\n\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer)\n\n            if (geometry.index) buffers.push(geometry.index.array.buffer)\n\n            self.postMessage({ type: 'decode', id: message.id, geometry }, buffers)\n          } catch (error) {\n            console.error(error)\n\n            self.postMessage({ type: 'error', id: message.id, error: error.message })\n          } finally {\n            draco.destroy(decoderBuffer)\n            draco.destroy(decoder)\n          }\n        })\n        break\n    }\n  }\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs\n    const attributeTypes = taskConfig.attributeTypes\n\n    let dracoGeometry\n    let decodingStatus\n\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer)\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh()\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry)\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud()\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry)\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.')\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg())\n    }\n\n    const geometry = { index: null, attributes: [] }\n\n    // Gather all vertex attributes.\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]]\n\n      let attribute\n      let attributeID\n\n      // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName]\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID)\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]])\n\n        if (attributeID === -1) continue\n\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID)\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute))\n    }\n\n    // Add index.\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry)\n    }\n\n    draco.destroy(dracoGeometry)\n\n    return geometry\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces()\n    const numIndices = numFaces * 3\n    const byteLength = numIndices * 4\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr)\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice()\n    draco._free(ptr)\n\n    return { array: index, itemSize: 1 }\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components()\n    const numPoints = dracoGeometry.num_points()\n    const numValues = numPoints * numComponents\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT\n    const dataType = getDracoDataType(draco, attributeType)\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr)\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice()\n    draco._free(ptr)\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents,\n    }\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32\n      case Int8Array:\n        return draco.DT_INT8\n      case Int16Array:\n        return draco.DT_INT16\n      case Int32Array:\n        return draco.DT_INT32\n      case Uint8Array:\n        return draco.DT_UINT8\n      case Uint16Array:\n        return draco.DT_UINT16\n      case Uint32Array:\n        return draco.DT_UINT32\n    }\n  }\n}\n\nexport { DRACOLoader }\n"],"names":["worker"],"mappings":"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"}},
    {"offset": {"line": 6679, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/libs/MeshoptDecoder.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/libs/MeshoptDecoder.ts"],"sourcesContent":["// This file is part of meshoptimizer library and is distributed under the terms of MIT License.\n// Copyright (C) 2016-2020, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)\n\ntype API = {\n  ready: Promise<void>\n  supported: boolean\n  decodeVertexBuffer: (target: Uint8Array, count: number, size: number, source: Uint8Array, filter?: string) => void\n  decodeIndexBuffer: (target: Uint8Array, count: number, size: number, source: Uint8Array) => void\n  decodeIndexSequence: (target: Uint8Array, count: number, size: number, source: Uint8Array) => void\n  decodeGltfBuffer: (\n    target: Uint8Array,\n    count: number,\n    size: number,\n    source: Uint8Array,\n    mode: string,\n    filter?: string,\n  ) => void\n}\n\nlet generated: API\n\nconst MeshoptDecoder = () => {\n  if (generated) return generated\n\n  // Built with clang version 11.0.0 (https://github.com/llvm/llvm-project.git 0160ad802e899c2922bc9b29564080c22eb0908c)\n  // Built from meshoptimizer 0.14\n  const wasm_base =\n    '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'\n  const wasm_simd =\n    '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'\n\n  // Uses bulk-memory and simd extensions\n  const detector = new Uint8Array([\n    0,\n    97,\n    115,\n    109,\n    1,\n    0,\n    0,\n    0,\n    1,\n    4,\n    1,\n    96,\n    0,\n    0,\n    3,\n    3,\n    2,\n    0,\n    0,\n    5,\n    3,\n    1,\n    0,\n    1,\n    12,\n    1,\n    0,\n    10,\n    22,\n    2,\n    12,\n    0,\n    65,\n    0,\n    65,\n    0,\n    65,\n    0,\n    252,\n    10,\n    0,\n    0,\n    11,\n    7,\n    0,\n    65,\n    0,\n    253,\n    15,\n    26,\n    11,\n  ])\n\n  // Used to unpack wasm\n  const wasmpack = new Uint8Array([\n    32,\n    0,\n    65,\n    253,\n    3,\n    1,\n    2,\n    34,\n    4,\n    106,\n    6,\n    5,\n    11,\n    8,\n    7,\n    20,\n    13,\n    33,\n    12,\n    16,\n    128,\n    9,\n    116,\n    64,\n    19,\n    113,\n    127,\n    15,\n    10,\n    21,\n    22,\n    14,\n    255,\n    66,\n    24,\n    54,\n    136,\n    107,\n    18,\n    23,\n    192,\n    26,\n    114,\n    118,\n    132,\n    17,\n    77,\n    101,\n    130,\n    144,\n    27,\n    87,\n    131,\n    44,\n    45,\n    74,\n    156,\n    154,\n    70,\n    167,\n  ])\n\n  if (typeof WebAssembly !== 'object') {\n    // This module requires WebAssembly to function\n    return {\n      supported: false,\n    }\n  }\n\n  let wasm = wasm_base\n\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd\n  }\n\n  let instance: any // WebAssembly.Instance\n\n  const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result) => {\n    instance = result.instance\n    instance.exports.__wasm_call_ctors()\n  })\n\n  function unpack(data: string) {\n    const result = new Uint8Array(data.length)\n    for (let i = 0; i < data.length; ++i) {\n      const ch = data.charCodeAt(i)\n      result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62\n    }\n    let write = 0\n    for (let i = 0; i < data.length; ++i) {\n      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i]\n    }\n    return result.buffer.slice(0, write)\n  }\n\n  function decode(\n    fun: Function,\n    target: Uint8Array,\n    count: number,\n    size: number,\n    source: Uint8Array,\n    filter?: Function,\n  ) {\n    const sbrk = instance.exports.sbrk\n    const count4 = (count + 3) & ~3 // pad for SIMD filter\n    const tp = sbrk(count4 * size)\n    const sp = sbrk(source.length)\n    const heap = new Uint8Array(instance.exports.memory.buffer)\n    heap.set(source, sp)\n    const res = fun(tp, count, size, sp, source.length)\n    if (res === 0 && filter) {\n      filter(tp, count4, size)\n    }\n    target.set(heap.subarray(tp, tp + count * size))\n    sbrk(tp - sbrk(0))\n    if (res !== 0) {\n      throw new Error(`Malformed buffer data: ${res}`)\n    }\n  }\n\n  const filters = {\n    // legacy index-based enums for glTF\n    0: '',\n    1: 'meshopt_decodeFilterOct',\n    2: 'meshopt_decodeFilterQuat',\n    3: 'meshopt_decodeFilterExp',\n    // string-based enums for glTF\n    NONE: '',\n    OCTAHEDRAL: 'meshopt_decodeFilterOct',\n    QUATERNION: 'meshopt_decodeFilterQuat',\n    EXPONENTIAL: 'meshopt_decodeFilterExp',\n  }\n\n  const decoders = {\n    // legacy index-based enums for glTF\n    0: 'meshopt_decodeVertexBuffer',\n    1: 'meshopt_decodeIndexBuffer',\n    2: 'meshopt_decodeIndexSequence',\n    // string-based enums for glTF\n    ATTRIBUTES: 'meshopt_decodeVertexBuffer',\n    TRIANGLES: 'meshopt_decodeIndexBuffer',\n    INDICES: 'meshopt_decodeIndexSequence',\n  }\n\n  generated = {\n    ready: promise,\n    supported: true,\n    decodeVertexBuffer(target, count, size, source, filter) {\n      decode(\n        instance.exports.meshopt_decodeVertexBuffer,\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter as keyof typeof filters]],\n      )\n    },\n    decodeIndexBuffer(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source)\n    },\n    decodeIndexSequence(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source)\n    },\n    decodeGltfBuffer(target, count, size, source, mode, filter) {\n      decode(\n        instance.exports[decoders[mode as keyof typeof decoders]],\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter as keyof typeof filters]],\n      )\n    },\n  }\n\n  return generated\n}\n\nexport { MeshoptDecoder }\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6894, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/utils/SkeletonUtils.js","sources":["file:///Applications/MAMP/htdocs/35-SAT/SAT/node_modules/src/utils/SkeletonUtils.js"],"sourcesContent":["import {\n  AnimationClip,\n  AnimationMixer,\n  Matrix4,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  SkeletonHelper,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\n\nfunction retarget(target, source, options = {}) {\n  const pos = new Vector3(),\n    quat = new Quaternion(),\n    scale = new Vector3(),\n    bindBoneMatrix = new Matrix4(),\n    relativeMatrix = new Matrix4(),\n    globalMatrix = new Matrix4()\n\n  options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true\n  options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true\n  options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false\n  options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false\n  options.hip = options.hip !== undefined ? options.hip : 'hip'\n  options.names = options.names || {}\n\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target)\n\n  let bindBones, bone, name, boneTo, bonesPosition\n\n  // reset bones\n\n  if (target.isObject3D) {\n    target.skeleton.pose()\n  } else {\n    options.useTargetMatrix = true\n    options.preserveMatrix = false\n  }\n\n  if (options.preservePosition) {\n    bonesPosition = []\n\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone())\n    }\n  }\n\n  if (options.preserveMatrix) {\n    // reset matrix\n\n    target.updateMatrixWorld()\n\n    target.matrixWorld.identity()\n\n    // reset children matrix\n\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true)\n    }\n  }\n\n  if (options.offsets) {\n    bindBones = []\n\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i]\n      name = options.names[bone.name] || bone.name\n\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name])\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale)\n\n        bone.updateMatrixWorld()\n      }\n\n      bindBones.push(bone.matrixWorld.clone())\n    }\n  }\n\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i]\n    name = options.names[bone.name] || bone.name\n\n    boneTo = getBoneByName(name, sourceBones)\n\n    globalMatrix.copy(bone.matrixWorld)\n\n    if (boneTo) {\n      boneTo.updateMatrixWorld()\n\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld)\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert()\n        relativeMatrix.multiply(boneTo.matrixWorld)\n      }\n\n      // ignore scale to extract rotation\n\n      scale.setFromMatrixScale(relativeMatrix)\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z))\n\n      // apply to global matrix\n\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix))\n\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone),\n          wBindMatrix = bindBones\n            ? bindBones[boneIndex]\n            : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert()\n\n        globalMatrix.multiply(wBindMatrix)\n      }\n\n      globalMatrix.copyPosition(relativeMatrix)\n    }\n\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert()\n      bone.matrix.multiply(globalMatrix)\n    } else {\n      bone.matrix.copy(globalMatrix)\n    }\n\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0))\n    }\n\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale)\n\n    bone.updateMatrixWorld()\n  }\n\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i]\n      name = options.names[bone.name] || bone.name\n\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i])\n      }\n    }\n  }\n\n  if (options.preserveMatrix) {\n    // restore matrix\n\n    target.updateMatrixWorld(true)\n  }\n}\n\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false\n  options.fps = options.fps !== undefined ? options.fps : 30\n  options.names = options.names || []\n\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source)\n  }\n\n  const numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n    delta = 1 / options.fps,\n    convertedTracks = [],\n    mixer = new AnimationMixer(source),\n    bones = getBones(target.skeleton),\n    boneDatas = []\n  let positionOffset, bone, boneTo, boneData, name\n\n  mixer.clipAction(clip).play()\n  mixer.update(0)\n\n  source.updateMatrixWorld()\n\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta\n\n    retarget(target, source, options)\n\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name\n\n      boneTo = getBoneByName(name, source.skeleton)\n\n      if (boneTo) {\n        bone = bones[j]\n        boneData = boneDatas[j] = boneDatas[j] || { bone: bone }\n\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3),\n            }\n          }\n\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone()\n            }\n\n            bone.position.sub(positionOffset)\n          }\n\n          boneData.pos.times[i] = time\n\n          bone.position.toArray(boneData.pos.values, i * 3)\n        }\n\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4),\n          }\n        }\n\n        boneData.quat.times[i] = time\n\n        bone.quaternion.toArray(boneData.quat.values, i * 4)\n      }\n    }\n\n    mixer.update(delta)\n\n    source.updateMatrixWorld()\n  }\n\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i]\n\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(\n          new VectorKeyframeTrack(\n            '.bones[' + boneData.bone.name + '].position',\n            boneData.pos.times,\n            boneData.pos.values,\n          ),\n        )\n      }\n\n      convertedTracks.push(\n        new QuaternionKeyframeTrack(\n          '.bones[' + boneData.bone.name + '].quaternion',\n          boneData.quat.times,\n          boneData.quat.values,\n        ),\n      )\n    }\n  }\n\n  mixer.uncacheAction(clip)\n\n  return new AnimationClip(clip.name, -1, convertedTracks)\n}\n\nfunction clone(source) {\n  const sourceLookup = new Map()\n  const cloneLookup = new Map()\n\n  const clone = source.clone()\n\n  parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode)\n    cloneLookup.set(sourceNode, clonedNode)\n  })\n\n  clone.traverse(function (node) {\n    if (!node.isSkinnedMesh) return\n\n    const clonedMesh = node\n    const sourceMesh = sourceLookup.get(node)\n    const sourceBones = sourceMesh.skeleton.bones\n\n    clonedMesh.skeleton = sourceMesh.skeleton.clone()\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix)\n\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone)\n    })\n\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix)\n  })\n\n  return clone\n}\n\n// internal helper\n\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name) return bones[i]\n  }\n}\n\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones\n}\n\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0])\n  source.skeleton = skeleton\n\n  return source\n}\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b)\n\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback)\n  }\n}\n\nexport const SkeletonUtils = { retarget, retargetClip, clone }\n"],"names":["clone"],"mappings":"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"}}]
}