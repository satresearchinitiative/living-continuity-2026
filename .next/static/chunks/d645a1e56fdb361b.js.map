{"version":3,"sources":["turbopack:///[project]/node_modules/next/src/client/components/router-reducer/compute-changed-path.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/handle-mutable.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/ppr-navigations.ts","turbopack:///[project]/node_modules/next/src/shared/lib/app-router-types.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache/types.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache/lru.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache/cache-map.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache/vary-path.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache/cache-key.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache/scheduler.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/parse-path.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/add-path-prefix.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/remove-trailing-slash.ts","turbopack:///[project]/node_modules/next/src/client/normalize-trailing-slash.ts","turbopack:///[project]/node_modules/next/src/client/add-base-path.ts","turbopack:///[project]/node_modules/next/src/client/components/app-router-utils.ts","turbopack:///[project]/node_modules/next/src/client/components/links.ts","turbopack:///[project]/node_modules/next/src/shared/lib/segment-cache/output-export-prefetch-encoding.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache/cache.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache/navigation.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/reducers/navigate-reducer.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/invalidate-cache-by-router-state.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/fill-cache-with-new-subtree-data.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/apply-flight-data.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/refetch-inactive-parallel-segments.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/apply-router-state-patch-to-tree.ts","turbopack:///[project]/node_modules/next/src/client/components/app-router-announcer.tsx","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/reducers/find-head-in-cache.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/path-has-prefix.ts","turbopack:///[project]/node_modules/next/src/client/has-base-path.ts","turbopack:///[project]/node_modules/next/src/client/remove-base-path.ts","turbopack:///[project]/node_modules/next/src/client/components/errors/graceful-degrade-boundary.tsx","turbopack:///[project]/node_modules/next/src/client/components/errors/root-error-boundary.tsx","turbopack:///[project]/node_modules/next/src/client/components/app-router.tsx","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/reducers/server-patch-reducer.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/reducers/restore-reducer.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/handle-segment-mismatch.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/reducers/refresh-reducer.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/reducers/hmr-refresh-reducer.ts","turbopack:///[project]/node_modules/next/src/client/assign-location.ts","turbopack:///[project]/node_modules/next/src/shared/lib/server-reference-info.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/reducers/server-action-reducer.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/router-reducer.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache/prefetch.ts","turbopack:///[project]/node_modules/next/src/client/components/app-router-instance.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n","import { computeChangedPath } from './compute-changed-path'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from './router-reducer-types'\n\nfunction isNotUndefined<T>(value: T): value is Exclude<T, undefined> {\n  return typeof value !== 'undefined'\n}\n\nexport function handleMutable(\n  state: ReadonlyReducerState,\n  mutable: Mutable\n): ReducerState {\n  // shouldScroll is true by default, can override to false.\n  const shouldScroll = mutable.shouldScroll ?? true\n\n  let previousNextUrl = state.previousNextUrl\n  let nextUrl = state.nextUrl\n\n  if (isNotUndefined(mutable.patchedTree)) {\n    // If we received a patched tree, we need to compute the changed path.\n    const changedPath = computeChangedPath(state.tree, mutable.patchedTree)\n    if (changedPath) {\n      // If the tree changed, we need to update the nextUrl\n      previousNextUrl = nextUrl\n      nextUrl = changedPath\n    } else if (!nextUrl) {\n      // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n      nextUrl = state.canonicalUrl\n    }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n  }\n\n  return {\n    // Set href.\n    canonicalUrl: mutable.canonicalUrl ?? state.canonicalUrl,\n    renderedSearch: mutable.renderedSearch ?? state.renderedSearch,\n    pushRef: {\n      pendingPush: isNotUndefined(mutable.pendingPush)\n        ? mutable.pendingPush\n        : state.pushRef.pendingPush,\n      mpaNavigation: isNotUndefined(mutable.mpaNavigation)\n        ? mutable.mpaNavigation\n        : state.pushRef.mpaNavigation,\n      preserveCustomHistoryState: isNotUndefined(\n        mutable.preserveCustomHistoryState\n      )\n        ? mutable.preserveCustomHistoryState\n        : state.pushRef.preserveCustomHistoryState,\n    },\n    // All navigation requires scroll and focus management to trigger.\n    focusAndScrollRef: {\n      apply: shouldScroll\n        ? isNotUndefined(mutable?.scrollableSegments)\n          ? true\n          : state.focusAndScrollRef.apply\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          false,\n      onlyHashChange: mutable.onlyHashChange || false,\n      hashFragment: shouldScroll\n        ? // Empty hash should trigger default behavior of scrolling layout into view.\n          // #top is handled in layout-router.\n          mutable.hashFragment && mutable.hashFragment !== ''\n          ? // Remove leading # and decode hash to make non-latin hashes work.\n            decodeURIComponent(mutable.hashFragment.slice(1))\n          : state.focusAndScrollRef.hashFragment\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          null,\n      segmentPaths: shouldScroll\n        ? (mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths)\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          [],\n    },\n    // Apply cache.\n    cache: mutable.cache ? mutable.cache : state.cache,\n    // Apply patched router state.\n    tree: isNotUndefined(mutable.patchedTree)\n      ? mutable.patchedTree\n      : state.tree,\n    nextUrl,\n    previousNextUrl: previousNextUrl,\n    debugInfo: mutable.collectedDebugInfo ?? null,\n  }\n}\n","import type { FlightRouterState } from '../../../shared/lib/app-router-types'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: FlightRouterState\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree[0]\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4]\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree[4]) {\n    return true\n  }\n  // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n  const currentTreeChild = Object.values(currentTree[1])[0]\n  const nextTreeChild = Object.values(nextTree[1])[0]\n  if (!currentTreeChild || !nextTreeChild) return true\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNode,\n  ChildSegmentMap,\n  ReadyCacheNode,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { FetchServerResponseResult } from './fetch-server-response'\nimport { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\nimport { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\ntype SPANavigationTask = {\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents. If\n  // `children` is null (i.e. if this is a terminal task node), then `node`\n  // represents a brand new Cache Node tree, which way or may not need to be\n  // filled with dynamic data from the server.\n  node: CacheNode | null\n  // The tree sent to the server during the dynamic request. This is the\n  // same as `route`, except with the `refetch` marker set on dynamic segments.\n  // If all the segments are static, then this will be null, and no server\n  // request is required.\n  dynamicRequestTree: FlightRouterState | null\n  children: Map<string, SPANavigationTask> | null\n}\n\n// A special type used to bail out and trigger a full-page navigation.\ntype MPANavigationTask = {\n  // MPA tasks are distinguised from SPA tasks by having a null `route`.\n  route: null\n  node: null\n  dynamicRequestTree: null\n  children: null\n}\n\nconst MPA_NAVIGATION_TASK: MPANavigationTask = {\n  route: null,\n  node: null,\n  dynamicRequestTree: null,\n  children: null,\n}\n\nexport type Task = SPANavigationTask | MPANavigationTask\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched — due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function startPPRNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task | null {\n  const segmentPath: Array<FlightSegmentPath> = []\n  return updateCacheNodeOnNavigation(\n    navigatedAt,\n    oldUrl,\n    oldCacheNode,\n    oldRouterState,\n    newRouterState,\n    false,\n    prefetchData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    segmentPath,\n    scrollableSegmentsResult\n  )\n}\n\nfunction updateCacheNodeOnNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  didFindRootLayout: boolean,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task | null {\n  // Diff the old and new trees to reuse the shared layouts.\n  const oldRouterStateChildren = oldRouterState[1]\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  if (!didFindRootLayout) {\n    // We're currently traversing the part of the tree that was also part of\n    // the previous route. If we discover a root layout, then we don't need to\n    // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n    const isRootLayout = newRouterState[4] === true\n    if (isRootLayout) {\n      // Found a matching root layout.\n      didFindRootLayout = true\n    }\n  }\n\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  const prefetchParallelRoutes = new Map(oldParallelRoutes)\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server — for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let needsDynamicRequest = false\n  // As we traverse the children, we'll construct a FlightRouterState that can\n  // be sent to the server to request the dynamic data. If it turns out that\n  // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the\n  // end), then this will be discarded.\n  // TODO: We can probably optimize the format of this data structure to only\n  // include paths that are dynamic. Instead of reusing the\n  // FlightRouterState type.\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentPathChild = segmentPath.concat([\n      parallelRouteKey,\n      newSegmentChild,\n    ])\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldSegmentChild =\n      oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    let taskChild: Task | null\n    if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n      // This is another kind of leaf segment — a default route.\n      //\n      // Default routes have special behavior. When there's no matching segment\n      // for a parallel route, Next.js preserves the currently active segment\n      // during a client navigation — but not for initial render. The server\n      // leaves it to the client to account for this. So we need to handle\n      // it here.\n      if (oldRouterStateChild !== undefined) {\n        // Reuse the existing Router State for this segment. We spawn a \"task\"\n        // just to keep track of the updated router state; unlike most, it's\n        // already fulfilled and won't be affected by the dynamic response.\n        taskChild = reuseActiveSegmentInDefaultSlot(oldUrl, oldRouterStateChild)\n      } else {\n        // There's no currently active segment. Switch to the \"create\" path.\n        taskChild = beginRenderingNewRouteTree(\n          navigatedAt,\n          oldRouterStateChild,\n          newRouterStateChild,\n          oldCacheNodeChild,\n          didFindRootLayout,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      }\n    } else if (\n      isSamePageNavigation &&\n      // Check if this is a page segment.\n      // TODO: We're not consistent about how we do this check. Some places\n      // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n      // check if there any any children, which is why I'm doing it here. We\n      // should probably encode an empty children set as `null` though. Either\n      // way, we should update all the checks to be consistent.\n      Object.keys(newRouterStateChild[1]).length === 0\n    ) {\n      // We special case navigations to the exact same URL as the current\n      // location. It's a common UI pattern for apps to refresh when you click a\n      // link to the current page. So when this happens, we refresh the dynamic\n      // data in the page segments.\n      //\n      // Note that this does not apply if the any part of the hash or search\n      // query has changed. This might feel a bit weird but it makes more sense\n      // when you consider that the way to trigger this behavior is to click\n      // the same link multiple times.\n      //\n      // TODO: We should probably refresh the *entire* route when this case\n      // occurs, not just the page segments. Essentially treating it the same as\n      // a refresh() triggered by an action, which is the more explicit way of\n      // modeling the UI pattern described above.\n      //\n      // Also note that this only refreshes the dynamic data, not static/\n      // cached data. If the page segment is fully static and prefetched, the\n      // request is skipped. (This is also how refresh() works.)\n      taskChild = beginRenderingNewRouteTree(\n        navigatedAt,\n        oldRouterStateChild,\n        newRouterStateChild,\n        oldCacheNodeChild,\n        didFindRootLayout,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newSegmentPathChild,\n        scrollableSegmentsResult\n      )\n    } else if (\n      oldRouterStateChild !== undefined &&\n      oldSegmentChild !== undefined &&\n      matchSegment(newSegmentChild, oldSegmentChild)\n    ) {\n      if (\n        oldCacheNodeChild !== undefined &&\n        oldRouterStateChild !== undefined\n      ) {\n        // This segment exists in both the old and new trees. Recursively update\n        // the children.\n        taskChild = updateCacheNodeOnNavigation(\n          navigatedAt,\n          oldUrl,\n          oldCacheNodeChild,\n          oldRouterStateChild,\n          newRouterStateChild,\n          didFindRootLayout,\n          prefetchDataChild,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          isSamePageNavigation,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      } else {\n        // There's no existing Cache Node for this segment. Switch to the\n        // \"create\" path.\n        taskChild = beginRenderingNewRouteTree(\n          navigatedAt,\n          oldRouterStateChild,\n          newRouterStateChild,\n          oldCacheNodeChild,\n          didFindRootLayout,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      }\n    } else {\n      // This is a new tree. Switch to the \"create\" path.\n      taskChild = beginRenderingNewRouteTree(\n        navigatedAt,\n        oldRouterStateChild,\n        newRouterStateChild,\n        oldCacheNodeChild,\n        didFindRootLayout,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newSegmentPathChild,\n        scrollableSegmentsResult\n      )\n    }\n\n    if (taskChild !== null) {\n      // Recursively propagate up the child tasks.\n\n      if (taskChild.route === null) {\n        // One of the child tasks discovered a change to the root layout.\n        // Immediately unwind from this recursive traversal.\n        return MPA_NAVIGATION_TASK\n      }\n\n      if (taskChildren === null) {\n        taskChildren = new Map()\n      }\n      taskChildren.set(parallelRouteKey, taskChild)\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n        prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n\n      // The child tree's route state may be different from the prefetched\n      // route sent by the server. We need to clone it as we traverse back up\n      // the tree.\n      const taskChildRoute = taskChild.route\n      patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        needsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n      }\n    } else {\n      // The child didn't change. We can use the prefetched router state.\n      patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild\n      dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild\n    }\n  }\n\n  if (taskChildren === null) {\n    // No new tasks were spawned.\n    return null\n  }\n\n  const newCacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc: oldCacheNode.rsc,\n    // We intentionally aren't updating the prefetchRsc field, since this node\n    // is already part of the current tree, because it would be weird for\n    // prefetch data to be newer than the final data. It probably won't ever be\n    // observable anyway, but it could happen if the segment is unmounted then\n    // mounted again, because LayoutRouter will momentarily switch to rendering\n    // prefetchRsc, via useDeferredValue.\n    prefetchRsc: oldCacheNode.prefetchRsc,\n    head: oldCacheNode.head,\n    prefetchHead: oldCacheNode.prefetchHead,\n    loading: oldCacheNode.loading,\n\n    // Everything is cloned except for the children, which we computed above.\n    parallelRoutes: prefetchParallelRoutes,\n\n    navigatedAt,\n  }\n\n  return {\n    // Return a cloned copy of the router state with updated children.\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: needsDynamicRequest\n      ? patchRouterStateWithNewChildren(\n          newRouterState,\n          dynamicRequestTreeChildren\n        )\n      : null,\n    children: taskChildren,\n  }\n}\n\nfunction beginRenderingNewRouteTree(\n  navigatedAt: number,\n  oldRouterState: FlightRouterState | void,\n  newRouterState: FlightRouterState,\n  existingCacheNode: CacheNode | void,\n  didFindRootLayout: boolean,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task {\n  if (!didFindRootLayout) {\n    // The route tree changed before we reached a layout. (The highest-level\n    // layout in a route tree is referred to as the \"root\" layout.) This could\n    // mean that we're navigating between two different root layouts. When this\n    // happens, we perform a full-page (MPA-style) navigation.\n    //\n    // However, the algorithm for deciding where to start rendering a route\n    // (i.e. the one performed in order to reach this function) is stricter\n    // than the one used to detect a change in the root layout. So just because\n    // we're re-rendering a segment outside of the root layout does not mean we\n    // should trigger a full-page navigation.\n    //\n    // Specifically, we handle dynamic parameters differently: two segments are\n    // considered the same even if their parameter values are different.\n    //\n    // Refer to isNavigatingToNewRootLayout for details.\n    //\n    // Note that we only have to perform this extra traversal if we didn't\n    // already discover a root layout in the part of the tree that is unchanged.\n    // In the common case, this branch is skipped completely.\n    if (\n      oldRouterState === undefined ||\n      isNavigatingToNewRootLayout(oldRouterState, newRouterState)\n    ) {\n      // The root layout changed. Perform a full-page navigation.\n      return MPA_NAVIGATION_TASK\n    }\n  }\n  return createCacheNodeOnNavigation(\n    navigatedAt,\n    newRouterState,\n    existingCacheNode,\n    prefetchData,\n    possiblyPartialPrefetchHead,\n    isPrefetchHeadPartial,\n    segmentPath,\n    scrollableSegmentsResult\n  )\n}\n\nfunction createCacheNodeOnNavigation(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  existingCacheNode: CacheNode | void,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): SPANavigationTask {\n  // Same traversal as updateCacheNodeNavigation, but we switch to this path\n  // once we reach the part of the tree that was not in the previous route. We\n  // don't need to diff against the old tree, we just need to create a new one.\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const routerStateChildren = routerState[1]\n  const isLeafSegment = Object.keys(routerStateChildren).length === 0\n\n  // Even we're rendering inside the \"new\" part of the target tree, we may have\n  // a locally cached segment that we can reuse. This may come from either 1)\n  // the CacheNode tree, which lives in React state and is populated by previous\n  // navigations; or 2) the prefetch cache, which is a separate cache that is\n  // populated by prefetches.\n  let rsc: React.ReactNode\n  let loading: LoadingModuleData | Promise<LoadingModuleData>\n  let head: HeadData | null\n  let cacheNodeNavigatedAt: number\n  if (\n    existingCacheNode !== undefined &&\n    // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n    // the experimental.staleTimes.dynamic config. When set, we'll avoid\n    // refetching dynamic data if it was fetched within the given threshold.\n    existingCacheNode.navigatedAt + DYNAMIC_STALETIME_MS > navigatedAt\n  ) {\n    // We have an existing CacheNode for this segment, and it's not stale. We\n    // should reuse it rather than request a new one.\n    rsc = existingCacheNode.rsc\n    loading = existingCacheNode.loading\n    head = existingCacheNode.head\n\n    // Don't update the navigatedAt timestamp, since we're reusing stale data.\n    cacheNodeNavigatedAt = existingCacheNode.navigatedAt\n  } else if (prefetchData !== null) {\n    // There's no existing CacheNode for this segment, but we do have prefetch\n    // data. If the prefetch data is fully static (i.e. does not contain any\n    // dynamic holes), we don't need to request it from the server.\n    rsc = prefetchData[0]\n    loading = prefetchData[2]\n    head = isLeafSegment ? possiblyPartialPrefetchHead : null\n    // Even though we're accessing the data from the prefetch cache, this is\n    // conceptually a new segment, not a reused one. So we should update the\n    // navigatedAt timestamp.\n    cacheNodeNavigatedAt = navigatedAt\n    const isPrefetchRscPartial = prefetchData[3]\n    if (\n      // Check if the segment data is partial\n      isPrefetchRscPartial ||\n      // Check if the head is partial (only relevant if this is a leaf segment)\n      (isPrefetchHeadPartial && isLeafSegment)\n    ) {\n      // We only have partial data from this segment. Like missing segments, we\n      // must request the full data from the server.\n      return spawnPendingTask(\n        navigatedAt,\n        routerState,\n        prefetchData,\n        possiblyPartialPrefetchHead,\n        isPrefetchHeadPartial,\n        segmentPath,\n        scrollableSegmentsResult\n      )\n    } else {\n      // The prefetch data is fully static, so we can omit it from the\n      // navigation request.\n    }\n  } else {\n    // There's no prefetch for this segment. Everything from this point will be\n    // requested from the server, even if there are static children below it.\n    // Create a terminal task node that will later be fulfilled by\n    // server response.\n    return spawnPendingTask(\n      navigatedAt,\n      routerState,\n      null,\n      possiblyPartialPrefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      scrollableSegmentsResult\n    )\n  }\n\n  // We already have a full segment we can render, so we don't need to request a\n  // new one from the server. Keep traversing down the tree until we reach\n  // something that requires a dynamic request.\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n  const taskChildren = new Map()\n  const existingCacheNodeChildren =\n    existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null\n  const cacheNodeChildren = new Map(existingCacheNodeChildren)\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let needsDynamicRequest = false\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    scrollableSegmentsResult.push(segmentPath)\n  } else {\n    for (let parallelRouteKey in routerStateChildren) {\n      const routerStateChild: FlightRouterState =\n        routerStateChildren[parallelRouteKey]\n      const prefetchDataChild: CacheNodeSeedData | void | null =\n        prefetchDataChildren !== null\n          ? prefetchDataChildren[parallelRouteKey]\n          : null\n      const existingSegmentMapChild =\n        existingCacheNodeChildren !== null\n          ? existingCacheNodeChildren.get(parallelRouteKey)\n          : undefined\n      const segmentChild = routerStateChild[0]\n      const segmentPathChild = segmentPath.concat([\n        parallelRouteKey,\n        segmentChild,\n      ])\n      const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n      const existingCacheNodeChild =\n        existingSegmentMapChild !== undefined\n          ? existingSegmentMapChild.get(segmentKeyChild)\n          : undefined\n\n      const taskChild = createCacheNodeOnNavigation(\n        navigatedAt,\n        routerStateChild,\n        existingCacheNodeChild,\n        prefetchDataChild,\n        possiblyPartialPrefetchHead,\n        isPrefetchHeadPartial,\n        segmentPathChild,\n        scrollableSegmentsResult\n      )\n      taskChildren.set(parallelRouteKey, taskChild)\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        needsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild\n      }\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map()\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  return {\n    // Since we're inside a new route tree, unlike the\n    // `updateCacheNodeOnNavigation` path, the router state on the children\n    // tasks is always the same as the router state we pass in. So we don't need\n    // to clone/modify it.\n    route: routerState,\n    node: {\n      lazyData: null,\n      // Since this segment is already full, we don't need to use the\n      // `prefetchRsc` field.\n      rsc,\n      prefetchRsc: null,\n      head,\n      prefetchHead: null,\n      loading,\n      parallelRoutes: cacheNodeChildren,\n      navigatedAt: cacheNodeNavigatedAt,\n    },\n    dynamicRequestTree: needsDynamicRequest\n      ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren)\n      : null,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction spawnPendingTask(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): SPANavigationTask {\n  // Create a task that will later be fulfilled by data from the server.\n\n  // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n  // this to the server so it knows where to start rendering.\n  const dynamicRequestTree = patchRouterStateWithNewChildren(\n    routerState,\n    routerState[1]\n  )\n  dynamicRequestTree[3] = 'refetch'\n\n  const newTask: Task = {\n    route: routerState,\n\n    // Corresponds to the part of the route that will be rendered on the server.\n    node: createPendingCacheNode(\n      navigatedAt,\n      routerState,\n      prefetchData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      scrollableSegmentsResult\n    ),\n    // Because this is non-null, and it gets propagated up through the parent\n    // tasks, the root task will know that it needs to perform a server request.\n    dynamicRequestTree,\n    children: null,\n  }\n  return newTask\n}\n\nfunction reuseActiveSegmentInDefaultSlot(\n  oldUrl: URL,\n  oldRouterState: FlightRouterState\n): Task {\n  // This is a \"default\" segment. These are never sent by the server during a\n  // soft navigation; instead, the client reuses whatever segment was already\n  // active in that slot on the previous route. This means if we later need to\n  // refresh the segment, it will have to be refetched from the previous route's\n  // URL. We store it in the Flight Router State.\n  //\n  // TODO: We also mark the segment with a \"refresh\" marker but I think we can\n  // get rid of that eventually by making sure we only add URLs to page segments\n  // that are reused. Then the presence of the URL alone is enough.\n  let reusedRouterState\n\n  const oldRefreshMarker = oldRouterState[3]\n  if (oldRefreshMarker === 'refresh') {\n    // This segment was already reused from an even older route. Keep its\n    // existing URL and refresh marker.\n    reusedRouterState = oldRouterState\n  } else {\n    // This segment was not previously reused, and it's not on the new route.\n    // So it must have been delivered in the old route.\n    reusedRouterState = patchRouterStateWithNewChildren(\n      oldRouterState,\n      oldRouterState[1]\n    )\n    reusedRouterState[2] = createHrefFromUrl(oldUrl)\n    reusedRouterState[3] = 'refresh'\n  }\n\n  return {\n    route: reusedRouterState,\n    node: null,\n    dynamicRequestTree: null,\n    children: null,\n  }\n}\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for — everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function listenForDynamicRequest(\n  task: SPANavigationTask,\n  responsePromise: Promise<FetchServerResponseResult>\n) {\n  responsePromise.then(\n    (result: FetchServerResponseResult) => {\n      if (typeof result === 'string') {\n        // Happens when navigating to page in `pages` from `app`. We shouldn't\n        // get here because should have already handled this during\n        // the prefetch.\n        return\n      }\n      const { flightData, debugInfo } = result\n      for (const normalizedFlightData of flightData) {\n        const {\n          segmentPath,\n          tree: serverRouterState,\n          seedData: dynamicData,\n          head: dynamicHead,\n        } = normalizedFlightData\n\n        if (!dynamicData) {\n          // This shouldn't happen. PPR should always send back a response.\n          // However, `FlightDataPath` is a shared type and the pre-PPR handling of\n          // this might return null.\n          continue\n        }\n\n        writeDynamicDataIntoPendingTask(\n          task,\n          segmentPath,\n          serverRouterState,\n          dynamicData,\n          dynamicHead,\n          debugInfo\n        )\n      }\n\n      // Now that we've exhausted all the data we received from the server, if\n      // there are any remaining pending tasks in the tree, abort them now.\n      // If there's any missing data, it will trigger a lazy fetch.\n      abortTask(task, null, debugInfo)\n    },\n    (error: any) => {\n      // This will trigger an error during render\n      abortTask(task, error, null)\n    }\n  )\n}\n\nfunction writeDynamicDataIntoPendingTask(\n  rootTask: SPANavigationTask,\n  segmentPath: FlightSegmentPath,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n) {\n  // The data sent by the server represents only a subtree of the app. We need\n  // to find the part of the task tree that matches the server response, and\n  // fulfill it using the dynamic data.\n  //\n  // segmentPath represents the parent path of subtree. It's a repeating pattern\n  // of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // Iterate through the path and finish any tasks that match this payload.\n  let task = rootTask\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n    const taskChildren = task.children\n    if (taskChildren !== null) {\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild !== undefined) {\n        const taskSegment = taskChild.route[0]\n        if (matchSegment(segment, taskSegment)) {\n          // Found a match for this task. Keep traversing down the task tree.\n          task = taskChild\n          continue\n        }\n      }\n    }\n    // We didn't find a child task that matches the server data. Exit. We won't\n    // abort the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    return\n  }\n\n  finishTaskUsingDynamicDataPayload(\n    task,\n    serverRouterState,\n    dynamicData,\n    dynamicHead,\n    debugInfo\n  )\n}\n\nfunction finishTaskUsingDynamicDataPayload(\n  task: SPANavigationTask,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n) {\n  if (task.dynamicRequestTree === null) {\n    // Everything in this subtree is already complete. Bail out.\n    return\n  }\n\n  // dynamicData may represent a larger subtree than the task. Before we can\n  // finish the task, we need to line them up.\n  const taskChildren = task.children\n  const taskNode = task.node\n  if (taskChildren === null) {\n    // We've reached the leaf node of the pending task. The server data tree\n    // lines up the pending Cache Node tree. We can now switch to the\n    // normal algorithm.\n    if (taskNode !== null) {\n      finishPendingCacheNode(\n        taskNode,\n        task.route,\n        serverRouterState,\n        dynamicData,\n        dynamicHead,\n        debugInfo\n      )\n      // Set this to null to indicate that this task is now complete.\n      task.dynamicRequestTree = null\n    }\n    return\n  }\n  // The server returned more data than we need to finish the task. Skip over\n  // the extra segments until we reach the leaf task node.\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData[1]\n\n  for (const parallelRouteKey in serverRouterState) {\n    const serverRouterStateChild: FlightRouterState =\n      serverChildren[parallelRouteKey]\n    const dynamicDataChild: CacheNodeSeedData | null | void =\n      dynamicDataChildren[parallelRouteKey]\n\n    const taskChild = taskChildren.get(parallelRouteKey)\n    if (taskChild !== undefined) {\n      const taskSegment = taskChild.route[0]\n      if (\n        matchSegment(serverRouterStateChild[0], taskSegment) &&\n        dynamicDataChild !== null &&\n        dynamicDataChild !== undefined\n      ) {\n        // Found a match for this task. Keep traversing down the task tree.\n        return finishTaskUsingDynamicDataPayload(\n          taskChild,\n          serverRouterStateChild,\n          dynamicDataChild,\n          dynamicHead,\n          debugInfo\n        )\n      }\n    }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n  }\n}\n\nfunction createPendingCacheNode(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): ReadyCacheNode {\n  const routerStateChildren = routerState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  const parallelRoutes = new Map()\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const prefetchDataChild: CacheNodeSeedData | null | void =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const segmentChild = routerStateChild[0]\n    const segmentPathChild = segmentPath.concat([\n      parallelRouteKey,\n      segmentChild,\n    ])\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n    const newCacheNodeChild = createPendingCacheNode(\n      navigatedAt,\n      routerStateChild,\n      prefetchDataChild === undefined ? null : prefetchDataChild,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPathChild,\n      scrollableSegmentsResult\n    )\n\n    const newSegmentMapChild: ChildSegmentMap = new Map()\n    newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n    parallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n  }\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const isLeafSegment = parallelRoutes.size === 0\n\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    scrollableSegmentsResult.push(segmentPath)\n  }\n\n  const maybePrefetchRsc = prefetchData !== null ? prefetchData[0] : null\n  return {\n    lazyData: null,\n    parallelRoutes: parallelRoutes,\n\n    prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n    prefetchHead: isLeafSegment ? prefetchHead : [null, null],\n\n    // Create a deferred promise. This will be fulfilled once the dynamic\n    // response is received from the server.\n    rsc: createDeferredRsc() as React.ReactNode,\n    head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,\n\n    // TODO: Technically, a loading boundary could contain dynamic data. We must\n    // have separate `loading` and `prefetchLoading` fields to handle this, like\n    // we do for the segment data and head.\n    loading:\n      prefetchData !== null\n        ? (prefetchData[2] ?? null)\n        : // If we don't have a prefetch, then we don't know if there's a loading component.\n          // We'll fulfill it based on the dynamic response, just like `rsc` and `head`.\n          createDeferredRsc<LoadingModuleData>(),\n\n    navigatedAt,\n  }\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  taskState: FlightRouterState,\n  serverState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety — it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n  const taskStateChildren = taskState[1]\n  const serverStateChildren = serverState[1]\n  const dataChildren = dynamicData[1]\n\n  // The router state that we traverse the tree with (taskState) is the same one\n  // that we used to construct the pending Cache Node tree. That way we're sure\n  // to resolve all the pending promises.\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in taskStateChildren) {\n    const taskStateChild: FlightRouterState =\n      taskStateChildren[parallelRouteKey]\n    const serverStateChild: FlightRouterState | void =\n      serverStateChildren[parallelRouteKey]\n    const dataChild: CacheNodeSeedData | null | void =\n      dataChildren[parallelRouteKey]\n\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    const taskSegmentChild = taskStateChild[0]\n    const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)\n\n    const cacheNodeChild =\n      segmentMapChild !== undefined\n        ? segmentMapChild.get(taskSegmentKeyChild)\n        : undefined\n\n    if (cacheNodeChild !== undefined) {\n      if (\n        serverStateChild !== undefined &&\n        matchSegment(taskSegmentChild, serverStateChild[0])\n      ) {\n        if (dataChild !== undefined && dataChild !== null) {\n          // This is the happy path. Recursively update all the children.\n          finishPendingCacheNode(\n            cacheNodeChild,\n            taskStateChild,\n            serverStateChild,\n            dataChild,\n            dynamicHead,\n            debugInfo\n          )\n        } else {\n          // The server never returned data for this segment. Trigger a lazy\n          // fetch during render. This shouldn't happen because the Route Tree\n          // and the Seed Data tree sent by the server should always be the same\n          // shape when part of the same server response.\n          abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n        }\n      } else {\n        // The server never returned data for this segment. Trigger a lazy\n        // fetch during render.\n        abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n      }\n    } else {\n      // The server response matches what was expected to receive, but there's\n      // no matching Cache Node in the task tree. This is a bug in the\n      // implementation because we should have created a node for every\n      // segment in the tree that's associated with this task.\n    }\n  }\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[0]\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData, debugInfo)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // If we navigated without a prefetch, then `loading` will be a deferred promise too.\n  // Fulfill it using the dynamic response so that we can display the loading boundary.\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    const dynamicLoading = dynamicData[2]\n    loading.resolve(dynamicLoading, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead, debugInfo)\n  }\n}\n\nexport function abortTask(\n  task: SPANavigationTask,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  const cacheNode = task.node\n  if (cacheNode === null) {\n    // This indicates the task is already complete.\n    return\n  }\n\n  const taskChildren = task.children\n  if (taskChildren === null) {\n    // Reached the leaf task node. This is the root of a pending cache\n    // node tree.\n    abortPendingCacheNode(task.route, cacheNode, error, debugInfo)\n  } else {\n    // This is an intermediate task node. Keep traversing until we reach a\n    // task node with no children. That will be the root of the cache node tree\n    // that needs to be resolved.\n    for (const taskChild of taskChildren.values()) {\n      abortTask(taskChild, error, debugInfo)\n    }\n  }\n\n  // Set this to null to indicate that this task is now complete.\n  task.dynamicRequestTree = null\n}\n\nfunction abortPendingCacheNode(\n  routerState: FlightRouterState,\n  cacheNode: CacheNode,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  // For every pending segment in the tree, resolve its `rsc` promise to `null`\n  // to trigger a lazy fetch during render.\n  //\n  // Or, if an error object is provided, it will error instead.\n  const routerStateChildren = routerState[1]\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    if (segmentMapChild === undefined) {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n      continue\n    }\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n    if (cacheNodeChild !== undefined) {\n      abortPendingCacheNode(routerStateChild, cacheNodeChild, error, debugInfo)\n    } else {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n    }\n  }\n\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null, debugInfo)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error, debugInfo)\n    }\n  }\n\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    loading.resolve(null, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null, debugInfo)\n  }\n}\n\nexport function updateCacheNodeOnPopstateRestoration(\n  oldCacheNode: CacheNode,\n  routerState: FlightRouterState\n): ReadyCacheNode {\n  // A popstate navigation reads data from the local cache. It does not issue\n  // new network requests (unless the cache entries have been evicted). So, we\n  // update the cache to drop the prefetch data for any segment whose dynamic\n  // data was already received. This prevents an unnecessary flash back to PPR\n  // state during a back/forward navigation.\n  //\n  // This function clones the entire cache node tree and sets the `prefetchRsc`\n  // field to `null` to prevent it from being rendered. We can't mutate the node\n  // in place because this is a concurrent data structure.\n\n  const routerStateChildren = routerState[1]\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n  const newParallelRoutes = new Map(oldParallelRoutes)\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    if (oldSegmentMapChild !== undefined) {\n      const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)\n      if (oldCacheNodeChild !== undefined) {\n        const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(\n          oldCacheNodeChild,\n          routerStateChild\n        )\n        const newSegmentMapChild = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  // Only show prefetched data if the dynamic data is still pending.\n  //\n  // Tehnically, what we're actually checking is whether the dynamic network\n  // response was received. But since it's a streaming response, this does not\n  // mean that all the dynamic data has fully streamed in. It just means that\n  // _some_ of the dynamic data was received. But as a heuristic, we assume that\n  // the rest dynamic data will stream in quickly, so it's still better to skip\n  // the prefetch state.\n  const rsc = oldCacheNode.rsc\n  const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending'\n\n  return {\n    lazyData: null,\n    rsc,\n    head: oldCacheNode.head,\n\n    prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [null, null],\n    prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n    loading: oldCacheNode.loading,\n\n    // These are the cloned children we computed above\n    parallelRoutes: newParallelRoutes,\n\n    navigatedAt: oldCacheNode.navigatedAt,\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc<T> = Promise<T> & {\n  status: 'pending'\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype FulfilledDeferredRsc<T> = Promise<T> & {\n  status: 'fulfilled'\n  value: T\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype RejectedDeferredRsc<T> = Promise<T> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype DeferredRsc<T extends React.ReactNode = React.ReactNode> =\n  | PendingDeferredRsc<T>\n  | FulfilledDeferredRsc<T>\n  | RejectedDeferredRsc<T>\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value: any): value is DeferredRsc {\n  return value && typeof value === 'object' && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc<\n  T extends React.ReactNode = React.ReactNode,\n>(): PendingDeferredRsc<T> {\n  // Create an unresolved promise that represents data derived from a Flight\n  // response. The promise will be resolved later as soon as we start receiving\n  // data from the server, i.e. as soon as the Flight client decodes and returns\n  // the top-level response object.\n\n  // The `_debugInfo` field contains profiling information. Promises that are\n  // created by Flight already have this info added by React; for any derived\n  // promise created by the router, we need to transfer the Flight debug info\n  // onto the derived promise.\n  //\n  // The debug info represents the latency between the start of the navigation\n  // and the start of rendering. (It does not represent the time it takes for\n  // whole stream to finish.)\n  const debugInfo: Array<any> = []\n\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc<T>\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: T, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc<T> = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc<T> = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  pendingRsc._debugInfo = debugInfo\n\n  return pendingRsc\n}\n","/**\n * App Router types - Client-safe types for the Next.js App Router\n *\n * This file contains type definitions that can be safely imported\n * by both client-side and server-side code without circular dependencies.\n */\nimport type { FetchServerResponseResult } from '../../client/components/router-reducer/fetch-server-response'\nimport type React from 'react'\n\nexport type LoadingModuleData =\n  | [React.JSX.Element, React.ReactNode, React.ReactNode]\n  | null\n\n/** viewport metadata node */\nexport type HeadData = React.ReactNode\n\nexport type ChildSegmentMap = Map<string, CacheNode>\n\n/**\n * Cache node used in app-router / layout-router.\n */\nexport type CacheNode = ReadyCacheNode | LazyCacheNode\n\nexport type LazyCacheNode = {\n  /**\n   * When rsc is null, this is a lazily-initialized cache node.\n   *\n   * If the app attempts to render it, it triggers a lazy data fetch,\n   * postpones the render, and schedules an update to a new tree.\n   *\n   * TODO: This mechanism should not be used when PPR is enabled, though it\n   * currently is in some cases until we've implemented partial\n   * segment fetching.\n   */\n  rsc: null\n\n  /**\n   * A prefetched version of the segment data. See explanation in corresponding\n   * field of ReadyCacheNode (below).\n   *\n   * Since LazyCacheNode mostly only exists in the non-PPR implementation, this\n   * will usually be null, but it could have been cloned from a previous\n   * CacheNode that was created by the PPR implementation. Eventually we want\n   * to migrate everything away from LazyCacheNode entirely.\n   */\n  prefetchRsc: React.ReactNode\n\n  /**\n   * A pending response for the lazy data fetch. If this is not present\n   * during render, it is lazily created.\n   */\n  lazyData: Promise<FetchServerResponseResult> | null\n\n  prefetchHead: HeadData | null\n\n  head: HeadData\n\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n\n  /**\n   * Child parallel routes.\n   */\n  parallelRoutes: Map<string, ChildSegmentMap>\n\n  /**\n   * The timestamp of the navigation that last updated the CacheNode's data. If\n   * a CacheNode is reused from a previous navigation, this value is not\n   * updated. Used to track the staleness of the data.\n   */\n  navigatedAt: number\n}\n\nexport type ReadyCacheNode = {\n  /**\n   * When rsc is not null, it represents the RSC data for the\n   * corresponding segment.\n   *\n   * `null` is a valid React Node but because segment data is always a\n   * <LayoutRouter> component, we can use `null` to represent empty.\n   *\n   * TODO: For additional type safety, update this type to\n   * Exclude<React.ReactNode, null>. Need to update createEmptyCacheNode to\n   * accept rsc as an argument, or just inline the callers.\n   */\n  rsc: React.ReactNode\n\n  /**\n   * Represents a static version of the segment that can be shown immediately,\n   * and may or may not contain dynamic holes. It's prefetched before a\n   * navigation occurs.\n   *\n   * During rendering, we will choose whether to render `rsc` or `prefetchRsc`\n   * with `useDeferredValue`. As with the `rsc` field, a value of `null` means\n   * no value was provided. In this case, the LayoutRouter will go straight to\n   * rendering the `rsc` value; if that one is also missing, it will suspend and\n   * trigger a lazy fetch.\n   */\n  prefetchRsc: React.ReactNode\n\n  /**\n   * There should never be a lazy data request in this case.\n   */\n  lazyData: null\n  prefetchHead: HeadData | null\n\n  head: HeadData\n\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n\n  parallelRoutes: Map<string, ChildSegmentMap>\n\n  navigatedAt: number\n}\n\nexport type DynamicParamTypes =\n  | 'catchall'\n  | 'catchall-intercepted-(..)(..)'\n  | 'catchall-intercepted-(.)'\n  | 'catchall-intercepted-(..)'\n  | 'catchall-intercepted-(...)'\n  | 'optional-catchall'\n  | 'dynamic'\n  | 'dynamic-intercepted-(..)(..)'\n  | 'dynamic-intercepted-(.)'\n  | 'dynamic-intercepted-(..)'\n  | 'dynamic-intercepted-(...)'\n\nexport type DynamicParamTypesShort =\n  | 'c'\n  | 'ci(..)(..)'\n  | 'ci(.)'\n  | 'ci(..)'\n  | 'ci(...)'\n  | 'oc'\n  | 'd'\n  | 'di(..)(..)'\n  | 'di(.)'\n  | 'di(..)'\n  | 'di(...)'\n\nexport type Segment =\n  | string\n  | [\n      // Param name\n      paramName: string,\n      // Param cache key (almost the same as the value, but arrays are\n      // concatenated into strings)\n      // TODO: We should change this to just be the value. Currently we convert\n      // it back to a value when passing to useParams. It only needs to be\n      // a string when converted to a a cache key, but that doesn't mean we\n      // need to store it as that representation.\n      paramCacheKey: string,\n      // Dynamic param type\n      dynamicParamType: DynamicParamTypesShort,\n    ]\n\n/**\n * Router state\n */\nexport type FlightRouterState = [\n  segment: Segment,\n  parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },\n  url?: string | null,\n  /**\n   * \"refresh\" and \"refetch\", despite being similarly named, have different\n   * semantics:\n   * - \"refetch\" is used during a request to inform the server where rendering\n   *   should start from.\n   *\n   * - \"refresh\" is used by the client to mark that a segment should re-fetch the\n   *   data from the server for the current segment. It uses the \"url\" property\n   *   above to determine where to fetch from.\n   *\n   * - \"inside-shared-layout\" is used during a prefetch request to inform the\n   *   server that even if the segment matches, it should be treated as if it's\n   *   within the \"new\" part of a navigation — inside the shared layout. If\n   *   the segment doesn't match, then it has no effect, since it would be\n   *   treated as new regardless. If it does match, though, the server does not\n   *   need to render it, because the client already has it.\n   *\n   * - \"metadata-only\" instructs the server to skip rendering the segments and\n   *   only send the head data.\n   *\n   *   A bit confusing, but that's because it has only one extremely narrow use\n   *   case — during a non-PPR prefetch, the server uses it to find the first\n   *   loading boundary beneath a shared layout.\n   *\n   *   TODO: We should rethink the protocol for dynamic requests. It might not\n   *   make sense for the client to send a FlightRouterState, since this type is\n   *   overloaded with concerns.\n   */\n  refresh?:\n    | 'refetch'\n    | 'refresh'\n    | 'inside-shared-layout'\n    | 'metadata-only'\n    | null,\n  isRootLayout?: boolean,\n  /**\n   * Only present when responding to a tree prefetch request. Indicates whether\n   * there is a loading boundary somewhere in the tree. The client cache uses\n   * this to determine if it can skip the data prefetch request.\n   */\n  hasLoadingBoundary?: HasLoadingBoundary,\n]\n\nexport const enum HasLoadingBoundary {\n  // There is a loading boundary in this particular segment\n  SegmentHasLoadingBoundary = 1,\n  // There is a loading boundary somewhere in the subtree (but not in\n  // this segment)\n  SubtreeHasLoadingBoundary = 2,\n  // There is no loading boundary in this segment or any of its descendants\n  SubtreeHasNoLoadingBoundary = 3,\n}\n\n/**\n * Individual Flight response path\n */\nexport type FlightSegmentPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n    ]\n\n/**\n * Represents a tree of segments and the Flight data (i.e. React nodes) that\n * correspond to each one. The tree is isomorphic to the FlightRouterState;\n * however in the future we want to be able to fetch arbitrary partial segments\n * without having to fetch all its children. So this response format will\n * likely change.\n */\nexport type CacheNodeSeedData = [\n  node: React.ReactNode | null,\n  parallelRoutes: {\n    [parallelRouterKey: string]: CacheNodeSeedData | null\n  },\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n  /** TODO: this doesn't feel like it belongs here, because it's only used during build, in `collectSegmentData` */\n  hasRuntimePrefetch: boolean,\n]\n\nexport type FlightDataSegment = [\n  /* segment of the rendered slice: */ Segment,\n  /* treePatch */ FlightRouterState,\n  /* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component\n  /* head: viewport */ HeadData,\n  /* isHeadPartial */ boolean,\n]\n\nexport type FlightDataPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      // Holds full path to the segment.\n      ...FlightSegmentPath[],\n      ...FlightDataSegment,\n    ]\n\n/**\n * The Flight response data\n */\nexport type FlightData = Array<FlightDataPath> | string\n\nexport type ActionResult = Promise<any>\n\nexport type InitialRSCPayload = {\n  /** buildId */\n  b: string\n  /** initialCanonicalUrlParts */\n  c: string[]\n  /** initialRenderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n  /** initialFlightData */\n  f: FlightDataPath[]\n  /** missingSlots */\n  m: Set<string> | undefined\n  /** GlobalError */\n  G: [React.ComponentType<any>, React.ReactNode | undefined]\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for normal rendering\nexport type NavigationFlightResponse = {\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** prerendered */\n  S: boolean\n  /** runtimePrefetch - [isPartial, staleTime]. Only present in runtime prefetch responses. */\n  rp?: [boolean, number]\n}\n\n// Response from `createFromFetch` for server actions. Action's flight data can be null\nexport type ActionFlightResponse = {\n  /** actionResult */\n  a: ActionResult\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n}\n\nexport type RSCPayload =\n  | InitialRSCPayload\n  | NavigationFlightResponse\n  | ActionFlightResponse\n","/**\n * Shared types and constants for the Segment Cache.\n */\n\nexport const enum NavigationResultTag {\n  MPA,\n  Success,\n  NoOp,\n  Async,\n}\n\n/**\n * The priority of the prefetch task. Higher numbers are higher priority.\n */\nexport const enum PrefetchPriority {\n  /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */\n  Intent = 2,\n  /**\n   * The default priority for prefetch tasks.\n   */\n  Default = 1,\n  /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */\n  Background = 0,\n}\n\nexport const enum FetchStrategy {\n  // Deliberately ordered so we can easily compare two segments\n  // and determine if one segment is \"more specific\" than another\n  // (i.e. if it's likely that it contains more data)\n  LoadingBoundary = 0,\n  PPR = 1,\n  PPRRuntime = 2,\n  Full = 3,\n}\n\n/**\n * A subset of fetch strategies used for prefetch tasks.\n * A prefetch task can't know if it should use `PPR` or `LoadingBoundary`\n * until we complete the initial tree prefetch request, so we use `PPR` to signal both cases\n * and adjust it based on the route when actually fetching.\n * */\nexport type PrefetchTaskFetchStrategy =\n  | FetchStrategy.PPR\n  | FetchStrategy.PPRRuntime\n  | FetchStrategy.Full\n","import type { MapEntry } from './cache-map'\nimport { deleteFromCacheMap } from './cache-map'\n\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\n\n// The MapEntry type is used as an LRU node, too. We choose this one instead of\n// the inner cache entry type (RouteCacheEntry, SegmentCacheEntry) because it's\n// monomorphic and can be optimized by the VM.\ntype LRUNode = MapEntry<any>\n\nlet head: LRUNode | null = null\nlet didScheduleCleanup: boolean = false\nlet lruSize: number = 0\n\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n\nexport function lruPut(node: LRUNode) {\n  if (head === node) {\n    // Already at the head\n    return\n  }\n  const prev = node.prev\n  const next = node.next\n  if (next === null || prev === null) {\n    // This is an insertion\n    lruSize += node.size\n    // Whenever we add an entry, we need to check if we've exceeded the\n    // max size. We don't evict entries immediately; they're evicted later in\n    // an asynchronous task.\n    ensureCleanupIsScheduled()\n  } else {\n    // This is a move. Remove from its current position.\n    prev.next = next\n    next.prev = prev\n  }\n\n  // Move to the front of the list\n  if (head === null) {\n    // This is the first entry\n    node.prev = node\n    node.next = node\n  } else {\n    // Add to the front of the list\n    const tail = head.prev\n    node.prev = tail\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      tail.next = node\n    }\n    node.next = head\n    head.prev = node\n  }\n  head = node\n}\n\nexport function updateLruSize(node: LRUNode, newNodeSize: number) {\n  // This is a separate function from `put` so that we can resize the entry\n  // regardless of whether it's currently being tracked by the LRU.\n  const prevNodeSize = node.size\n  node.size = newNodeSize\n  if (node.next === null) {\n    // This entry is not currently being tracked by the LRU.\n    return\n  }\n  // Update the total LRU size\n  lruSize = lruSize - prevNodeSize + newNodeSize\n  ensureCleanupIsScheduled()\n}\n\nexport function deleteFromLru(deleted: LRUNode) {\n  const next = deleted.next\n  const prev = deleted.prev\n  if (next !== null && prev !== null) {\n    lruSize -= deleted.size\n\n    deleted.next = null\n    deleted.prev = null\n\n    // Remove from the list\n    if (head === deleted) {\n      // Update the head\n      if (next === head) {\n        // This was the last entry\n        head = null\n      } else {\n        head = next\n      }\n    } else {\n      prev.next = next\n      next.prev = prev\n    }\n  } else {\n    // Already deleted\n  }\n}\n\nfunction ensureCleanupIsScheduled() {\n  if (didScheduleCleanup || lruSize <= maxLruSize) {\n    return\n  }\n  didScheduleCleanup = true\n  requestCleanupCallback(cleanup)\n}\n\nfunction cleanup() {\n  didScheduleCleanup = false\n\n  // Evict entries until we're at 90% capacity. We can assume this won't\n  // infinite loop because even if `maxLruSize` were 0, eventually\n  // `deleteFromLru` sets `head` to `null` when we run out entries.\n  const ninetyPercentMax = maxLruSize * 0.9\n  while (lruSize > ninetyPercentMax && head !== null) {\n    const tail = head.prev\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      // Delete the entry from the map. In turn, this will remove it from\n      // the LRU.\n      deleteFromCacheMap(tail.value)\n    }\n  }\n}\n\nconst requestCleanupCallback =\n  typeof requestIdleCallback === 'function'\n    ? requestIdleCallback\n    : (cb: () => void) => setTimeout(cb, 0)\n","import type { VaryPath } from './vary-path'\nimport { lruPut, updateLruSize, deleteFromLru } from './lru'\n\n/**\n * A specialized data type for storing multi-key cache entries.\n *\n * The basic structure is a map whose keys are tuples, called the keypath.\n * When querying the cache, keypaths are compared per-element.\n *\n * Example:\n *   set(map, ['https://localhost', 'foo/bar/baz'], 'yay');\n *   get(map, ['https://localhost', 'foo/bar/baz']) -> 'yay'\n *\n * NOTE: Array syntax is used in these examples for illustration purposes, but\n * in reality the paths are lists.\n * \n * The parts of the keypath represent the different inputs that contribute\n * to the entry value. To illustrate, if you were to use this data type to store\n * HTTP responses, the keypath would include the URL and everything listed by\n * the Vary header.\n * \n * See vary-path.ts for more details.\n *\n * The order of elements in a keypath must be consistent between lookups to\n * be considered the same, but besides that, the order of the keys is not\n * semantically meaningful.\n *\n * Keypaths may include a special kind of key called Fallback. When an entry is\n * stored with Fallback as part of its keypath, it means that the entry does not\n * vary by that key. When querying the cache, if an exact match is not found for\n * a keypath, the cache will check for a Fallback match instead. Each element of\n * the keypath may have a Fallback, so retrieval is an O(n ^ 2) operation, but\n * it's expected that keypaths are relatively short.\n *\n * Example:\n *   set(cacheMap, ['store', 'product', 1], PRODUCT_PAGE_1);\n *   set(cacheMap, ['store', 'product', Fallback], GENERIC_PRODUCT_PAGE);\n *\n *   // Exact match\n *   get(cacheMap, ['store', 'product', 1]) -> PRODUCT_PAGE_1\n *\n *   // Fallback match\n *   get(cacheMap, ['store', 'product', 2]) -> GENERIC_PRODUCT_PAGE\n *\n * Because we have the Fallback mechanism, we can impose a constraint that\n * regular JS maps do not have: a value cannot be stored at multiple keypaths\n * simultaneously. These cases should be expressed with Fallback keys instead.\n *\n * Additionally, because values only exist at a single keypath at a time, we\n * can optimize successive lookups by caching the internal map entry on the\n * value itself, using the `ref` field. This is especially useful because it\n * lets us skip the O(n ^ 2) lookup that occurs when Fallback entries\n * are present.\n *\n\n * How to decide if stuff belongs in here, or in cache.ts?\n * -------------------------------------------------------\n * \n * Anything to do with retrival, lifetimes, or eviction needs to go in this\n * module because it affects the fallback algorithm. For example, when\n * performing a lookup, if an entry is stale, it needs to be treated as\n * semantically equivalent to if the entry was not present at all.\n * \n * If there's logic that's not related to the fallback algorithm, though, we\n * should prefer to put it in cache.ts.\n */\n\ntype MapEntryShared<V extends MapValue> = {\n  parent: MapEntry<V> | null\n  key: any\n  map: Map<any, MapEntry<V>> | null\n\n  // LRU-related fields\n  prev: MapEntry<any> | null\n  next: MapEntry<any> | null\n  size: number\n}\n\ntype EmptyMapEntry<V extends MapValue> = MapEntryShared<V> & {\n  value: null\n}\n\ntype FullMapEntry<V extends MapValue> = MapEntryShared<V> & {\n  value: V\n}\n\nexport type MapEntry<V extends MapValue> = EmptyMapEntry<V> | FullMapEntry<V>\n\n// The CacheMap type is just the root entry of the map.\nexport type CacheMap<V extends MapValue> = MapEntry<V>\n\n// The protocol that values must implement. In practice, the only two types that\n// we ever actually deal with in this module are RouteCacheEntry and\n// SegmentCacheEntry; this is just to keep track of the coupling so we don't\n// leak concerns between the modules unnecessarily.\nexport interface MapValue {\n  ref: MapEntry<any> | null\n  size: number\n  staleAt: number\n  version: number\n}\n\nexport type FallbackType = { __brand: 'Fallback' }\nexport const Fallback = {} as FallbackType\n\n// This is a special internal key that is used for \"revalidation\" entries. It's\n// an implementation detail that shouldn't leak outside of this module.\nconst Revalidation = {}\n\nexport function createCacheMap<V extends MapValue>(): CacheMap<V> {\n  const cacheMap: MapEntry<V> = {\n    parent: null,\n    key: null,\n    value: null,\n    map: null,\n\n    // LRU-related fields\n    prev: null,\n    next: null,\n    size: 0,\n  }\n  return cacheMap\n}\n\nfunction getOrInitialize<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): MapEntry<V> {\n  // Go through each level of keys until we find the entry that matches, or\n  // create a new entry if one doesn't exist.\n  //\n  // This function will only return entries that match the keypath _exactly_.\n  // Unlike getWithFallback, it will not access fallback entries unless it's\n  // explicitly part of the keypath.\n  let entry = cacheMap\n  let remainingKeys: VaryPath | null = keys\n  let key: unknown | null = null\n  while (true) {\n    const previousKey = key\n    if (remainingKeys !== null) {\n      key = remainingKeys.value\n      remainingKeys = remainingKeys.parent\n    } else if (isRevalidation && previousKey !== Revalidation) {\n      // During a revalidation, we append an internal \"Revalidation\" key to\n      // the end of the keypath. The \"normal\" entry is its parent.\n\n      // However, if the parent entry is currently empty, we don't need to store\n      // this as a revalidation entry. Just insert the revalidation into the\n      // normal slot.\n      if (entry.value === null) {\n        return entry\n      }\n\n      // Otheriwse, create a child entry.\n      key = Revalidation\n    } else {\n      // There are no more keys. This is the terminal entry.\n      break\n    }\n\n    let map = entry.map\n    if (map !== null) {\n      const existingEntry = map.get(key)\n      if (existingEntry !== undefined) {\n        // Found a match. Keep going.\n        entry = existingEntry\n        continue\n      }\n    } else {\n      map = new Map()\n      entry.map = map\n    }\n    // No entry exists yet at this level. Create a new one.\n    const newEntry: EmptyMapEntry<V> = {\n      parent: entry,\n      key,\n      value: null,\n      map: null,\n\n      // LRU-related fields\n      prev: null,\n      next: null,\n      size: 0,\n    }\n    map.set(key, newEntry)\n    entry = newEntry\n  }\n\n  return entry\n}\n\nexport function getFromCacheMap<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  rootEntry: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): V | null {\n  const entry = getEntryWithFallbackImpl(\n    now,\n    currentCacheVersion,\n    rootEntry,\n    keys,\n    isRevalidation,\n    0\n  )\n  if (entry === null || entry.value === null) {\n    return null\n  }\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  return entry.value\n}\n\nexport function isValueExpired<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  value: V\n): boolean {\n  return value.staleAt <= now || value.version < currentCacheVersion\n}\n\nfunction lazilyEvictIfNeeded<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>\n) {\n  // We have a matching entry, but before we can return it, we need to check if\n  // it's still fresh. Otherwise it should be treated the same as a cache miss.\n\n  if (entry.value === null) {\n    // This entry has no value, so there's nothing to evict.\n    return entry\n  }\n\n  const value = entry.value\n  if (isValueExpired(now, currentCacheVersion, value)) {\n    // The value expired. Lazily evict it from the cache, and return null. This\n    // is conceptually the same as a cache miss.\n    deleteMapEntry(entry)\n    return null\n  }\n\n  // The matched entry has not expired. Return it.\n  return entry\n}\n\nfunction getEntryWithFallbackImpl<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>,\n  keys: VaryPath | null,\n  isRevalidation: boolean,\n  previousKey: unknown | null\n): MapEntry<V> | null {\n  // This is similar to getExactEntry, but if an exact match is not found for\n  // a key, it will return the fallback entry instead. This is recursive at\n  // every level, e.g. an entry with keypath [a, Fallback, c, Fallback] is\n  // valid match for [a, b, c, d].\n  //\n  // It will return the most specific match available.\n  let key\n  let remainingKeys: VaryPath | null\n  if (keys !== null) {\n    key = keys.value\n    remainingKeys = keys.parent\n  } else if (isRevalidation && previousKey !== Revalidation) {\n    // During a revalidation, we append an internal \"Revalidation\" key to\n    // the end of the keypath.\n    key = Revalidation\n    remainingKeys = null\n  } else {\n    // There are no more keys. This is the terminal entry.\n\n    // TODO: When performing a lookup during a navigation, as opposed to a\n    // prefetch, we may want to skip entries that are Pending if there's also\n    // a Fulfilled fallback entry. Tricky to say, though, since if it's\n    // already pending, it's likely to stream in soon. Maybe we could do this\n    // just on slow connections and offline mode.\n\n    return lazilyEvictIfNeeded(now, currentCacheVersion, entry)\n  }\n  const map = entry.map\n  if (map !== null) {\n    const existingEntry = map.get(key)\n    if (existingEntry !== undefined) {\n      // Found an exact match for this key. Keep searching.\n      const result = getEntryWithFallbackImpl<V>(\n        now,\n        currentCacheVersion,\n        existingEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n      if (result !== null) {\n        return result\n      }\n    }\n    // No match found for this key. Check if there's a fallback.\n    const fallbackEntry = map.get(Fallback)\n    if (fallbackEntry !== undefined) {\n      // Found a fallback for this key. Keep searching.\n      return getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        fallbackEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n    }\n  }\n  return null\n}\n\nexport function setInCacheMap<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  value: V,\n  isRevalidation: boolean\n): void {\n  // Add a value to the map at the given keypath. If the value is already\n  // part of the map, it's removed from its previous keypath. (NOTE: This is\n  // unlike a regular JS map, but the behavior is intentional.)\n  const entry = getOrInitialize(cacheMap, keys, isRevalidation)\n  setMapEntryValue(entry, value)\n\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  updateLruSize(entry, value.size)\n}\n\nfunction setMapEntryValue<V extends MapValue>(\n  entry: MapEntry<V>,\n  value: V\n): void {\n  if (entry.value !== null) {\n    // There's already a value at the given keypath. Disconnect the old value\n    // from the map. We're not calling `deleteMapEntry` here because the\n    // entry itself is still in the map. We just want to overwrite its value.\n    dropRef(entry.value)\n\n    // Fill the entry with the updated value.\n    const emptyEntry: EmptyMapEntry<V> = entry as any\n    emptyEntry.value = null\n    fillEmptyReference(emptyEntry, value)\n  } else {\n    fillEmptyReference(entry as any, value)\n  }\n}\n\nfunction fillEmptyReference<V extends MapValue>(\n  entry: EmptyMapEntry<V>,\n  value: V\n): void {\n  // This value may already be in the map at a different keypath.\n  // Grab a reference before we overwrite it.\n  const oldEntry = value.ref\n\n  const fullEntry: FullMapEntry<V> = entry as any\n  fullEntry.value = value\n  value.ref = fullEntry\n\n  updateLruSize(fullEntry, value.size)\n\n  if (oldEntry !== null && oldEntry !== entry && oldEntry.value === value) {\n    // This value is already in the map at a different keypath in the map.\n    // Values only exist at a single keypath at a time. Remove it from the\n    // previous keypath.\n    //\n    // Note that only the internal map entry is garbage collected; we don't\n    // call `dropRef` here because it's still in the map, just\n    // at a new keypath (the one we just set, above).\n    deleteMapEntry(oldEntry)\n  }\n}\n\nexport function deleteFromCacheMap<V extends MapValue>(value: V): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n\n  dropRef(value)\n  deleteMapEntry(entry)\n}\n\nfunction dropRef<V extends MapValue>(value: V): void {\n  // Drop the value from the map by setting its `ref` backpointer to\n  // null. This is a separate operation from `deleteMapEntry` because when\n  // re-keying a value we need to be able to delete the old, internal map\n  // entry without garbage collecting the value itself.\n  value.ref = null\n}\n\nfunction deleteMapEntry<V extends MapValue>(entry: MapEntry<V>): void {\n  // Delete the entry from the cache.\n  const emptyEntry: EmptyMapEntry<V> = entry as any\n  emptyEntry.value = null\n\n  deleteFromLru(entry)\n\n  // Check if we can garbage collect the entry.\n  const map = emptyEntry.map\n  if (map === null) {\n    // Since this entry has no value, and also no child entries, we can\n    // garbage collect it. Remove it from its parent, and keep garbage\n    // collecting the parents until we reach a non-empty entry.\n    let parent = emptyEntry.parent\n    let key = emptyEntry.key\n    while (parent !== null) {\n      const parentMap = parent.map\n      if (parentMap !== null) {\n        parentMap.delete(key)\n        if (parentMap.size === 0) {\n          // We just removed the last entry in the parent map.\n          parent.map = null\n          if (parent.value === null) {\n            // The parent node has no child entries, nor does it have a value\n            // on itself. It can be garbage collected. Keep going.\n            key = parent.key\n            parent = parent.parent\n            continue\n          }\n        }\n      }\n      // The parent is not empty. Stop garbage collecting.\n      break\n    }\n  } else {\n    // Check if there's a revalidating entry. If so, promote it to a\n    // \"normal\" entry, since the normal one was just deleted.\n    const revalidatingEntry = map.get(Revalidation)\n    if (revalidatingEntry !== undefined && revalidatingEntry.value !== null) {\n      setMapEntryValue(emptyEntry, revalidatingEntry.value)\n    }\n  }\n}\n\nexport function setSizeInCacheMap<V extends MapValue>(\n  value: V,\n  size: number\n): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n  // Except during initialization (when the size is set to 0), this is the only\n  // place the `size` field should be updated, to ensure it's in sync with the\n  // the LRU.\n  value.size = size\n  updateLruSize(entry, size)\n}\n","import { FetchStrategy } from './types'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n  NormalizedNextUrl,\n} from './cache-key'\nimport type { RouteTree } from './cache'\nimport { Fallback, type FallbackType } from './cache-map'\nimport { HEAD_REQUEST_KEY } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\ntype Opaque<T, K> = T & { __brand: K }\n\n/**\n * A linked-list of all the params (or other param-like) inputs that a cache\n * entry may vary by. This is used by the CacheMap module to reuse cache entries\n * across different param values. If a param has a value of Fallback, it means\n * the cache entry is reusable for all possible values of that param. See\n * cache-map.ts for details.\n *\n * A segment's vary path is a pure function of a segment's position in a\n * particular route tree and the (post-rewrite) URL that is being queried. More\n * concretely, successive queries of the cache for the same segment always use\n * the same vary path.\n *\n * A route's vary path is simpler: it's comprised of the pathname, search\n * string, and Next-URL header.\n */\nexport type VaryPath = {\n  value: string | null | FallbackType\n  parent: VaryPath | null\n}\n\n// Because it's so important for vary paths to line up across cache accesses,\n// we use opaque type aliases to ensure these are only created within\n// this module.\n\n// requestKey -> searchParams -> nextUrl\nexport type RouteVaryPath = Opaque<\n  {\n    value: NormalizedPathname\n    parent: {\n      value: NormalizedSearch\n      parent: {\n        value: NormalizedNextUrl | null | FallbackType\n        parent: null\n      }\n    }\n  },\n  'RouteVaryPath'\n>\n\n// requestKey -> pathParams\nexport type LayoutVaryPath = Opaque<\n  {\n    value: string\n    parent: PartialSegmentVaryPath | null\n  },\n  'LayoutVaryPath'\n>\n\n// requestKey -> searchParams -> pathParams\nexport type PageVaryPath = Opaque<\n  {\n    value: string\n    parent: {\n      value: NormalizedSearch | FallbackType\n      parent: PartialSegmentVaryPath | null\n    }\n  },\n  'PageVaryPath'\n>\n\nexport type SegmentVaryPath = LayoutVaryPath | PageVaryPath\n\n// Intermediate type used when building a vary path during a recursive traversal\n// of the route tree.\nexport type PartialSegmentVaryPath = Opaque<VaryPath, 'PartialSegmentVaryPath'>\n\nexport function getRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null\n): RouteVaryPath {\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    value: pathname,\n    parent: {\n      value: search,\n      parent: {\n        value: nextUrl,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function getFulfilledRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null,\n  couldBeIntercepted: boolean\n): RouteVaryPath {\n  // This is called when a route's data is fulfilled. The cache entry will be\n  // re-keyed based on which inputs the response varies by.\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    value: pathname,\n    parent: {\n      value: search,\n      parent: {\n        value: couldBeIntercepted ? nextUrl : Fallback,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function appendLayoutVaryPath(\n  parentPath: PartialSegmentVaryPath | null,\n  cacheKey: string\n): PartialSegmentVaryPath {\n  const varyPathPart: VaryPath = {\n    value: cacheKey,\n    parent: parentPath,\n  }\n  return varyPathPart as PartialSegmentVaryPath\n}\n\nexport function finalizeLayoutVaryPath(\n  requestKey: string,\n  varyPath: PartialSegmentVaryPath | null\n): LayoutVaryPath {\n  const layoutVaryPath: VaryPath = {\n    value: requestKey,\n    parent: varyPath,\n  }\n  return layoutVaryPath as LayoutVaryPath\n}\n\nexport function finalizePageVaryPath(\n  requestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // Unlike layouts, a page segment's vary path also includes the search string.\n  // requestKey -> searchParams -> pathParams\n  const pageVaryPath: VaryPath = {\n    value: requestKey,\n    parent: {\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function finalizeMetadataVaryPath(\n  pageRequestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // The metadata \"segment\" is not a real segment because it doesn't exist in\n  // the normal structure of the route tree, but in terms of caching, it\n  // behaves like a page segment because it varies by all the same params as\n  // a page.\n  //\n  // To keep the protocol for querying the server simple, the request key for\n  // the metadata does not include any path information. It's unnecessary from\n  // the server's perspective, because unlike page segments, there's only one\n  // metadata response per URL, i.e. there's no need to distinguish multiple\n  // parallel pages.\n  //\n  // However, this means the metadata request key is insufficient for\n  // caching the the metadata in the client cache, because on the client we\n  // use the request key to distinguish the metadata entry from all other\n  // page's metadata entries.\n  //\n  // So instead we create a simulated request key based on the page segment.\n  // Conceptually this is equivalent to the request key the server would have\n  // assigned the metadata segment if it treated it as part of the actual\n  // route structure.\n\n  // If there are multiple parallel pages, we use whichever is the first one.\n  // This is fine because the only difference between request keys for\n  // different parallel pages are things like route groups and parallel\n  // route slots. As long as it's always the same one, it doesn't matter.\n  const pageVaryPath: VaryPath = {\n    // Append the actual metadata request key to the page request key. Note\n    // that we're not using a separate vary path part; it's unnecessary because\n    // these are not conceptually separate inputs.\n    value: pageRequestKey + HEAD_REQUEST_KEY,\n    parent: {\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function getSegmentVaryPathForRequest(\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentVaryPath {\n  // This is used for storing pending requests in the cache. We want to choose\n  // the most generic vary path based on the strategy used to fetch it, i.e.\n  // static/PPR versus runtime prefetching, so that it can be reused as much\n  // as possible.\n  //\n  // We may be able to re-key the response to something even more generic once\n  // we receive it — for example, if the server tells us that the response\n  // doesn't vary on a particular param — but even before we send the request,\n  // we know some params are reusable based on the fetch strategy alone. For\n  // example, a static prefetch will never vary on search params.\n  //\n  // The original vary path with all the params filled in is stored on the\n  // route tree object. We will clone this one to create a new vary path\n  // where certain params are replaced with Fallback.\n  //\n  // This result of this function is not stored anywhere. It's only used to\n  // access the cache a single time.\n  //\n  // TODO: Rather than create a new list object just to access the cache, the\n  // plan is to add the concept of a \"vary mask\". This will represent all the\n  // params that can be treated as Fallback. (Or perhaps the inverse.)\n  const originalVaryPath = tree.varyPath\n\n  // Only page segments (and the special \"metadata\" segment, which is treated\n  // like a page segment for the purposes of caching) may contain search\n  // params. There's no reason to include them in the vary path otherwise.\n  if (tree.isPage) {\n    // Only a runtime prefetch will include search params in the vary path.\n    // Static prefetches never include search params, so they can be reused\n    // across all possible search param values.\n    const doesVaryOnSearchParams =\n      fetchStrategy === FetchStrategy.Full ||\n      fetchStrategy === FetchStrategy.PPRRuntime\n\n    if (!doesVaryOnSearchParams) {\n      // The response from the the server will not vary on search params. Clone\n      // the end of the original vary path to replace the search params\n      // with Fallback.\n      //\n      // requestKey -> searchParams -> pathParams\n      //               ^ This part gets replaced with Fallback\n      const searchParamsVaryPath = (originalVaryPath as PageVaryPath).parent\n      const pathParamsVaryPath = searchParamsVaryPath.parent\n      const patchedVaryPath: VaryPath = {\n        value: originalVaryPath.value,\n        parent: {\n          value: Fallback,\n          parent: pathParamsVaryPath,\n        },\n      }\n      return patchedVaryPath as SegmentVaryPath\n    }\n  }\n\n  // The request does vary on search params. We don't need to modify anything.\n  return originalVaryPath as SegmentVaryPath\n}\n\nexport function clonePageVaryPathWithNewSearchParams(\n  originalVaryPath: PageVaryPath,\n  newSearch: NormalizedSearch\n): PageVaryPath {\n  // requestKey -> searchParams -> pathParams\n  //               ^ This part gets replaced with newSearch\n  const searchParamsVaryPath = originalVaryPath.parent\n  const clonedVaryPath: VaryPath = {\n    value: originalVaryPath.value,\n    parent: {\n      value: newSearch,\n      parent: searchParamsVaryPath.parent,\n    },\n  }\n  return clonedVaryPath as PageVaryPath\n}\n","// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\n// Only functions in this module should be allowed to create CacheKeys.\nexport type NormalizedPathname = Opaque<'NormalizedPathname', string>\nexport type NormalizedSearch = Opaque<'NormalizedSearch', string>\nexport type NormalizedNextUrl = Opaque<'NormalizedNextUrl', string>\n\nexport type RouteCacheKey = Opaque<\n  'RouteCacheKey',\n  {\n    pathname: NormalizedPathname\n    search: NormalizedSearch\n    nextUrl: NormalizedNextUrl | null\n\n    // TODO: Eventually the dynamic params will be added here, too.\n  }\n>\n\nexport function createCacheKey(\n  originalHref: string,\n  nextUrl: string | null\n): RouteCacheKey {\n  const originalUrl = new URL(originalHref)\n  const cacheKey = {\n    pathname: originalUrl.pathname as NormalizedPathname,\n    search: originalUrl.search as NormalizedSearch,\n    nextUrl: nextUrl as NormalizedNextUrl | null,\n  } as RouteCacheKey\n  return cacheKey\n}\n","import type {\n  FlightRouterState,\n  Segment as FlightRouterStateSegment,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport { matchSegment } from '../match-segments'\nimport {\n  readOrCreateRouteCacheEntry,\n  readOrCreateSegmentCacheEntry,\n  fetchRouteOnCacheMiss,\n  fetchSegmentOnCacheMiss,\n  EntryStatus,\n  type FulfilledRouteCacheEntry,\n  type RouteCacheEntry,\n  type SegmentCacheEntry,\n  type RouteTree,\n  fetchSegmentPrefetchesUsingDynamicRequest,\n  type PendingSegmentCacheEntry,\n  convertRouteTreeToFlightRouterState,\n  readOrCreateRevalidatingSegmentEntry,\n  upsertSegmentEntry,\n  type FulfilledSegmentCacheEntry,\n  upgradeToPendingSegment,\n  waitForSegmentCacheEntry,\n  overwriteRevalidatingSegmentCacheEntry,\n  canNewFetchStrategyProvideMoreContent,\n} from './cache'\nimport { getSegmentVaryPathForRequest, type SegmentVaryPath } from './vary-path'\nimport type { RouteCacheKey } from './cache-key'\nimport { createCacheKey } from './cache-key'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './types'\nimport { getCurrentCacheVersion } from './cache'\nimport {\n  addSearchParamsIfPageSegment,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport type { SegmentRequestKey } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\nconst scheduleMicrotask =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : (fn: () => unknown) =>\n        Promise.resolve()\n          .then(fn)\n          .catch((error) =>\n            setTimeout(() => {\n              throw error\n            })\n          )\n\nexport type PrefetchTask = {\n  key: RouteCacheKey\n\n  /**\n   * The FlightRouterState at the time the task was initiated. This is needed\n   * when falling back to the non-PPR behavior, which only prefetches up to\n   * the first loading boundary.\n   */\n  treeAtTimeOfPrefetch: FlightRouterState\n\n  /**\n   * The cache version at the time the task was initiated. This is used to\n   * determine if the cache was invalidated since the task was initiated.\n   */\n  cacheVersion: number\n\n  /**\n   * Whether to prefetch dynamic data, in addition to static data. This is\n   * used by `<Link prefetch={true}>`.\n   *\n   * Note that a task with `FetchStrategy.PPR` might need to use\n   * `FetchStrategy.LoadingBoundary` instead if we find out that a route\n   * does not support PPR after doing the initial route prefetch.\n   */\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  /**\n   * sortId is an incrementing counter\n   *\n   * Newer prefetches are prioritized over older ones, so that as new links\n   * enter the viewport, they are not starved by older links that are no\n   * longer relevant. In the future, we can add additional prioritization\n   * heuristics, like removing prefetches once a link leaves the viewport.\n   *\n   * The sortId is assigned when the prefetch is initiated, and reassigned if\n   * the same task is prefetched again (effectively bumping it to the top of\n   * the queue).\n   *\n   * TODO: We can add additional fields here to indicate what kind of prefetch\n   * it is. For example, was it initiated by a link? Or was it an imperative\n   * call? If it was initiated by a link, we can remove it from the queue when\n   * the link leaves the viewport, but if it was an imperative call, then we\n   * should keep it in the queue until it's fulfilled.\n   *\n   * We can also add priority levels. For example, hovering over a link could\n   * increase the priority of its prefetch.\n   */\n  sortId: number\n\n  /**\n   * The priority of the task. Like sortId, this affects the task's position in\n   * the queue, so it must never be updated without resifting the heap.\n   */\n  priority: PrefetchPriority\n\n  /**\n   * The phase of the task. Tasks are split into multiple phases so that their\n   * priority can be adjusted based on what kind of work they're doing.\n   * Concretely, prefetching the route tree is higher priority than prefetching\n   * segment data.\n   */\n  phase: PrefetchPhase\n\n  /**\n   * These fields are temporary state for tracking the currently running task.\n   * They are reset after each iteration of the task queue.\n   */\n  hasBackgroundWork: boolean\n  spawnedRuntimePrefetches: Set<SegmentRequestKey> | null\n\n  /**\n   * True if the prefetch was cancelled.\n   */\n  isCanceled: boolean\n\n  /**\n   * The callback passed to `router.prefetch`, if given.\n   */\n  onInvalidate: null | (() => void)\n\n  /**\n   * The index of the task in the heap's backing array. Used to efficiently\n   * change the priority of a task by re-sifting it, which requires knowing\n   * where it is in the array. This is only used internally by the heap\n   * algorithm. The naive alternative is indexOf every time a task is queued,\n   * which has O(n) complexity.\n   *\n   * We also use this field to check whether a task is currently in the queue.\n   */\n  _heapIndex: number\n}\n\nconst enum PrefetchTaskExitStatus {\n  /**\n   * The task yielded because there are too many requests in progress.\n   */\n  InProgress,\n\n  /**\n   * The task is blocked. It needs more data before it can proceed.\n   *\n   * Currently the only reason this happens is we're still waiting to receive a\n   * route tree from the server, because we can't start prefetching the segments\n   * until we know what to prefetch.\n   */\n  Blocked,\n\n  /**\n   * There's nothing left to prefetch.\n   */\n  Done,\n}\n\n/**\n * Prefetch tasks are processed in two phases: first the route tree is fetched,\n * then the segments. We use this to priortize tasks that have not yet fetched\n * the route tree.\n */\nconst enum PrefetchPhase {\n  RouteTree = 1,\n  Segments = 0,\n}\n\nexport type PrefetchSubtaskResult<T> = {\n  /**\n   * A promise that resolves when the network connection is closed.\n   */\n  closed: Promise<void>\n  value: T\n}\n\nconst taskHeap: Array<PrefetchTask> = []\n\nlet inProgressRequests = 0\n\nlet sortIdCounter = 0\nlet didScheduleMicrotask = false\n\n// The most recently hovered (or touched, etc) link, i.e. the most recent task\n// scheduled at Intent priority. There's only ever a single task at Intent\n// priority at a time. We reserve special network bandwidth for this task only.\nlet mostRecentlyHoveredLink: PrefetchTask | null = null\n\n// CDN cache propagation delay after revalidation (in milliseconds)\nconst REVALIDATION_COOLDOWN_MS = 300\n\n// Timeout handle for the revalidation cooldown. When non-null, prefetch\n// requests are blocked to allow CDN cache propagation.\nlet revalidationCooldownTimeoutHandle: ReturnType<typeof setTimeout> | null =\n  null\n\n/**\n * Called by the cache when revalidation occurs. Starts a cooldown period\n * during which prefetch requests are blocked to allow CDN cache propagation.\n */\nexport function startRevalidationCooldown(): void {\n  // Clear any existing timeout in case multiple revalidations happen\n  // in quick succession.\n  if (revalidationCooldownTimeoutHandle !== null) {\n    clearTimeout(revalidationCooldownTimeoutHandle)\n  }\n\n  // Schedule the cooldown to expire after the delay.\n  revalidationCooldownTimeoutHandle = setTimeout(() => {\n    revalidationCooldownTimeoutHandle = null\n    // Retry the prefetch queue now that the cooldown has expired.\n    ensureWorkIsScheduled()\n  }, REVALIDATION_COOLDOWN_MS)\n}\n\nexport type IncludeDynamicData = null | 'full' | 'dynamic'\n\n/**\n * Initiates a prefetch task for the given URL. If a prefetch for the same URL\n * is already in progress, this will bump it to the top of the queue.\n *\n * This is not a user-facing function. By the time this is called, the href is\n * expected to be validated and normalized.\n *\n * @param key The RouteCacheKey to prefetch.\n * @param treeAtTimeOfPrefetch The app's current FlightRouterState\n * @param fetchStrategy Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n */\nexport function schedulePrefetchTask(\n  key: RouteCacheKey,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority,\n  onInvalidate: null | (() => void)\n): PrefetchTask {\n  // Spawn a new prefetch task\n  const task: PrefetchTask = {\n    key,\n    treeAtTimeOfPrefetch,\n    cacheVersion: getCurrentCacheVersion(),\n    priority,\n    phase: PrefetchPhase.RouteTree,\n    hasBackgroundWork: false,\n    spawnedRuntimePrefetches: null,\n    fetchStrategy,\n    sortId: sortIdCounter++,\n    isCanceled: false,\n    onInvalidate,\n    _heapIndex: -1,\n  }\n\n  trackMostRecentlyHoveredLink(task)\n\n  heapPush(taskHeap, task)\n\n  // Schedule an async task to process the queue.\n  //\n  // The main reason we process the queue in an async task is for batching.\n  // It's common for a single JS task/event to trigger multiple prefetches.\n  // By deferring to a microtask, we only process the queue once per JS task.\n  // If they have different priorities, it also ensures they are processed in\n  // the optimal order.\n  ensureWorkIsScheduled()\n\n  return task\n}\n\nexport function cancelPrefetchTask(task: PrefetchTask): void {\n  // Remove the prefetch task from the queue. If the task already completed,\n  // then this is a no-op.\n  //\n  // We must also explicitly mark the task as canceled so that a blocked task\n  // does not get added back to the queue when it's pinged by the network.\n  task.isCanceled = true\n  heapDelete(taskHeap, task)\n}\n\nexport function reschedulePrefetchTask(\n  task: PrefetchTask,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority\n): void {\n  // Bump the prefetch task to the top of the queue, as if it were a fresh\n  // task. This is essentially the same as canceling the task and scheduling\n  // a new one, except it reuses the original object.\n  //\n  // The primary use case is to increase the priority of a Link-initated\n  // prefetch on hover.\n\n  // Un-cancel the task, in case it was previously canceled.\n  task.isCanceled = false\n  task.phase = PrefetchPhase.RouteTree\n\n  // Assign a new sort ID to move it ahead of all other tasks at the same\n  // priority level. (Higher sort IDs are processed first.)\n  task.sortId = sortIdCounter++\n  task.priority =\n    // If this task is the most recently hovered link, maintain its\n    // Intent priority, even if the rescheduled priority is lower.\n    task === mostRecentlyHoveredLink ? PrefetchPriority.Intent : priority\n\n  task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch\n  task.fetchStrategy = fetchStrategy\n\n  trackMostRecentlyHoveredLink(task)\n\n  if (task._heapIndex !== -1) {\n    // The task is already in the queue.\n    heapResift(taskHeap, task)\n  } else {\n    heapPush(taskHeap, task)\n  }\n  ensureWorkIsScheduled()\n}\n\nexport function isPrefetchTaskDirty(\n  task: PrefetchTask,\n  nextUrl: string | null,\n  tree: FlightRouterState\n): boolean {\n  // This is used to quickly bail out of a prefetch task if the result is\n  // guaranteed to not have changed since the task was initiated. This is\n  // strictly an optimization — theoretically, if it always returned true, no\n  // behavior should change because a full prefetch task will effectively\n  // perform the same checks.\n  const currentCacheVersion = getCurrentCacheVersion()\n  return (\n    task.cacheVersion !== currentCacheVersion ||\n    task.treeAtTimeOfPrefetch !== tree ||\n    task.key.nextUrl !== nextUrl\n  )\n}\n\nfunction trackMostRecentlyHoveredLink(task: PrefetchTask) {\n  // Track the mostly recently hovered link, i.e. the most recently scheduled\n  // task at Intent priority. There must only be one such task at a time.\n  if (\n    task.priority === PrefetchPriority.Intent &&\n    task !== mostRecentlyHoveredLink\n  ) {\n    if (mostRecentlyHoveredLink !== null) {\n      // Bump the previously hovered link's priority down to Default.\n      if (mostRecentlyHoveredLink.priority !== PrefetchPriority.Background) {\n        mostRecentlyHoveredLink.priority = PrefetchPriority.Default\n        heapResift(taskHeap, mostRecentlyHoveredLink)\n      }\n    }\n    mostRecentlyHoveredLink = task\n  }\n}\n\nfunction ensureWorkIsScheduled() {\n  if (didScheduleMicrotask) {\n    // Already scheduled a task to process the queue\n    return\n  }\n  didScheduleMicrotask = true\n  scheduleMicrotask(processQueueInMicrotask)\n}\n\n/**\n * Checks if we've exceeded the maximum number of concurrent prefetch requests,\n * to avoid saturating the browser's internal network queue. This is a\n * cooperative limit — prefetch tasks should check this before issuing\n * new requests.\n *\n * Also checks if we're within the revalidation cooldown window, during which\n * prefetch requests are delayed to allow CDN cache propagation.\n */\nfunction hasNetworkBandwidth(task: PrefetchTask): boolean {\n  // Check if we're within the revalidation cooldown window\n  if (revalidationCooldownTimeoutHandle !== null) {\n    // We're within the cooldown window. Return false to prevent prefetching.\n    // When the cooldown expires, the timeout will call ensureWorkIsScheduled()\n    // to retry the queue.\n    return false\n  }\n\n  // TODO: Also check if there's an in-progress navigation. We should never\n  // add prefetch requests to the network queue if an actual navigation is\n  // taking place, to ensure there's sufficient bandwidth for render-blocking\n  // data and resources.\n\n  // TODO: Consider reserving some amount of bandwidth for static prefetches.\n\n  if (task.priority === PrefetchPriority.Intent) {\n    // The most recently hovered link is allowed to exceed the default limit.\n    //\n    // The goal is to always have enough bandwidth to start a new prefetch\n    // request when hovering over a link.\n    //\n    // However, because we don't abort in-progress requests, it's still possible\n    // we'll run out of bandwidth. When links are hovered in quick succession,\n    // there could be multiple hover requests running simultaneously.\n    return inProgressRequests < 12\n  }\n\n  // The default limit is lower than the limit for a hovered link.\n  return inProgressRequests < 4\n}\n\nfunction spawnPrefetchSubtask<T>(\n  prefetchSubtask: Promise<PrefetchSubtaskResult<T> | null>\n): Promise<T | null> {\n  // When the scheduler spawns an async task, we don't await its result.\n  // Instead, the async task writes its result directly into the cache, then\n  // pings the scheduler to continue.\n  //\n  // We process server responses streamingly, so the prefetch subtask will\n  // likely resolve before we're finished receiving all the data. The subtask\n  // result includes a promise that resolves once the network connection is\n  // closed. The scheduler uses this to control network bandwidth by tracking\n  // and limiting the number of concurrent requests.\n  inProgressRequests++\n  return prefetchSubtask.then((result) => {\n    if (result === null) {\n      // The prefetch task errored before it could start processing the\n      // network stream. Assume the connection is closed.\n      onPrefetchConnectionClosed()\n      return null\n    }\n    // Wait for the connection to close before freeing up more bandwidth.\n    result.closed.then(onPrefetchConnectionClosed)\n    return result.value\n  })\n}\n\nfunction onPrefetchConnectionClosed(): void {\n  inProgressRequests--\n\n  // Notify the scheduler that we have more bandwidth, and can continue\n  // processing tasks.\n  ensureWorkIsScheduled()\n}\n\n/**\n * Notify the scheduler that we've received new data for an in-progress\n * prefetch. The corresponding task will be added back to the queue (unless the\n * task has been canceled in the meantime).\n */\nexport function pingPrefetchTask(task: PrefetchTask) {\n  // \"Ping\" a prefetch that's already in progress to notify it of new data.\n  if (\n    // Check if prefetch was canceled.\n    task.isCanceled ||\n    // Check if prefetch is already queued.\n    task._heapIndex !== -1\n  ) {\n    return\n  }\n  // Add the task back to the queue.\n  heapPush(taskHeap, task)\n  ensureWorkIsScheduled()\n}\n\nfunction processQueueInMicrotask() {\n  didScheduleMicrotask = false\n\n  // We aim to minimize how often we read the current time. Since nearly all\n  // functions in the prefetch scheduler are synchronous, we can read the time\n  // once and pass it as an argument wherever it's needed.\n  const now = Date.now()\n\n  // Process the task queue until we run out of network bandwidth.\n  let task = heapPeek(taskHeap)\n  while (task !== null && hasNetworkBandwidth(task)) {\n    task.cacheVersion = getCurrentCacheVersion()\n\n    const exitStatus = pingRoute(now, task)\n\n    // These fields are only valid for a single attempt. Reset them after each\n    // iteration of the task queue.\n    const hasBackgroundWork = task.hasBackgroundWork\n    task.hasBackgroundWork = false\n    task.spawnedRuntimePrefetches = null\n\n    switch (exitStatus) {\n      case PrefetchTaskExitStatus.InProgress:\n        // The task yielded because there are too many requests in progress.\n        // Stop processing tasks until we have more bandwidth.\n        return\n      case PrefetchTaskExitStatus.Blocked:\n        // The task is blocked. It needs more data before it can proceed.\n        // Keep the task out of the queue until the server responds.\n        heapPop(taskHeap)\n        // Continue to the next task\n        task = heapPeek(taskHeap)\n        continue\n      case PrefetchTaskExitStatus.Done:\n        if (task.phase === PrefetchPhase.RouteTree) {\n          // Finished prefetching the route tree. Proceed to prefetching\n          // the segments.\n          task.phase = PrefetchPhase.Segments\n          heapResift(taskHeap, task)\n        } else if (hasBackgroundWork) {\n          // The task spawned additional background work. Reschedule the task\n          // at background priority.\n          task.priority = PrefetchPriority.Background\n          heapResift(taskHeap, task)\n        } else {\n          // The prefetch is complete. Continue to the next task.\n          heapPop(taskHeap)\n        }\n        task = heapPeek(taskHeap)\n        continue\n      default:\n        exitStatus satisfies never\n    }\n  }\n}\n\n/**\n * Check this during a prefetch task to determine if background work can be\n * performed. If so, it evaluates to `true`. Otherwise, it returns `false`,\n * while also scheduling a background task to run later. Usage:\n *\n * @example\n * if (background(task)) {\n *   // Perform background-pri work\n * }\n */\nfunction background(task: PrefetchTask): boolean {\n  if (task.priority === PrefetchPriority.Background) {\n    return true\n  }\n  task.hasBackgroundWork = true\n  return false\n}\n\nfunction pingRoute(now: number, task: PrefetchTask): PrefetchTaskExitStatus {\n  const key = task.key\n  const route = readOrCreateRouteCacheEntry(now, task, key)\n  const exitStatus = pingRootRouteTree(now, task, route)\n\n  if (exitStatus !== PrefetchTaskExitStatus.InProgress && key.search !== '') {\n    // If the URL has a non-empty search string, also prefetch the pathname\n    // without the search string. We use the searchless route tree as a base for\n    // optimistic routing; see requestOptimisticRouteCacheEntry for details.\n    //\n    // Note that we don't need to prefetch any of the segment data. Just the\n    // route tree.\n    //\n    // TODO: This is a temporary solution; the plan is to replace this by adding\n    // a wildcard lookup method to the TupleMap implementation. This is\n    // non-trivial to implement because it needs to account for things like\n    // fallback route entries, hence this temporary workaround.\n    const url = new URL(key.pathname, location.origin)\n    const keyWithoutSearch = createCacheKey(url.href, key.nextUrl)\n    const routeWithoutSearch = readOrCreateRouteCacheEntry(\n      now,\n      task,\n      keyWithoutSearch\n    )\n    switch (routeWithoutSearch.status) {\n      case EntryStatus.Empty: {\n        if (background(task)) {\n          routeWithoutSearch.status = EntryStatus.Pending\n          spawnPrefetchSubtask(\n            fetchRouteOnCacheMiss(routeWithoutSearch, task, keyWithoutSearch)\n          )\n        }\n        break\n      }\n      case EntryStatus.Pending:\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected: {\n        // Either the route tree is already cached, or there's already a\n        // request in progress. Since we don't need to fetch any segment data\n        // for this route, there's nothing left to do.\n        break\n      }\n      default:\n        routeWithoutSearch satisfies never\n    }\n  }\n\n  return exitStatus\n}\n\nfunction pingRootRouteTree(\n  now: number,\n  task: PrefetchTask,\n  route: RouteCacheEntry\n): PrefetchTaskExitStatus {\n  switch (route.status) {\n    case EntryStatus.Empty: {\n      // Route is not yet cached, and there's no request already in progress.\n      // Spawn a task to request the route, load it into the cache, and ping\n      // the task to continue.\n\n      // TODO: There are multiple strategies in the <Link> API for prefetching\n      // a route. Currently we've only implemented the main one: per-segment,\n      // static-data only.\n      //\n      // There's also `<Link prefetch={true}>`\n      // which prefetch both static *and* dynamic data.\n      // Similarly, we need to fallback to the old, per-page\n      // behavior if PPR is disabled for a route (via the incremental opt-in).\n      //\n      // Those cases will be handled here.\n      spawnPrefetchSubtask(fetchRouteOnCacheMiss(route, task, task.key))\n\n      // If the request takes longer than a minute, a subsequent request should\n      // retry instead of waiting for this one. When the response is received,\n      // this value will be replaced by a new value based on the stale time sent\n      // from the server.\n      // TODO: We should probably also manually abort the fetch task, to reclaim\n      // server bandwidth.\n      route.staleAt = now + 60 * 1000\n\n      // Upgrade to Pending so we know there's already a request in progress\n      route.status = EntryStatus.Pending\n\n      // Intentional fallthrough to the Pending branch\n    }\n    case EntryStatus.Pending: {\n      // Still pending. We can't start prefetching the segments until the route\n      // tree has loaded. Add the task to the set of blocked tasks so that it\n      // is notified when the route tree is ready.\n      const blockedTasks = route.blockedTasks\n      if (blockedTasks === null) {\n        route.blockedTasks = new Set([task])\n      } else {\n        blockedTasks.add(task)\n      }\n      return PrefetchTaskExitStatus.Blocked\n    }\n    case EntryStatus.Rejected: {\n      // Route tree failed to load. Treat as a 404.\n      return PrefetchTaskExitStatus.Done\n    }\n    case EntryStatus.Fulfilled: {\n      if (task.phase !== PrefetchPhase.Segments) {\n        // Do not prefetch segment data until we've entered the segment phase.\n        return PrefetchTaskExitStatus.Done\n      }\n      // Recursively fill in the segment tree.\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const tree = route.tree\n\n      // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n      // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n      // We don't need to do this for runtime prefetches, because those are only available in\n      // `cacheComponents`, where every route is PPR.\n      const fetchStrategy =\n        task.fetchStrategy === FetchStrategy.PPR\n          ? route.isPPREnabled\n            ? FetchStrategy.PPR\n            : FetchStrategy.LoadingBoundary\n          : task.fetchStrategy\n\n      switch (fetchStrategy) {\n        case FetchStrategy.PPR: {\n          // For Cache Components pages, each segment may be prefetched\n          // statically or using a runtime request, based on various\n          // configurations and heuristics. We'll do this in two passes: first\n          // traverse the tree and perform all the static prefetches.\n          //\n          // Then, if there are any segments that need a runtime request,\n          // do another pass to perform a runtime prefetch.\n          pingStaticHead(now, task, route)\n          const exitStatus = pingSharedPartOfCacheComponentsTree(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree\n          )\n          if (exitStatus === PrefetchTaskExitStatus.InProgress) {\n            // Child yielded without finishing.\n            return PrefetchTaskExitStatus.InProgress\n          }\n          const spawnedRuntimePrefetches = task.spawnedRuntimePrefetches\n          if (spawnedRuntimePrefetches !== null) {\n            // During the first pass, we discovered segments that require a\n            // runtime prefetch. Do a second pass to construct a request tree.\n            const spawnedEntries = new Map<\n              SegmentRequestKey,\n              PendingSegmentCacheEntry\n            >()\n            pingRuntimeHead(\n              now,\n              task,\n              route,\n              spawnedEntries,\n              FetchStrategy.PPRRuntime\n            )\n            const requestTree = pingRuntimePrefetches(\n              now,\n              task,\n              route,\n              tree,\n              spawnedRuntimePrefetches,\n              spawnedEntries\n            )\n            let needsDynamicRequest = spawnedEntries.size > 0\n            if (needsDynamicRequest) {\n              // Perform a dynamic prefetch request and populate the cache with\n              // the result.\n              spawnPrefetchSubtask(\n                fetchSegmentPrefetchesUsingDynamicRequest(\n                  task,\n                  route,\n                  FetchStrategy.PPRRuntime,\n                  requestTree,\n                  spawnedEntries\n                )\n              )\n            }\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        case FetchStrategy.Full:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.LoadingBoundary: {\n          // Prefetch multiple segments using a single dynamic request.\n          // TODO: We can consolidate this branch with previous one by modeling\n          // it as if the first segment in the new tree has runtime prefetching\n          // enabled. Will do this as a follow-up refactor. Might want to remove\n          // the special metatdata case below first. In the meantime, it's not\n          // really that much duplication, just would be nice to remove one of\n          // these codepaths.\n          const spawnedEntries = new Map<\n            SegmentRequestKey,\n            PendingSegmentCacheEntry\n          >()\n          pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy)\n          const dynamicRequestTree = diffRouteTreeAgainstCurrent(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree,\n            spawnedEntries,\n            fetchStrategy\n          )\n          let needsDynamicRequest = spawnedEntries.size > 0\n          if (needsDynamicRequest) {\n            spawnPrefetchSubtask(\n              fetchSegmentPrefetchesUsingDynamicRequest(\n                task,\n                route,\n                fetchStrategy,\n                dynamicRequestTree,\n                spawnedEntries\n              )\n            )\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        default:\n          fetchStrategy satisfies never\n      }\n      break\n    }\n    default: {\n      route satisfies never\n    }\n  }\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingStaticHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry\n): void {\n  // The Head data for a page (metadata, viewport) is not really a route\n  // segment, in the sense that it doesn't appear in the route tree. But we\n  // store it in the cache as if it were, using a special key.\n  pingStaticSegmentData(\n    now,\n    task,\n    route,\n    readOrCreateSegmentCacheEntry(\n      now,\n      FetchStrategy.PPR,\n      route,\n      route.metadata\n    ),\n    task.key,\n    route.metadata\n  )\n}\n\nfunction pingRuntimeHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): void {\n  pingRouteTreeAndIncludeDynamicData(\n    now,\n    task,\n    route,\n    route.metadata,\n    false,\n    spawnedEntries,\n    // When prefetching the head, there's no difference between Full\n    // and LoadingBoundary\n    fetchStrategy === FetchStrategy.LoadingBoundary\n      ? FetchStrategy.Full\n      : fetchStrategy\n  )\n}\n\n// TODO: Rename dynamic -> runtime throughout this module\n\nfunction pingSharedPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree\n): PrefetchTaskExitStatus {\n  // When Cache Components is enabled (or PPR, or a fully static route when PPR\n  // is disabled; those cases are treated equivalently to Cache Components), we\n  // start by prefetching each segment individually. Once we reach the \"new\"\n  // part of the tree — the part that doesn't exist on the current page — we\n  // may choose to switch to a runtime prefetch instead, based on the\n  // information sent by the server in the route tree.\n  //\n  // The traversal starts in the \"shared\" part of the tree. Once we reach the\n  // \"new\" part of the tree, we switch to a different traversal,\n  // pingNewPartOfCacheComponentsTree.\n\n  // Prefetch this segment's static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    newTree\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, newTree)\n\n  // Recursively ping the children.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      let childExitStatus\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // We're still in the \"shared\" part of the tree.\n        childExitStatus = pingSharedPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild\n        )\n      } else {\n        // We've entered the \"new\" part of the tree. Switch\n        // traversal functions.\n        childExitStatus = pingNewPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          newTreeChild\n        )\n      }\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingNewPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): PrefetchTaskExitStatus.InProgress | PrefetchTaskExitStatus.Done {\n  // We're now prefetching in the \"new\" part of the tree, the part that doesn't\n  // exist on the current page. (In other words, we're deeper than the\n  // shared layouts.) Segments in here default to being prefetched statically.\n  // However, if the server instructs us to, we may switch to a runtime\n  // prefetch instead. Traverse the tree and check at each segment.\n  if (tree.hasRuntimePrefetch) {\n    // This route has a runtime prefetch response. Since we're below the shared\n    // layout, everything from this point should be prefetched using a single,\n    // combined runtime request, rather than using per-segment static requests.\n    // This is true even if some of the child segments are known to be fully\n    // static — once we've decided to perform a runtime prefetch, we might as\n    // well respond with the static segments in the same roundtrip. (That's how\n    // regular navigations work, too.) We'll still skip over segments that are\n    // already cached, though.\n    //\n    // It's the server's responsibility to set a reasonable value of\n    // `hasRuntimePrefetch`. Currently it's user-defined, but eventually, the\n    // server may send a value of `false` even if the user opts in, if it\n    // determines during build that the route is always fully static. There are\n    // more optimizations we can do once we implement fallback param\n    // tracking, too.\n    //\n    // Use the task object to collect the segments that need a runtime prefetch.\n    // This will signal to the outer task queue that a second traversal is\n    // required to construct a request tree.\n    if (task.spawnedRuntimePrefetches === null) {\n      task.spawnedRuntimePrefetches = new Set([tree.requestKey])\n    } else {\n      task.spawnedRuntimePrefetches.add(tree.requestKey)\n    }\n    // Then exit the traversal without prefetching anything further.\n    return PrefetchTaskExitStatus.Done\n  }\n\n  // This segment should not be runtime prefetched. Prefetch its static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    tree\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, tree)\n  if (tree.slots !== null) {\n    if (!hasNetworkBandwidth(task)) {\n      // Stop prefetching segments until there's more bandwidth.\n      return PrefetchTaskExitStatus.InProgress\n    }\n    // Recursively ping the children.\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      const childExitStatus = pingNewPartOfCacheComponentsTree(\n        now,\n        task,\n        route,\n        childTree\n      )\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n  // This segment and all its children have finished prefetching.\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction diffRouteTreeAgainstCurrent(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): FlightRouterState {\n  // This is a single recursive traversal that does multiple things:\n  // - Finds the parts of the target route (newTree) that are not part of\n  //   of the current page (oldTree) by diffing them, using the same algorithm\n  //   as a real navigation.\n  // - Constructs a request tree (FlightRouterState) that describes which\n  //   segments need to be prefetched and which ones are already cached.\n  // - Creates a set of pending cache entries for the segments that need to\n  //   be prefetched, so that a subsequent prefetch task does not request the\n  //   same segments again.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // This segment is already part of the current route. Keep traversing.\n        const requestTreeChild = diffRouteTreeAgainstCurrent(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild,\n          spawnedEntries,\n          fetchStrategy\n        )\n        requestTreeChildren[parallelRouteKey] = requestTreeChild\n      } else {\n        // This segment is not part of the current route. We're entering a\n        // part of the tree that we need to prefetch (unless everything is\n        // already cached).\n        switch (fetchStrategy) {\n          case FetchStrategy.LoadingBoundary: {\n            // When PPR is disabled, we can't prefetch per segment. We must\n            // fallback to the old prefetch behavior and send a dynamic request.\n            // Only routes that include a loading boundary can be prefetched in\n            // this way.\n            //\n            // This is simlar to a \"full\" prefetch, but we're much more\n            // conservative about which segments to include in the request.\n            //\n            // The server will only render up to the first loading boundary\n            // inside new part of the tree. If there's no loading boundary\n            // anywhere in the tree, the server will never return any data, so\n            // we can skip the request.\n            const subtreeHasLoadingBoundary =\n              newTreeChild.hasLoadingBoundary !==\n              HasLoadingBoundary.SubtreeHasNoLoadingBoundary\n            const requestTreeChild = subtreeHasLoadingBoundary\n              ? pingPPRDisabledRouteTreeUpToLoadingBoundary(\n                  now,\n                  task,\n                  route,\n                  newTreeChild,\n                  null,\n                  spawnedEntries\n                )\n              : // There's no loading boundary within this tree. Bail out.\n                convertRouteTreeToFlightRouterState(newTreeChild)\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.PPRRuntime: {\n            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n            // not just the static PPR shell.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.Full: {\n            // This is a \"full\" prefetch. Fetch all the data in the tree, both\n            // static and dynamic. We issue roughly the same request that we\n            // would during a real navigation. The goal is that once the\n            // navigation occurs, the router should not have to fetch any\n            // additional data.\n            //\n            // Although the response will include dynamic data, opting into a\n            // Full prefetch — via <Link prefetch={true}> — implicitly\n            // instructs the cache to treat the response as \"static\", or non-\n            // dynamic, since the whole point is to cache it for\n            // future navigations.\n            //\n            // Construct a tree (currently a FlightRouterState) that represents\n            // which segments need to be prefetched and which ones are already\n            // cached. If the tree is empty, then we can exit. Otherwise, we'll\n            // send the request tree to the server and use the response to\n            // populate the segment cache.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          default:\n            fetchStrategy satisfies never\n        }\n      }\n    }\n  }\n  const requestTree: FlightRouterState = [\n    newTree.segment,\n    requestTreeChildren,\n    null,\n    null,\n    newTree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingPPRDisabledRouteTreeUpToLoadingBoundary(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  refetchMarkerContext: 'refetch' | 'inside-shared-layout' | null,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n  // server is only going to return a minimal loading state — it will stop\n  // rendering at the first loading boundary. Whereas a Full prefetch is\n  // intentionally aggressive and tries to pretfetch all the data that will be\n  // needed for a navigation, a LoadingBoundary prefetch is much more\n  // conservative. For example, it will omit from the request tree any segment\n  // that is already cached, regardles of whether it's partial or full. By\n  // contrast, a Full prefetch will refetch partial segments.\n\n  // \"inside-shared-layout\" tells the server where to start looking for a\n  // loading boundary.\n  let refetchMarker: 'refetch' | 'inside-shared-layout' | null =\n    refetchMarkerContext === null ? 'inside-shared-layout' : null\n\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    tree\n  )\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Add a refetch marker so the server knows\n      // to start rendering here.\n      // TODO: Instead of a \"refetch\" marker, we could just omit this subtree's\n      // FlightRouterState from the request tree. I think this would probably\n      // already work even without any updates to the server. For consistency,\n      // though, I'll send the full tree and we'll look into this later as part\n      // of a larger redesign of the request protocol.\n\n      // Add the pending cache entry to the result map.\n      spawnedEntries.set(\n        tree.requestKey,\n        upgradeToPendingSegment(\n          segment,\n          // Set the fetch strategy to LoadingBoundary to indicate that the server\n          // might not include it in the pending response. If another route is able\n          // to issue a per-segment request, we'll do that in the background.\n          FetchStrategy.LoadingBoundary\n        )\n      )\n      if (refetchMarkerContext !== 'refetch') {\n        refetchMarker = refetchMarkerContext = 'refetch'\n      } else {\n        // There's already a parent with a refetch marker, so we don't need\n        // to add another one.\n      }\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      const segmentHasLoadingBoundary =\n        tree.hasLoadingBoundary === HasLoadingBoundary.SegmentHasLoadingBoundary\n      if (segmentHasLoadingBoundary) {\n        // This segment has a loading boundary, which means the server won't\n        // render its children. So there's nothing left to prefetch along this\n        // path. We can bail out.\n        return convertRouteTreeToFlightRouterState(tree)\n      }\n      // NOTE: If the cached segment were fetched using PPR, then it might be\n      // partial. We could get a more complete version of the segment by\n      // including it in this non-PPR request.\n      //\n      // We're intentionally choosing not to, though, because it's generally\n      // better to avoid doing a full prefetch whenever possible.\n      break\n    }\n    case EntryStatus.Pending: {\n      // There's another prefetch currently in progress. Don't add the refetch\n      // marker yet, so the server knows it can skip rendering this segment.\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The segment failed to load. We shouldn't issue another request until\n      // the stale time has elapsed.\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingPPRDisabledRouteTreeUpToLoadingBoundary(\n          now,\n          task,\n          route,\n          childTree,\n          refetchMarkerContext,\n          spawnedEntries\n        )\n    }\n  }\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRouteTreeAndIncludeDynamicData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  isInsideRefetchingParent: boolean,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): FlightRouterState {\n  // The tree we're constructing is the same shape as the tree we're navigating\n  // to. But even though this is a \"new\" tree, some of the individual segments\n  // may be cached as a result of other route prefetches.\n  //\n  // So we need to find the first uncached segment along each path add an\n  // explicit \"refetch\" marker so the server knows where to start rendering.\n  // Once the server starts rendering along a path, it keeps rendering the\n  // entire subtree.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    // Note that `fetchStrategy` might be different from `task.fetchStrategy`,\n    // and we have to use the former here.\n    // We can have a task with `FetchStrategy.PPR` where some of its segments are configured to\n    // always use runtime prefetching (via `export const prefetch`), and those should check for\n    // entries that include search params.\n    fetchStrategy,\n    route,\n    tree\n  )\n\n  let spawnedSegment: PendingSegmentCacheEntry | null = null\n\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Include it in the request.\n      spawnedSegment = upgradeToPendingSegment(segment, fetchStrategy)\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      if (\n        segment.isPartial &&\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n        // This means we're in one of these cases:\n        //   - we have a static prefetch, and we're doing a runtime prefetch\n        //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n        // In either case, we need to include it in the request to get a more specific (or full) version.\n        spawnedSegment = pingFullSegmentRevalidation(\n          now,\n          route,\n          tree,\n          fetchStrategy\n        )\n      }\n      break\n    }\n    case EntryStatus.Pending:\n    case EntryStatus.Rejected: {\n      // There's either another prefetch currently in progress, or the previous\n      // attempt failed. If the new strategy can provide more content, fetch it again.\n      if (\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        spawnedSegment = pingFullSegmentRevalidation(\n          now,\n          route,\n          tree,\n          fetchStrategy\n        )\n      }\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingRouteTreeAndIncludeDynamicData(\n          now,\n          task,\n          route,\n          childTree,\n          isInsideRefetchingParent || spawnedSegment !== null,\n          spawnedEntries,\n          fetchStrategy\n        )\n    }\n  }\n\n  if (spawnedSegment !== null) {\n    // Add the pending entry to the result map.\n    spawnedEntries.set(tree.requestKey, spawnedSegment)\n  }\n\n  // Don't bother to add a refetch marker if one is already present in a parent.\n  const refetchMarker =\n    !isInsideRefetchingParent && spawnedSegment !== null ? 'refetch' : null\n\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRuntimePrefetches(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  spawnedRuntimePrefetches: Set<SegmentRequestKey>,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n  // a segment is part of the runtime prefetch, the tree is constructed by\n  // diffing against what's already in the prefetch cache. Otherwise, we send\n  // a regular FlightRouterState with no special markers.\n  //\n  // See pingRouteTreeAndIncludeDynamicData for details.\n  if (spawnedRuntimePrefetches.has(tree.requestKey)) {\n    // This segment needs a runtime prefetch.\n    return pingRouteTreeAndIncludeDynamicData(\n      now,\n      task,\n      route,\n      tree,\n      false,\n      spawnedEntries,\n      FetchStrategy.PPRRuntime\n    )\n  }\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] = pingRuntimePrefetches(\n        now,\n        task,\n        route,\n        childTree,\n        spawnedRuntimePrefetches,\n        spawnedEntries\n      )\n    }\n  }\n\n  // This segment is not part of the runtime prefetch. Clone the base tree.\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    null,\n  ]\n  return requestTree\n}\n\nfunction pingStaticSegmentData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  segment: SegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  switch (segment.status) {\n    case EntryStatus.Empty:\n      // Upgrade to Pending so we know there's already a request in progress\n      spawnPrefetchSubtask(\n        fetchSegmentOnCacheMiss(\n          route,\n          upgradeToPendingSegment(segment, FetchStrategy.PPR),\n          routeKey,\n          tree\n        )\n      )\n      break\n    case EntryStatus.Pending: {\n      // There's already a request in progress. Depending on what kind of\n      // request it is, we may want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // There's already a request in progress. Don't do anything.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a pending request, but because it's using the old\n          // prefetching strategy, we can't be sure if it will be fulfilled by\n          // the response — it might be inside the loading boundary. Perform\n          // a revalidation, but because it's speculative, wait to do it at\n          // background priority.\n          if (background(task)) {\n            // TODO: Instead of speculatively revalidating, consider including\n            // `hasLoading` in the route tree prefetch response.\n            pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          }\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The existing entry in the cache was rejected. Depending on how it\n      // was originally fetched, we may or may not want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // The previous attempt to fetch this entry failed. Don't attempt to\n          // fetch it again until the entry expires.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a rejected entry, but it was fetched using the loading\n          // boundary strategy. So the reason it wasn't returned by the server\n          // might just be because it was inside a loading boundary. Or because\n          // there was a dynamic rewrite. Revalidate it using the per-\n          // segment strategy.\n          //\n          // Because a rejected segment will definitely prevent the segment (and\n          // all of its children) from rendering, we perform this revalidation\n          // immediately instead of deferring it to a background task.\n          pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Fulfilled:\n      // Segment is already cached. There's nothing left to prefetch.\n      break\n    default:\n      segment satisfies never\n  }\n\n  // Segments do not have dependent tasks, so once the prefetch is initiated,\n  // there's nothing else for us to do (except write the server data into the\n  // entry, which is handled by `fetchSegmentOnCacheMiss`).\n}\n\nfunction pingPPRSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    FetchStrategy.PPR,\n    route,\n    tree\n  )\n  switch (revalidatingSegment.status) {\n    case EntryStatus.Empty:\n      // Spawn a prefetch request and upsert the segment into the cache\n      // upon completion.\n      upsertSegmentOnCompletion(\n        spawnPrefetchSubtask(\n          fetchSegmentOnCacheMiss(\n            route,\n            upgradeToPendingSegment(revalidatingSegment, FetchStrategy.PPR),\n            routeKey,\n            tree\n          )\n        ),\n        getSegmentVaryPathForRequest(FetchStrategy.PPR, tree)\n      )\n      break\n    case EntryStatus.Pending:\n      // There's already a revalidation in progress.\n      break\n    case EntryStatus.Fulfilled:\n    case EntryStatus.Rejected:\n      // A previous revalidation attempt finished, but we chose not to replace\n      // the existing entry in the cache. Don't try again until or unless the\n      // revalidation entry expires.\n      break\n    default:\n      revalidatingSegment satisfies never\n  }\n}\n\nfunction pingFullSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): PendingSegmentCacheEntry | null {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    fetchStrategy,\n    route,\n    tree\n  )\n  if (revalidatingSegment.status === EntryStatus.Empty) {\n    // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n    // segments that we need. So we don't initiate a request here directly. By\n    // returning a pending entry from this function, it signals to the caller\n    // that this segment should be included in the request that's sent to\n    // the server.\n    const pendingSegment = upgradeToPendingSegment(\n      revalidatingSegment,\n      fetchStrategy\n    )\n    upsertSegmentOnCompletion(\n      waitForSegmentCacheEntry(pendingSegment),\n      getSegmentVaryPathForRequest(fetchStrategy, tree)\n    )\n    return pendingSegment\n  } else {\n    // There's already a revalidation in progress.\n    const nonEmptyRevalidatingSegment = revalidatingSegment\n    if (\n      canNewFetchStrategyProvideMoreContent(\n        nonEmptyRevalidatingSegment.fetchStrategy,\n        fetchStrategy\n      )\n    ) {\n      // The existing revalidation was fetched using a less specific strategy.\n      // Reset it and start a new revalidation.\n      const emptySegment = overwriteRevalidatingSegmentCacheEntry(\n        fetchStrategy,\n        route,\n        tree\n      )\n      const pendingSegment = upgradeToPendingSegment(\n        emptySegment,\n        fetchStrategy\n      )\n      upsertSegmentOnCompletion(\n        waitForSegmentCacheEntry(pendingSegment),\n        getSegmentVaryPathForRequest(fetchStrategy, tree)\n      )\n      return pendingSegment\n    }\n    switch (nonEmptyRevalidatingSegment.status) {\n      case EntryStatus.Pending:\n        // There's already an in-progress prefetch that includes this segment.\n        return null\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected:\n        // A previous revalidation attempt finished, but we chose not to replace\n        // the existing entry in the cache. Don't try again until or unless the\n        // revalidation entry expires.\n        return null\n      default:\n        nonEmptyRevalidatingSegment satisfies never\n        return null\n    }\n  }\n}\n\nconst noop = () => {}\n\nfunction upsertSegmentOnCompletion(\n  promise: Promise<FulfilledSegmentCacheEntry | null>,\n  varyPath: SegmentVaryPath\n) {\n  // Wait for a segment to finish loading, then upsert it into the cache\n  promise.then((fulfilled) => {\n    if (fulfilled !== null) {\n      // Received new data. Attempt to replace the existing entry in the cache.\n      upsertSegmentEntry(Date.now(), varyPath, fulfilled)\n    }\n  }, noop)\n}\n\nfunction doesCurrentSegmentMatchCachedSegment(\n  route: FulfilledRouteCacheEntry,\n  currentSegment: Segment,\n  cachedSegment: Segment\n): boolean {\n  if (cachedSegment === PAGE_SEGMENT_KEY) {\n    // In the FlightRouterState stored by the router, the page segment has the\n    // rendered search params appended to the name of the segment. In the\n    // prefetch cache, however, this is stored separately. So, when comparing\n    // the router's current FlightRouterState to the cached FlightRouterState,\n    // we need to make sure we compare both parts of the segment.\n    // TODO: This is not modeled clearly. We use the same type,\n    // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n    // _and_ the server response format, when conceptually those are three\n    // different things and treated in different ways. We should encode more of\n    // this information into the type design so mistakes are less likely.\n    return (\n      currentSegment ===\n      addSearchParamsIfPageSegment(\n        PAGE_SEGMENT_KEY,\n        Object.fromEntries(new URLSearchParams(route.renderedSearch))\n      )\n    )\n  }\n  // Non-page segments are compared using the same function as the server\n  return matchSegment(cachedSegment, currentSegment)\n}\n\n// -----------------------------------------------------------------------------\n// The remainder of the module is a MinHeap implementation. Try not to put any\n// logic below here unless it's related to the heap algorithm. We can extract\n// this to a separate module if/when we need multiple kinds of heaps.\n// -----------------------------------------------------------------------------\n\nfunction compareQueuePriority(a: PrefetchTask, b: PrefetchTask) {\n  // Since the queue is a MinHeap, this should return a positive number if b is\n  // higher priority than a, and a negative number if a is higher priority\n  // than b.\n\n  // `priority` is an integer, where higher numbers are higher priority.\n  const priorityDiff = b.priority - a.priority\n  if (priorityDiff !== 0) {\n    return priorityDiff\n  }\n\n  // If the priority is the same, check which phase the prefetch is in — is it\n  // prefetching the route tree, or the segments? Route trees are prioritized.\n  const phaseDiff = b.phase - a.phase\n  if (phaseDiff !== 0) {\n    return phaseDiff\n  }\n\n  // Finally, check the insertion order. `sortId` is an incrementing counter\n  // assigned to prefetches. We want to process the newest prefetches first.\n  return b.sortId - a.sortId\n}\n\nfunction heapPush(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = heap.length\n  heap.push(node)\n  node._heapIndex = index\n  heapSiftUp(heap, node, index)\n}\n\nfunction heapPeek(heap: Array<PrefetchTask>): PrefetchTask | null {\n  return heap.length === 0 ? null : heap[0]\n}\n\nfunction heapPop(heap: Array<PrefetchTask>): PrefetchTask | null {\n  if (heap.length === 0) {\n    return null\n  }\n  const first = heap[0]\n  first._heapIndex = -1\n  const last = heap.pop() as PrefetchTask\n  if (last !== first) {\n    heap[0] = last\n    last._heapIndex = 0\n    heapSiftDown(heap, last, 0)\n  }\n  return first\n}\n\nfunction heapDelete(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    node._heapIndex = -1\n    if (heap.length !== 0) {\n      const last = heap.pop() as PrefetchTask\n      if (last !== node) {\n        heap[index] = last\n        last._heapIndex = index\n        heapSiftDown(heap, last, index)\n      }\n    }\n  }\n}\n\nfunction heapResift(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    if (index === 0) {\n      heapSiftDown(heap, node, 0)\n    } else {\n      const parentIndex = (index - 1) >>> 1\n      const parent = heap[parentIndex]\n      if (compareQueuePriority(parent, node) > 0) {\n        // The parent is larger. Sift up.\n        heapSiftUp(heap, node, index)\n      } else {\n        // The parent is smaller (or equal). Sift down.\n        heapSiftDown(heap, node, index)\n      }\n    }\n  }\n}\n\nfunction heapSiftUp(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  while (index > 0) {\n    const parentIndex = (index - 1) >>> 1\n    const parent = heap[parentIndex]\n    if (compareQueuePriority(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node\n      node._heapIndex = parentIndex\n      heap[index] = parent\n      parent._heapIndex = index\n\n      index = parentIndex\n    } else {\n      // The parent is smaller. Exit.\n      return\n    }\n  }\n}\n\nfunction heapSiftDown(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  const length = heap.length\n  const halfLength = length >>> 1\n  while (index < halfLength) {\n    const leftIndex = (index + 1) * 2 - 1\n    const left = heap[leftIndex]\n    const rightIndex = leftIndex + 1\n    const right = heap[rightIndex]\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (compareQueuePriority(left, node) < 0) {\n      if (rightIndex < length && compareQueuePriority(right, left) < 0) {\n        heap[index] = right\n        right._heapIndex = index\n        heap[rightIndex] = node\n        node._heapIndex = rightIndex\n\n        index = rightIndex\n      } else {\n        heap[index] = left\n        left._heapIndex = index\n        heap[leftIndex] = node\n        node._heapIndex = leftIndex\n\n        index = leftIndex\n      }\n    } else if (rightIndex < length && compareQueuePriority(right, node) < 0) {\n      heap[index] = right\n      right._heapIndex = index\n      heap[rightIndex] = node\n      node._heapIndex = rightIndex\n\n      index = rightIndex\n    } else {\n      // Neither child is smaller. Exit.\n      return\n    }\n  }\n}\n","/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */\nexport function parsePath(path: string) {\n  const hashIndex = path.indexOf('#')\n  const queryIndex = path.indexOf('?')\n  const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex)\n\n  if (hasQuery || hashIndex > -1) {\n    return {\n      pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n      query: hasQuery\n        ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined)\n        : '',\n      hash: hashIndex > -1 ? path.slice(hashIndex) : '',\n    }\n  }\n\n  return { pathname: path, query: '', hash: '' }\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Adds the provided prefix to the given path. It first ensures that the path\n * is indeed starting with a slash.\n */\nexport function addPathPrefix(path: string, prefix?: string) {\n  if (!path.startsWith('/') || !prefix) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  return `${prefix}${pathname}${query}${hash}`\n}\n","/**\n * Removes the trailing slash for a given route or page path. Preserves the\n * root page. Examples:\n *   - `/foo/bar/` -> `/foo/bar`\n *   - `/foo/bar` -> `/foo/bar`\n *   - `/` -> `/`\n */\nexport function removeTrailingSlash(route: string) {\n  return route.replace(/\\/$/, '') || '/'\n}\n","import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { parsePath } from '../shared/lib/router/utils/parse-path'\n\n/**\n * Normalizes the trailing slash of a path according to the `trailingSlash` option\n * in `next.config.js`.\n */\nexport const normalizePathTrailingSlash = (path: string) => {\n  if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  if (process.env.__NEXT_TRAILING_SLASH) {\n    if (/\\.[^/]+\\/?$/.test(pathname)) {\n      return `${removeTrailingSlash(pathname)}${query}${hash}`\n    } else if (pathname.endsWith('/')) {\n      return `${pathname}${query}${hash}`\n    } else {\n      return `${pathname}/${query}${hash}`\n    }\n  }\n\n  return `${removeTrailingSlash(pathname)}${query}${hash}`\n}\n","import { addPathPrefix } from '../shared/lib/router/utils/add-path-prefix'\nimport { normalizePathTrailingSlash } from './normalize-trailing-slash'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function addBasePath(path: string, required?: boolean): string {\n  return normalizePathTrailingSlash(\n    process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required\n      ? path\n      : addPathPrefix(path, basePath)\n  )\n}\n","import { isBot } from '../../shared/lib/router/utils/is-bot'\nimport { addBasePath } from '../add-base-path'\n\nexport function isExternalURL(url: URL) {\n  return url.origin !== window.location.origin\n}\n\n/**\n * Given a link href, constructs the URL that should be prefetched. Returns null\n * in cases where prefetching should be disabled, like external URLs, or\n * during development.\n * @param href The href passed to <Link>, router.prefetch(), or similar\n * @returns A URL object to prefetch, or null if prefetching should be disabled\n */\nexport function createPrefetchURL(href: string): URL | null {\n  // Don't prefetch for bots as they don't navigate.\n  if (isBot(window.navigator.userAgent)) {\n    return null\n  }\n\n  let url: URL\n  try {\n    url = new URL(addBasePath(href), window.location.href)\n  } catch (_) {\n    // TODO: Does this need to throw or can we just console.error instead? Does\n    // anyone rely on this throwing? (Seems unlikely.)\n    throw new Error(\n      `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n    )\n  }\n\n  // Don't prefetch during development (improves compilation performance)\n  if (process.env.NODE_ENV === 'development') {\n    return null\n  }\n\n  // External urls can't be prefetched in the same way.\n  if (isExternalURL(url)) {\n    return null\n  }\n\n  return url\n}\n","import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './segment-cache/types'\nimport { createCacheKey } from './segment-cache/cache-key'\nimport {\n  type PrefetchTask,\n  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n  cancelPrefetchTask,\n  reschedulePrefetchTask,\n  isPrefetchTaskDirty,\n} from './segment-cache/scheduler'\nimport { startTransition } from 'react'\n\ntype LinkElement = HTMLAnchorElement | SVGAElement\n\ntype Element = LinkElement | HTMLFormElement\n\n// Properties that are shared between Link and Form instances. We use the same\n// shape for both to prevent a polymorphic de-opt in the VM.\ntype LinkOrFormInstanceShared = {\n  router: AppRouterInstance\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  isVisible: boolean\n\n  // The most recently initiated prefetch task. It may or may not have\n  // already completed. The same prefetch task object can be reused across\n  // multiple prefetches of the same link.\n  prefetchTask: PrefetchTask | null\n}\n\nexport type FormInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: null\n}\n\ntype PrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype NonPrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: null\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype PrefetchableInstance = PrefetchableLinkInstance | FormInstance\n\nexport type LinkInstance =\n  | PrefetchableLinkInstance\n  | NonPrefetchableLinkInstance\n\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation: LinkInstance | null = null\n\n// Status object indicating link is pending\nexport const PENDING_LINK_STATUS = { pending: true }\n\n// Status object indicating link is idle\nexport const IDLE_LINK_STATUS = { pending: false }\n\n// Updates the loading state when navigating between links\n// - Resets the previous link's loading state\n// - Sets the new link's loading state\n// - Updates tracking of current navigation\nexport function setLinkForCurrentNavigation(link: LinkInstance | null) {\n  startTransition(() => {\n    linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)\n    link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)\n    linkForMostRecentNavigation = link\n  })\n}\n\n// Unmounts the current link instance from navigation tracking\nexport function unmountLinkForCurrentNavigation(link: LinkInstance) {\n  if (linkForMostRecentNavigation === link) {\n    linkForMostRecentNavigation = null\n  }\n}\n\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable:\n  | WeakMap<Element, PrefetchableInstance>\n  | Map<Element, PrefetchableInstance> =\n  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible: Set<PrefetchableInstance> = new Set()\n\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer: IntersectionObserver | null =\n  typeof IntersectionObserver === 'function'\n    ? new IntersectionObserver(handleIntersect, {\n        rootMargin: '200px',\n      })\n    : null\n\nfunction observeVisibility(element: Element, instance: PrefetchableInstance) {\n  const existingInstance = prefetchable.get(element)\n  if (existingInstance !== undefined) {\n    // This shouldn't happen because each <Link> component should have its own\n    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n    // case there's a logical error somewhere else.\n    unmountPrefetchableInstance(element)\n  }\n  // Only track prefetchable links that have a valid prefetch URL\n  prefetchable.set(element, instance)\n  if (observer !== null) {\n    observer.observe(element)\n  }\n}\n\nfunction coercePrefetchableUrl(href: string): URL | null {\n  if (typeof window !== 'undefined') {\n    const { createPrefetchURL } =\n      require('./app-router-utils') as typeof import('./app-router-utils')\n\n    try {\n      return createPrefetchURL(href)\n    } catch {\n      // createPrefetchURL sometimes throws an error if an invalid URL is\n      // provided, though I'm not sure if it's actually necessary.\n      // TODO: Consider removing the throw from the inner function, or change it\n      // to reportError. Or maybe the error isn't even necessary for automatic\n      // prefetches, just navigations.\n      const reportErrorFn =\n        typeof reportError === 'function' ? reportError : console.error\n      reportErrorFn(\n        `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n      )\n      return null\n    }\n  } else {\n    return null\n  }\n}\n\nexport function mountLinkInstance(\n  element: LinkElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  prefetchEnabled: boolean,\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n): LinkInstance {\n  if (prefetchEnabled) {\n    const prefetchURL = coercePrefetchableUrl(href)\n    if (prefetchURL !== null) {\n      const instance: PrefetchableLinkInstance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus,\n      }\n      // We only observe the link's visibility if it's prefetchable. For\n      // example, this excludes links to external URLs.\n      observeVisibility(element, instance)\n      return instance\n    }\n  }\n  // If the link is not prefetchable, we still create an instance so we can\n  // track its optimistic state (i.e. useLinkStatus).\n  const instance: NonPrefetchableLinkInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: null,\n    setOptimisticLinkStatus,\n  }\n  return instance\n}\n\nexport function mountFormInstance(\n  element: HTMLFormElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy\n): void {\n  const prefetchURL = coercePrefetchableUrl(href)\n  if (prefetchURL === null) {\n    // This href is not prefetchable, so we don't track it.\n    // TODO: We currently observe/unobserve a form every time its href changes.\n    // For Links, this isn't a big deal because the href doesn't usually change,\n    // but for forms it's extremely common. We should optimize this.\n    return\n  }\n  const instance: FormInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: prefetchURL.href,\n    setOptimisticLinkStatus: null,\n  }\n  observeVisibility(element, instance)\n}\n\nexport function unmountPrefetchableInstance(element: Element) {\n  const instance = prefetchable.get(element)\n  if (instance !== undefined) {\n    prefetchable.delete(element)\n    prefetchableAndVisible.delete(instance)\n    const prefetchTask = instance.prefetchTask\n    if (prefetchTask !== null) {\n      cancelPrefetchTask(prefetchTask)\n    }\n  }\n  if (observer !== null) {\n    observer.unobserve(element)\n  }\n}\n\nfunction handleIntersect(entries: Array<IntersectionObserverEntry>) {\n  for (const entry of entries) {\n    // Some extremely old browsers or polyfills don't reliably support\n    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n    // really. But whatever this is fine.)\n    const isVisible = entry.intersectionRatio > 0\n    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n  }\n}\n\nexport function onLinkVisibilityChanged(element: Element, isVisible: boolean) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Prefetching on viewport is disabled in development for performance\n    // reasons, because it requires compiling the target page.\n    // TODO: Investigate re-enabling this.\n    return\n  }\n\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n\n  instance.isVisible = isVisible\n  if (isVisible) {\n    prefetchableAndVisible.add(instance)\n  } else {\n    prefetchableAndVisible.delete(instance)\n  }\n  rescheduleLinkPrefetch(instance, PrefetchPriority.Default)\n}\n\nexport function onNavigationIntent(\n  element: HTMLAnchorElement | SVGAElement,\n  unstable_upgradeToDynamicPrefetch: boolean\n) {\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n  // Prefetch the link on hover/touchstart.\n  if (instance !== undefined) {\n    if (\n      process.env.__NEXT_DYNAMIC_ON_HOVER &&\n      unstable_upgradeToDynamicPrefetch\n    ) {\n      // Switch to a full prefetch\n      instance.fetchStrategy = FetchStrategy.Full\n    }\n    rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n  }\n}\n\nfunction rescheduleLinkPrefetch(\n  instance: PrefetchableInstance,\n  priority: PrefetchPriority.Default | PrefetchPriority.Intent\n) {\n  // Ensures that app-router-instance is not compiled in the server bundle\n  if (typeof window !== 'undefined') {\n    const existingPrefetchTask = instance.prefetchTask\n\n    if (!instance.isVisible) {\n      // Cancel any in-progress prefetch task. (If it already finished then this\n      // is a no-op.)\n      if (existingPrefetchTask !== null) {\n        cancelPrefetchTask(existingPrefetchTask)\n      }\n      // We don't need to reset the prefetchTask to null upon cancellation; an\n      // old task object can be rescheduled with reschedulePrefetchTask. This is a\n      // micro-optimization but also makes the code simpler (don't need to\n      // worry about whether an old task object is stale).\n      return\n    }\n\n    const { getCurrentAppRouterState } =\n      require('./app-router-instance') as typeof import('./app-router-instance')\n\n    const appRouterState = getCurrentAppRouterState()\n    if (appRouterState !== null) {\n      const treeAtTimeOfPrefetch = appRouterState.tree\n      if (existingPrefetchTask === null) {\n        // Initiate a prefetch task.\n        const nextUrl = appRouterState.nextUrl\n        const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n        instance.prefetchTask = scheduleSegmentPrefetchTask(\n          cacheKey,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority,\n          null\n        )\n      } else {\n        // We already have an old task object that we can reschedule. This is\n        // effectively the same as canceling the old task and creating a new one.\n        reschedulePrefetchTask(\n          existingPrefetchTask,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority\n        )\n      }\n    }\n  }\n}\n\nexport function pingVisibleLinks(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // For each currently visible link, cancel the existing prefetch task (if it\n  // exists) and schedule a new one. This is effectively the same as if all the\n  // visible links left and then re-entered the viewport.\n  //\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  for (const instance of prefetchableAndVisible) {\n    const task = instance.prefetchTask\n    if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n      // The cache has not been invalidated, and none of the inputs have\n      // changed. Bail out.\n      continue\n    }\n    // Something changed. Cancel the existing prefetch task and schedule a\n    // new one.\n    if (task !== null) {\n      cancelPrefetchTask(task)\n    }\n    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n    instance.prefetchTask = scheduleSegmentPrefetchTask(\n      cacheKey,\n      tree,\n      instance.fetchStrategy,\n      PrefetchPriority.Default,\n      null\n    )\n  }\n}\n","// In output: export mode, the build id is added to the start of the HTML\n// document, directly after the doctype declaration. During a prefetch, the\n// client performs a range request to get the build id, so it can check whether\n// the target page belongs to the same build.\n//\n// The first 64 bytes of the document are requested. The exact number isn't\n// too important; it must be larger than the build id + doctype + closing and\n// ending comment markers, but it doesn't need to match the end of the\n// comment exactly.\n//\n// Build ids are 21 bytes long in the default implementation, though this\n// can be overridden in the Next.js config. For the purposes of this check,\n// it's OK to only match the start of the id, so we'll truncate it if exceeds\n// a certain length.\n\nconst DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes\nconst MAX_BUILD_ID_LENGTH = 24\n\n// Request the first 64 bytes. The Range header is inclusive of the end value.\nexport const DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63'\n\nfunction escapeBuildId(buildId: string) {\n  // If the build id is longer than the given limit, it's OK for our purposes\n  // to only match the beginning.\n  const truncated = buildId.slice(0, MAX_BUILD_ID_LENGTH)\n  // Replace hyphens with underscores so it doesn't break the HTML comment.\n  // (Unlikely, but if this did happen it would break the whole document.)\n  return truncated.replace(/-/g, '_')\n}\n\nexport function insertBuildIdComment(originalHtml: string, buildId: string) {\n  if (\n    // Skip if the build id contains a closing comment marker.\n    buildId.includes('-->') ||\n    // React always inserts a doctype at the start of the document. Skip if it\n    // isn't present. Shouldn't happen; suggests an issue elsewhere.\n    !originalHtml.startsWith(DOCTYPE_PREFIX)\n  ) {\n    // Return the original HTML unchanged. This means the document will not\n    // be prefetched.\n    // TODO: The build id comment is currently only used during prefetches, but\n    // if we eventually use this mechanism for regular navigations, we may need\n    // to error during build if we fail to insert it for some reason.\n    return originalHtml\n  }\n  // The comment must be inserted after the doctype.\n  return originalHtml.replace(\n    DOCTYPE_PREFIX,\n    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n  )\n}\n\nexport function doesExportedHtmlMatchBuildId(\n  partialHtmlDocument: string,\n  buildId: string\n) {\n  // Check whether the document starts with the expected buildId.\n  return partialHtmlDocument.startsWith(\n    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n  )\n}\n","import type {\n  TreePrefetch,\n  RootTreePrefetch,\n  SegmentPrefetch,\n} from '../../../server/app-render/collect-segment-data'\nimport type { LoadingModuleData } from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNodeSeedData,\n  Segment as FlightRouterStateSegment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport {\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  RSC_HEADER,\n} from '../app-router-headers'\nimport {\n  createFetch,\n  createFromNextReadableStream,\n  type RSCResponse,\n  type RequestHeaders,\n} from '../router-reducer/fetch-server-response'\nimport {\n  pingPrefetchTask,\n  isPrefetchTaskDirty,\n  type PrefetchTask,\n  type PrefetchSubtaskResult,\n  startRevalidationCooldown,\n} from './scheduler'\nimport {\n  type RouteVaryPath,\n  type SegmentVaryPath,\n  type PartialSegmentVaryPath,\n  getRouteVaryPath,\n  getFulfilledRouteVaryPath,\n  getSegmentVaryPathForRequest,\n  appendLayoutVaryPath,\n  finalizeLayoutVaryPath,\n  finalizePageVaryPath,\n  clonePageVaryPathWithNewSearchParams,\n  type PageVaryPath,\n  finalizeMetadataVaryPath,\n} from './vary-path'\nimport { getAppBuildId } from '../../app-build-id'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport type { NormalizedSearch, RouteCacheKey } from './cache-key'\n// TODO: Rename this module to avoid confusion with other types of cache keys\nimport { createCacheKey as createPrefetchRequestKey } from './cache-key'\nimport {\n  doesStaticSegmentAppearInURL,\n  getCacheKeyForDynamicParam,\n  getRenderedPathname,\n  getRenderedSearch,\n  parseDynamicParamFromURLPart,\n} from '../../route-params'\nimport {\n  createCacheMap,\n  getFromCacheMap,\n  setInCacheMap,\n  setSizeInCacheMap,\n  deleteFromCacheMap,\n  isValueExpired,\n  type CacheMap,\n  type MapEntry,\n} from './cache-map'\nimport {\n  appendSegmentRequestKeyPart,\n  convertSegmentPathToStaticExportFilename,\n  createSegmentRequestKeyPart,\n  HEAD_REQUEST_KEY,\n  ROOT_SEGMENT_REQUEST_KEY,\n  type SegmentRequestKey,\n} from '../../../shared/lib/segment-cache/segment-value-encoding'\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n} from '../../flight-data-helpers'\nimport { STATIC_STALETIME_MS } from '../router-reducer/reducers/navigate-reducer'\nimport { pingVisibleLinks } from '../links'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport {\n  DOC_PREFETCH_RANGE_HEADER_VALUE,\n  doesExportedHtmlMatchBuildId,\n} from '../../../shared/lib/segment-cache/output-export-prefetch-encoding'\nimport { FetchStrategy } from './types'\nimport { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'\n\n/**\n * Ensures a minimum stale time of 30s to avoid issues where the server sends a too\n * short-lived stale time, which would prevent anything from being prefetched.\n */\nexport function getStaleTimeMs(staleTimeSeconds: number): number {\n  return Math.max(staleTimeSeconds, 30) * 1000\n}\n\n// A note on async/await when working in the prefetch cache:\n//\n// Most async operations in the prefetch cache should *not* use async/await,\n// Instead, spawn a subtask that writes the results to a cache entry, and attach\n// a \"ping\" listener to notify the prefetch queue to try again.\n//\n// The reason is we need to be able to access the segment cache and traverse its\n// data structures synchronously. For example, if there's a synchronous update\n// we can take an immediate snapshot of the cache to produce something we can\n// render. Limiting the use of async/await also makes it easier to avoid race\n// conditions, which is especially important because is cache is mutable.\n//\n// Another reason is that while we're performing async work, it's possible for\n// existing entries to become stale, or for Link prefetches to be removed from\n// the queue. For optimal scheduling, we need to be able to \"cancel\" subtasks\n// that are no longer needed. So, when a segment is received from the server, we\n// restart from the root of the tree that's being prefetched, to confirm all the\n// parent segments are still cached. If the segment is no longer reachable from\n// the root, then it's effectively canceled. This is similar to the design of\n// Rust Futures, or React Suspense.\n\ntype RouteTreeShared = {\n  requestKey: SegmentRequestKey\n  // TODO: Remove the `segment` field, now that it can be reconstructed\n  // from `param`.\n  segment: FlightRouterStateSegment\n  slots: null | {\n    [parallelRouteKey: string]: RouteTree\n  }\n  isRootLayout: boolean\n\n  // If this is a dynamic route, indicates whether there is a loading boundary\n  // somewhere in the tree. If not, we can skip the prefetch for the data,\n  // because we know it would be an empty response. (For a static/PPR route,\n  // this value is disregarded, because in that model `loading.tsx` is treated\n  // like any other Suspense boundary.)\n  hasLoadingBoundary: HasLoadingBoundary\n\n  // Indicates whether this route has a runtime prefetch that we can request.\n  // This is determined by the server; it's not purely a user configuration\n  // because the server may determine that a route is fully static and doesn't\n  // need runtime prefetching regardless of the configuration.\n  hasRuntimePrefetch: boolean\n}\n\ntype LayoutRouteTree = RouteTreeShared & {\n  isPage: false\n  varyPath: SegmentVaryPath\n}\n\ntype PageRouteTree = RouteTreeShared & {\n  isPage: true\n  varyPath: PageVaryPath\n}\n\nexport type RouteTree = LayoutRouteTree | PageRouteTree\n\ntype RouteCacheEntryShared = {\n  // This is false only if we're certain the route cannot be intercepted. It's\n  // true in all other cases, including on initialization when we haven't yet\n  // received a response from the server.\n  couldBeIntercepted: boolean\n\n  // Map-related fields.\n  ref: null | MapEntry<RouteCacheEntry>\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Tracks the status of a cache entry as it progresses from no data (Empty),\n * waiting for server data (Pending), and finished (either Fulfilled or\n * Rejected depending on the response from the server.\n */\nexport const enum EntryStatus {\n  Empty = 0,\n  Pending = 1,\n  Fulfilled = 2,\n  Rejected = 3,\n}\n\ntype PendingRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Empty | EntryStatus.Pending\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: false\n}\n\ntype RejectedRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Rejected\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: boolean\n}\n\nexport type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  blockedTasks: null\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n  tree: RouteTree\n  metadata: RouteTree\n  isPPREnabled: boolean\n}\n\nexport type RouteCacheEntry =\n  | PendingRouteCacheEntry\n  | FulfilledRouteCacheEntry\n  | RejectedRouteCacheEntry\n\ntype SegmentCacheEntryShared = {\n  fetchStrategy: FetchStrategy\n\n  // Map-related fields.\n  ref: null | MapEntry<SegmentCacheEntry>\n  size: number\n  staleAt: number\n  version: number\n}\n\nexport type EmptySegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Empty\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type PendingSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Pending\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null | PromiseWithResolvers<FulfilledSegmentCacheEntry | null>\n}\n\ntype RejectedSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Rejected\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type FulfilledSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n  promise: null\n}\n\nexport type SegmentCacheEntry =\n  | EmptySegmentCacheEntry\n  | PendingSegmentCacheEntry\n  | RejectedSegmentCacheEntry\n  | FulfilledSegmentCacheEntry\n\nexport type NonEmptySegmentCacheEntry = Exclude<\n  SegmentCacheEntry,\n  EmptySegmentCacheEntry\n>\n\nconst isOutputExportMode =\n  process.env.NODE_ENV === 'production' &&\n  process.env.__NEXT_CONFIG_OUTPUT === 'export'\n\nconst MetadataOnlyRequestTree: FlightRouterState = [\n  '',\n  {},\n  null,\n  'metadata-only',\n]\n\nlet routeCacheMap: CacheMap<RouteCacheEntry> = createCacheMap()\nlet segmentCacheMap: CacheMap<SegmentCacheEntry> = createCacheMap()\n\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners: Set<PrefetchTask> | null = null\n\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0\n\nexport function getCurrentCacheVersion(): number {\n  return currentCacheVersion\n}\n\n/**\n * Used to clear the client prefetch cache when a server action calls\n * revalidatePath or revalidateTag. Eventually we will support only clearing the\n * segments that were actually affected, but there's more work to be done on the\n * server before the client is able to do this correctly.\n */\nexport function revalidateEntireCache(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // Increment the current cache version. This does not eagerly evict anything\n  // from the cache, but because all the entries are versioned, and we check\n  // the version when reading from the cache, this effectively causes all\n  // entries to be evicted lazily. We do it lazily because in the future,\n  // actions like revalidateTag or refresh will not evict the entire cache,\n  // but rather some subset of the entries.\n  currentCacheVersion++\n\n  // Start a cooldown before re-prefetching to allow CDN cache propagation.\n  startRevalidationCooldown()\n\n  // Prefetch all the currently visible links again, to re-fill the cache.\n  pingVisibleLinks(nextUrl, tree)\n\n  // Similarly, notify all invalidation listeners (i.e. those passed to\n  // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n  // if needed.\n  pingInvalidationListeners(nextUrl, tree)\n}\n\nfunction attachInvalidationListener(task: PrefetchTask): void {\n  // This function is called whenever a prefetch task reads a cache entry. If\n  // the task has an onInvalidate function associated with it — i.e. the one\n  // optionally passed to router.prefetch(onInvalidate) — then we attach that\n  // listener to the every cache entry that the task reads. Then, if an entry\n  // is invalidated, we call the function.\n  if (task.onInvalidate !== null) {\n    if (invalidationListeners === null) {\n      invalidationListeners = new Set([task])\n    } else {\n      invalidationListeners.add(task)\n    }\n  }\n}\n\nfunction notifyInvalidationListener(task: PrefetchTask): void {\n  const onInvalidate = task.onInvalidate\n  if (onInvalidate !== null) {\n    // Clear the callback from the task object to guarantee it's not called more\n    // than once.\n    task.onInvalidate = null\n\n    // This is a user-space function, so we must wrap in try/catch.\n    try {\n      onInvalidate()\n    } catch (error) {\n      if (typeof reportError === 'function') {\n        reportError(error)\n      } else {\n        console.error(error)\n      }\n    }\n  }\n}\n\nexport function pingInvalidationListeners(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  if (invalidationListeners !== null) {\n    const tasks = invalidationListeners\n    invalidationListeners = null\n    for (const task of tasks) {\n      if (isPrefetchTaskDirty(task, nextUrl, tree)) {\n        notifyInvalidationListener(task)\n      }\n    }\n  }\n}\n\nexport function readRouteCacheEntry(\n  now: number,\n  key: RouteCacheKey\n): RouteCacheEntry | null {\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    routeCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function readSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nfunction readRevalidatingSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = true\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function waitForSegmentCacheEntry(\n  pendingEntry: PendingSegmentCacheEntry\n): Promise<FulfilledSegmentCacheEntry | null> {\n  // Because the entry is pending, there's already a in-progress request.\n  // Attach a promise to the entry that will resolve when the server responds.\n  let promiseWithResolvers = pendingEntry.promise\n  if (promiseWithResolvers === null) {\n    promiseWithResolvers = pendingEntry.promise =\n      createPromiseWithResolvers<FulfilledSegmentCacheEntry | null>()\n  } else {\n    // There's already a promise we can use\n  }\n  return promiseWithResolvers.promise\n}\n\n/**\n * Checks if an entry for a route exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateRouteCacheEntry(\n  now: number,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): RouteCacheEntry {\n  attachInvalidationListener(task)\n\n  const existingEntry = readRouteCacheEntry(now, key)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry: PendingRouteCacheEntry = {\n    canonicalUrl: null,\n    status: EntryStatus.Empty,\n    blockedTasks: null,\n    tree: null,\n    metadata: null,\n    // This is initialized to true because we don't know yet whether the route\n    // could be intercepted. It's only set to false once we receive a response\n    // from the server.\n    couldBeIntercepted: true,\n    // Similarly, we don't yet know if the route supports PPR.\n    isPPREnabled: false,\n    renderedSearch: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    // Since this is an empty entry, there's no reason to ever evict it. It will\n    // be updated when the data is populated.\n    staleAt: Infinity,\n    version: getCurrentCacheVersion(),\n  }\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  setInCacheMap(routeCacheMap, varyPath, pendingEntry, isRevalidation)\n  return pendingEntry\n}\n\nexport function requestOptimisticRouteCacheEntry(\n  now: number,\n  requestedUrl: URL,\n  nextUrl: string | null\n): FulfilledRouteCacheEntry | null {\n  // This function is called during a navigation when there was no matching\n  // route tree in the prefetch cache. Before de-opting to a blocking,\n  // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n  // route tree by checking the cache for similar routes.\n  //\n  // Check if there's a route with the same pathname, but with different\n  // search params. We can then base our optimistic route tree on this entry.\n  //\n  // Conceptually, we are simulating what would happen if we did perform a\n  // prefetch the requested URL, under the assumption that the server will\n  // not redirect or rewrite the request in a different manner than the\n  // base route tree. This assumption might not hold, in which case we'll have\n  // to recover when we perform the dynamic navigation request. However, this\n  // is what would happen if a route were dynamically rewritten/redirected\n  // in between the prefetch and the navigation. So the logic needs to exist\n  // to handle this case regardless.\n\n  // Look for a route with the same pathname, but with an empty search string.\n  // TODO: There's nothing inherently special about the empty search string;\n  // it's chosen somewhat arbitrarily, with the rationale that it's the most\n  // likely one to exist. But we should update this to match _any_ search\n  // string. The plan is to generalize this logic alongside other improvements\n  // related to \"fallback\" cache entries.\n  const requestedSearch = requestedUrl.search as NormalizedSearch\n  if (requestedSearch === '') {\n    // The caller would have already checked if a route with an empty search\n    // string is in the cache. So we can bail out here.\n    return null\n  }\n  const urlWithoutSearchParams = new URL(requestedUrl)\n  urlWithoutSearchParams.search = ''\n  const routeWithNoSearchParams = readRouteCacheEntry(\n    now,\n    createPrefetchRequestKey(urlWithoutSearchParams.href, nextUrl)\n  )\n\n  if (\n    routeWithNoSearchParams === null ||\n    routeWithNoSearchParams.status !== EntryStatus.Fulfilled\n  ) {\n    // Bail out of constructing an optimistic route tree. This will result in\n    // a blocking, unprefetched navigation.\n    return null\n  }\n\n  // Now we have a base route tree we can \"patch\" with our optimistic values.\n\n  // Optimistically assume that redirects for the requested pathname do\n  // not vary on the search string. Therefore, if the base route was\n  // redirected to a different search string, then the optimistic route\n  // should be redirected to the same search string. Otherwise, we use\n  // the requested search string.\n  const canonicalUrlForRouteWithNoSearchParams = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    requestedUrl.origin\n  )\n  const optimisticCanonicalSearch =\n    canonicalUrlForRouteWithNoSearchParams.search !== ''\n      ? // Base route was redirected. Reuse the same redirected search string.\n        canonicalUrlForRouteWithNoSearchParams.search\n      : requestedSearch\n\n  // Similarly, optimistically assume that rewrites for the requested\n  // pathname do not vary on the search string. Therefore, if the base\n  // route was rewritten to a different search string, then the optimistic\n  // route should be rewritten to the same search string. Otherwise, we use\n  // the requested search string.\n  const optimisticRenderedSearch =\n    routeWithNoSearchParams.renderedSearch !== ''\n      ? // Base route was rewritten. Reuse the same rewritten search string.\n        routeWithNoSearchParams.renderedSearch\n      : requestedSearch\n\n  const optimisticUrl = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    location.origin\n  )\n  optimisticUrl.search = optimisticCanonicalSearch\n  const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)\n\n  const optimisticRouteTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.tree,\n    optimisticRenderedSearch\n  )\n  const optimisticMetadataTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.metadata,\n    optimisticRenderedSearch\n  )\n\n  // Clone the base route tree, and override the relevant fields with our\n  // optimistic values.\n  const optimisticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: optimisticCanonicalUrl,\n\n    status: EntryStatus.Fulfilled,\n    // This isn't cloned because it's instance-specific\n    blockedTasks: null,\n    tree: optimisticRouteTree,\n    metadata: optimisticMetadataTree,\n    couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n    isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n\n    // Override the rendered search with the optimistic value.\n    renderedSearch: optimisticRenderedSearch,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt: routeWithNoSearchParams.staleAt,\n    version: routeWithNoSearchParams.version,\n  }\n\n  // Do not insert this entry into the cache. It only exists so we can\n  // perform the current navigation. Just return it to the caller.\n  return optimisticEntry\n}\n\nfunction createOptimisticRouteTree(\n  tree: RouteTree,\n  newRenderedSearch: NormalizedSearch\n): RouteTree {\n  // Create a new route tree that identical to the original one except for\n  // the rendered search string, which is contained in the vary path.\n\n  let clonedSlots: Record<string, RouteTree> | null = null\n  const originalSlots = tree.slots\n  if (originalSlots !== null) {\n    clonedSlots = {}\n    for (const parallelRouteKey in originalSlots) {\n      const childTree = originalSlots[parallelRouteKey]\n      clonedSlots[parallelRouteKey] = createOptimisticRouteTree(\n        childTree,\n        newRenderedSearch\n      )\n    }\n  }\n\n  // We only need to clone the vary path if the route is a page.\n  if (tree.isPage) {\n    return {\n      requestKey: tree.requestKey,\n      segment: tree.segment,\n      varyPath: clonePageVaryPathWithNewSearchParams(\n        tree.varyPath,\n        newRenderedSearch\n      ),\n      isPage: true,\n      slots: clonedSlots,\n      isRootLayout: tree.isRootLayout,\n      hasLoadingBoundary: tree.hasLoadingBoundary,\n      hasRuntimePrefetch: tree.hasRuntimePrefetch,\n    }\n  }\n\n  return {\n    requestKey: tree.requestKey,\n    segment: tree.segment,\n    varyPath: tree.varyPath,\n    isPage: false,\n    slots: clonedSlots,\n    isRootLayout: tree.isRootLayout,\n    hasLoadingBoundary: tree.hasLoadingBoundary,\n    hasRuntimePrefetch: tree.hasRuntimePrefetch,\n  }\n}\n\n/**\n * Checks if an entry for a segment exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  const existingEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = false\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function readOrCreateRevalidatingSegmentEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  // This function is called when we've already confirmed that a particular\n  // segment is cached, but we want to perform another request anyway in case it\n  // returns more complete and/or fresher data than we already have. The logic\n  // for deciding whether to replace the existing entry is handled elsewhere;\n  // this function just handles retrieving a cache entry that we can use to\n  // track the revalidation.\n  //\n  // The reason revalidations are stored in the cache is because we need to be\n  // able to dedupe multiple revalidation requests. The reason they have to be\n  // handled specially is because we shouldn't overwrite a \"normal\" entry if\n  // one exists at the same keypath. So, for each internal cache location, there\n  // is a special \"revalidation\" slot that is used solely for this purpose.\n  //\n  // You can think of it as if all the revalidation entries were stored in a\n  // separate cache map from the canonical entries, and then transfered to the\n  // canonical cache map once the request is complete — this isn't how it's\n  // actually implemented, since it's more efficient to store them in the same\n  // data structure as the normal entries, but that's how it's modeled\n  // conceptually.\n\n  // TODO: Once we implement Fallback behavior for params, where an entry is\n  // re-keyed based on response information, we'll need to account for the\n  // possibility that the keypath of the previous entry is more generic than\n  // the keypath of the revalidating entry. In other words, the server could\n  // return a less generic entry upon revalidation. For now, though, this isn't\n  // a concern because the keypath is based solely on the prefetch strategy,\n  // not on data contained in the response.\n  const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function overwriteRevalidatingSegmentCacheEntry(\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n) {\n  // This function is called when we've already decided to replace an existing\n  // revalidation entry. Create a new entry and write it into the cache,\n  // overwriting the previous value.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function upsertSegmentEntry(\n  now: number,\n  varyPath: SegmentVaryPath,\n  candidateEntry: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  // We have a new entry that has not yet been inserted into the cache. Before\n  // we do so, we need to confirm whether it takes precedence over the existing\n  // entry (if one exists).\n  // TODO: We should not upsert an entry if its key was invalidated in the time\n  // since the request was made. We can do that by passing the \"owner\" entry to\n  // this function and confirming it's the same as `existingEntry`.\n\n  if (isValueExpired(now, getCurrentCacheVersion(), candidateEntry)) {\n    // The entry is expired. We cannot upsert it.\n    return null\n  }\n\n  const existingEntry = readSegmentCacheEntry(now, varyPath)\n  if (existingEntry !== null) {\n    // Don't replace a more specific segment with a less-specific one. A case where this\n    // might happen is if the existing segment was fetched via\n    // `<Link prefetch={true}>`.\n    if (\n      // We fetched the new segment using a different, less specific fetch strategy\n      // than the segment we already have in the cache, so it can't have more content.\n      (candidateEntry.fetchStrategy !== existingEntry.fetchStrategy &&\n        !canNewFetchStrategyProvideMoreContent(\n          existingEntry.fetchStrategy,\n          candidateEntry.fetchStrategy\n        )) ||\n      // The existing entry isn't partial, but the new one is.\n      // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n      (!existingEntry.isPartial && candidateEntry.isPartial)\n    ) {\n      // We're going to leave revalidating entry in the cache so that it doesn't\n      // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n      // Rejected and null out the data so it can be garbage collected. We leave\n      // `staleAt` intact to prevent subsequent revalidation attempts only until\n      // the entry expires.\n      const rejectedEntry: RejectedSegmentCacheEntry = candidateEntry as any\n      rejectedEntry.status = EntryStatus.Rejected\n      rejectedEntry.loading = null\n      rejectedEntry.rsc = null\n      return null\n    }\n\n    // Evict the existing entry from the cache.\n    deleteFromCacheMap(existingEntry)\n  }\n\n  const isRevalidation = false\n  setInCacheMap(segmentCacheMap, varyPath, candidateEntry, isRevalidation)\n  return candidateEntry\n}\n\nexport function createDetachedSegmentCacheEntry(\n  staleAt: number\n): EmptySegmentCacheEntry {\n  const emptyEntry: EmptySegmentCacheEntry = {\n    status: EntryStatus.Empty,\n    // Default to assuming the fetch strategy will be PPR. This will be updated\n    // when a fetch is actually initiated.\n    fetchStrategy: FetchStrategy.PPR,\n    rsc: null,\n    loading: null,\n    isPartial: true,\n    promise: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt,\n    version: 0,\n  }\n  return emptyEntry\n}\n\nexport function upgradeToPendingSegment(\n  emptyEntry: EmptySegmentCacheEntry,\n  fetchStrategy: FetchStrategy\n): PendingSegmentCacheEntry {\n  const pendingEntry: PendingSegmentCacheEntry = emptyEntry as any\n  pendingEntry.status = EntryStatus.Pending\n  pendingEntry.fetchStrategy = fetchStrategy\n  // Set the version here, since this is right before the request is initiated.\n  // The next time the global cache version is incremented, the entry will\n  // effectively be evicted. This happens before initiating the request, rather\n  // than when receiving the response, because it's guaranteed to happen\n  // before the data is read on the server.\n  pendingEntry.version = getCurrentCacheVersion()\n  return pendingEntry\n}\n\nfunction pingBlockedTasks(entry: {\n  blockedTasks: Set<PrefetchTask> | null\n}): void {\n  const blockedTasks = entry.blockedTasks\n  if (blockedTasks !== null) {\n    for (const task of blockedTasks) {\n      pingPrefetchTask(task)\n    }\n    entry.blockedTasks = null\n  }\n}\n\nfunction fulfillRouteCacheEntry(\n  entry: RouteCacheEntry,\n  tree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  staleAt: number,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  renderedSearch: NormalizedSearch,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  // The Head is not actually part of the route tree, but other than that, it's\n  // fetched and cached like a segment. Some functions expect a RouteTree\n  // object, so rather than fork the logic in all those places, we use this\n  // \"fake\" one.\n  const metadata: RouteTree = {\n    requestKey: HEAD_REQUEST_KEY,\n    segment: HEAD_REQUEST_KEY,\n    varyPath: metadataVaryPath,\n    // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n    // either) but for the purposes of how this field is used, it behaves like\n    // one. If this logic ever gets more complex we can change this to an enum.\n    isPage: true,\n    slots: null,\n    isRootLayout: false,\n    hasLoadingBoundary: HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n    hasRuntimePrefetch: false,\n  }\n  const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.tree = tree\n  fulfilledEntry.metadata = metadata\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.couldBeIntercepted = couldBeIntercepted\n  fulfilledEntry.canonicalUrl = canonicalUrl\n  fulfilledEntry.renderedSearch = renderedSearch\n  fulfilledEntry.isPPREnabled = isPPREnabled\n  pingBlockedTasks(entry)\n  return fulfilledEntry\n}\n\nfunction fulfillSegmentCacheEntry(\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  staleAt: number,\n  isPartial: boolean\n): FulfilledSegmentCacheEntry {\n  const fulfilledEntry: FulfilledSegmentCacheEntry = segmentCacheEntry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.rsc = rsc\n  fulfilledEntry.loading = loading\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.isPartial = isPartial\n  // Resolve any listeners that were waiting for this data.\n  if (segmentCacheEntry.promise !== null) {\n    segmentCacheEntry.promise.resolve(fulfilledEntry)\n    // Free the promise for garbage collection.\n    fulfilledEntry.promise = null\n  }\n  return fulfilledEntry\n}\n\nfunction rejectRouteCacheEntry(\n  entry: PendingRouteCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedRouteCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  pingBlockedTasks(entry)\n}\n\nfunction rejectSegmentCacheEntry(\n  entry: PendingSegmentCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedSegmentCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  if (entry.promise !== null) {\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\ntype RouteTreeAccumulator = {\n  metadataVaryPath: PageVaryPath | null\n}\n\nfunction convertRootTreePrefetchToRouteTree(\n  rootTree: RootTreePrefetch,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n) {\n  // Remove trailing and leading slashes\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  const rootSegment = ROOT_SEGMENT_REQUEST_KEY\n  return convertTreePrefetchToRouteTree(\n    rootTree.tree,\n    rootSegment,\n    null,\n    ROOT_SEGMENT_REQUEST_KEY,\n    pathnameParts,\n    index,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertTreePrefetchToRouteTree(\n  prefetch: TreePrefetch,\n  segment: FlightRouterStateSegment,\n  partialVaryPath: PartialSegmentVaryPath | null,\n  requestKey: SegmentRequestKey,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  // Converts the route tree sent by the server into the format used by the\n  // cache. The cached version of the tree includes additional fields, such as a\n  // cache key for each segment. Since this is frequently accessed, we compute\n  // it once instead of on every access. This same cache key is also used to\n  // request the segment from the server.\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  const prefetchSlots = prefetch.slots\n  if (prefetchSlots !== null) {\n    isPage = false\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n\n    slots = {}\n    for (let parallelRouteKey in prefetchSlots) {\n      const childPrefetch = prefetchSlots[parallelRouteKey]\n      const childParamName = childPrefetch.name\n      const childParamType = childPrefetch.paramType\n      const childServerSentParamKey = childPrefetch.paramKey\n\n      let childDoesAppearInURL: boolean\n      let childSegment: FlightRouterStateSegment\n      let childPartialVaryPath: PartialSegmentVaryPath | null\n      if (childParamType !== null) {\n        // This segment is parameterized. Get the param from the pathname.\n        const childParamValue = parseDynamicParamFromURLPart(\n          childParamType,\n          pathnameParts,\n          pathnamePartsIndex\n        )\n\n        // Assign a cache key to the segment, based on the param value. In the\n        // pre-Segment Cache implementation, the server computes this and sends\n        // it in the body of the response. In the Segment Cache implementation,\n        // the server sends an empty string and we fill it in here.\n\n        // TODO: We're intentionally not adding the search param to page\n        // segments here; it's tracked separately and added back during a read.\n        // This would clearer if we waited to construct the segment until it's\n        // read from the cache, since that's effectively what we're\n        // doing anyway.\n        const childParamKey =\n          // The server omits this field from the prefetch response when\n          // cacheComponents is enabled.\n          childServerSentParamKey !== null\n            ? childServerSentParamKey\n            : // If no param key was sent, use the value parsed on the client.\n              getCacheKeyForDynamicParam(\n                childParamValue,\n                '' as NormalizedSearch\n              )\n\n        childPartialVaryPath = appendLayoutVaryPath(\n          partialVaryPath,\n          childParamKey\n        )\n        childSegment = [childParamName, childParamKey, childParamType]\n        childDoesAppearInURL = true\n      } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        childPartialVaryPath = partialVaryPath\n        childSegment = childParamName\n        childDoesAppearInURL = doesStaticSegmentAppearInURL(childParamName)\n      }\n\n      // Only increment the index if the segment appears in the URL. If it's a\n      // \"virtual\" segment, like a route group, it remains the same.\n      const childPathnamePartsIndex = childDoesAppearInURL\n        ? pathnamePartsIndex + 1\n        : pathnamePartsIndex\n\n      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n      const childRequestKey = appendSegmentRequestKeyPart(\n        requestKey,\n        parallelRouteKey,\n        childRequestKeyPart\n      )\n      slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n        childPrefetch,\n        childSegment,\n        childPartialVaryPath,\n        childRequestKey,\n        pathnameParts,\n        childPathnamePartsIndex,\n        renderedSearch,\n        acc\n      )\n    }\n  } else {\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: prefetch.isRootLayout,\n    // This field is only relevant to dynamic routes. For a PPR/static route,\n    // there's always some partial loading state we can fetch.\n    hasLoadingBoundary: HasLoadingBoundary.SegmentHasLoadingBoundary,\n    hasRuntimePrefetch: prefetch.hasRuntimePrefetch,\n  }\n}\n\nfunction convertRootFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    ROOT_SEGMENT_REQUEST_KEY,\n    null,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  requestKey: SegmentRequestKey,\n  parentPartialVaryPath: PartialSegmentVaryPath | null,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  const originalSegment = flightRouterState[0]\n\n  let segment: FlightRouterStateSegment\n  let partialVaryPath: PartialSegmentVaryPath | null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  if (Array.isArray(originalSegment)) {\n    isPage = false\n    const paramCacheKey = originalSegment[1]\n    partialVaryPath = appendLayoutVaryPath(parentPartialVaryPath, paramCacheKey)\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    segment = originalSegment\n  } else {\n    // This segment does not have a param. Inherit the partial vary path of\n    // the parent.\n    partialVaryPath = parentPartialVaryPath\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n\n      // The navigation implementation expects the search params to be included\n      // in the segment. However, in the case of a static response, the search\n      // params are omitted. So the client needs to add them back in when reading\n      // from the Segment Cache.\n      //\n      // For consistency, we'll do this for dynamic responses, too.\n      //\n      // TODO: We should move search params out of FlightRouterState and handle\n      // them entirely on the client, similar to our plan for dynamic params.\n      segment = PAGE_SEGMENT_KEY\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      segment = originalSegment\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n\n  const parallelRoutes = flightRouterState[1]\n  for (let parallelRouteKey in parallelRoutes) {\n    const childRouterState = parallelRoutes[parallelRouteKey]\n    const childSegment = childRouterState[0]\n    // TODO: Eventually, the param values will not be included in the response\n    // from the server. We'll instead fill them in on the client by parsing\n    // the URL. This is where we'll do that.\n    const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n    const childRequestKey = appendSegmentRequestKeyPart(\n      requestKey,\n      parallelRouteKey,\n      childRequestKeyPart\n    )\n    const childTree = convertFlightRouterStateToRouteTree(\n      childRouterState,\n      childRequestKey,\n      partialVaryPath,\n      renderedSearch,\n      acc\n    )\n    if (slots === null) {\n      slots = {\n        [parallelRouteKey]: childTree,\n      }\n    } else {\n      slots[parallelRouteKey] = childTree\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: flightRouterState[4] === true,\n    hasLoadingBoundary:\n      flightRouterState[5] !== undefined\n        ? flightRouterState[5]\n        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n\n    // Non-static tree responses are only used by apps that haven't adopted\n    // Cache Components. So this is always false.\n    hasRuntimePrefetch: false,\n  }\n}\n\nexport function convertRouteTreeToFlightRouterState(\n  routeTree: RouteTree\n): FlightRouterState {\n  const parallelRoutes: Record<string, FlightRouterState> = {}\n  if (routeTree.slots !== null) {\n    for (const parallelRouteKey in routeTree.slots) {\n      parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(\n        routeTree.slots[parallelRouteKey]\n      )\n    }\n  }\n  const flightRouterState: FlightRouterState = [\n    routeTree.segment,\n    parallelRoutes,\n    null,\n    null,\n    routeTree.isRootLayout,\n  ]\n  return flightRouterState\n}\n\nexport async function fetchRouteOnCacheMiss(\n  entry: PendingRouteCacheEntry,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): Promise<PrefetchSubtaskResult<null> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  const pathname = key.pathname\n  const search = key.search\n  const nextUrl = key.nextUrl\n  const segmentPath = '/_tree' as SegmentRequestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    const url = new URL(pathname + search, location.origin)\n    let response\n    let urlAfterRedirects\n    if (isOutputExportMode) {\n      // In output: \"export\" mode, we can't use headers to request a particular\n      // segment. Instead, we encode the extra request information into the URL.\n      // This is not part of the \"public\" interface of the app; it's an internal\n      // Next.js implementation detail that the app developer should not need to\n      // concern themselves with.\n      //\n      // For example, to request a segment:\n      //\n      //   Path passed to <Link>:   /path/to/page\n      //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n      //\n      //   (This is not the exact protocol, just an illustration.)\n      //\n      // Before we do that, though, we need to account for redirects. Even in\n      // output: \"export\" mode, a proxy might redirect the page to a different\n      // location, but we shouldn't assume or expect that they also redirect all\n      // the segment files, too.\n      //\n      // To check whether the page is redirected, we perform a range request of\n      // the first N bytes of the HTML document. The canonical URL is determined\n      // from the response.\n      //\n      // Then we can use the canonical URL to request the route tree.\n      //\n      // NOTE: We could embed the route tree into the HTML document, to avoid\n      // a second request. We're not doing that currently because it would make\n      // the HTML document larger and affect normal page loads.\n      const htmlResponse = await fetch(url, {\n        headers: {\n          Range: DOC_PREFETCH_RANGE_HEADER_VALUE,\n        },\n      })\n      const partialHtml = await htmlResponse.text()\n      if (!doesExportedHtmlMatchBuildId(partialHtml, getAppBuildId())) {\n        // The target page is not part of this app, or it belongs to a\n        // different build.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n      urlAfterRedirects = htmlResponse.redirected\n        ? new URL(htmlResponse.url)\n        : url\n      response = await fetchPrefetchResponse(\n        addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),\n        headers\n      )\n    } else {\n      // \"Server\" mode. We can use request headers instead of the pathname.\n      // TODO: The eventual plan is to get rid of our custom request headers and\n      // encode everything into the URL, using a similar strategy to the\n      // \"output: export\" block above.\n      response = await fetchPrefetchResponse(url, headers)\n      urlAfterRedirects =\n        response !== null && response.redirected ? new URL(response.url) : url\n    }\n\n    if (\n      !response ||\n      !response.ok ||\n      // 204 is a Cache miss. Though theoretically this shouldn't happen when\n      // PPR is enabled, because we always respond to route tree requests, even\n      // if it needs to be blockingly generated on demand.\n      response.status === 204 ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // TODO: The canonical URL is the href without the origin. I think\n    // historically the reason for this is because the initial canonical URL\n    // gets passed as a prop to the top-level React component, which means it\n    // needs to be computed during SSR. If it were to include the origin, it\n    // would need to always be same as location.origin on the client, to prevent\n    // a hydration mismatch. To sidestep this complexity, we omit the origin.\n    //\n    // However, since this is neither a native URL object nor a fully qualified\n    // URL string, we need to be careful about how we use it. To prevent subtle\n    // mistakes, we should create a special type for it, instead of just string.\n    // Or, we should just use a (readonly) URL object instead. The type of the\n    // prop that we pass to seed the initial state does not need to be the same\n    // type as the state itself.\n    const canonicalUrl = createHrefFromUrl(urlAfterRedirects)\n\n    // Check whether the response varies based on the Next-Url header.\n    const varyHeader = response.headers.get('vary')\n    const couldBeIntercepted =\n      varyHeader !== null && varyHeader.includes(NEXT_URL)\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // This checks whether the response was served from the per-segment cache,\n    // rather than the old prefetching flow. If it fails, it implies that PPR\n    // is disabled on this route.\n    const routeIsPPREnabled =\n      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2' ||\n      // In output: \"export\" mode, we can't rely on response headers. But if we\n      // receive a well-formed response, we can assume it's a static response,\n      // because all data is static in this mode.\n      isOutputExportMode\n\n    if (routeIsPPREnabled) {\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData = await createFromNextReadableStream<RootTreePrefetch>(\n        prefetchStream,\n        headers\n      )\n      if (serverData.buildId !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Get the params that were used to render the target page. These may\n      // be different from the params in the request URL, if the page\n      // was rewritten.\n      const renderedPathname = getRenderedPathname(response)\n      const renderedSearch = getRenderedSearch(response)\n\n      // Convert the server-sent data into the RouteTree format used by the\n      // client cache.\n      //\n      // During this traversal, we accumulate additional data into this\n      // \"accumulator\" object.\n      const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n      const routeTree = convertRootTreePrefetchToRouteTree(\n        serverData,\n        renderedPathname,\n        renderedSearch,\n        acc\n      )\n      const metadataVaryPath = acc.metadataVaryPath\n      if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      const staleTimeMs = getStaleTimeMs(serverData.staleTime)\n      fulfillRouteCacheEntry(\n        entry,\n        routeTree,\n        metadataVaryPath,\n        Date.now() + staleTimeMs,\n        couldBeIntercepted,\n        canonicalUrl,\n        renderedSearch,\n        routeIsPPREnabled\n      )\n    } else {\n      // PPR is not enabled for this route. The server responds with a\n      // different format (FlightRouterState) that we need to convert.\n      // TODO: We will unify the responses eventually. I'm keeping the types\n      // separate for now because FlightRouterState has so many\n      // overloaded concerns.\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData =\n        await createFromNextReadableStream<NavigationFlightResponse>(\n          prefetchStream,\n          headers\n        )\n      if (serverData.b !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      writeDynamicTreeResponseIntoCache(\n        Date.now(),\n        task,\n        // The non-PPR response format is what we'd get if we prefetched these segments\n        // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n        FetchStrategy.LoadingBoundary,\n        response as RSCResponse<NavigationFlightResponse>,\n        serverData,\n        entry,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled\n      )\n    }\n\n    if (!couldBeIntercepted) {\n      // This route will never be intercepted. So we can use this entry for all\n      // requests to this route, regardless of the Next-Url header. This works\n      // because when reading the cache we always check for a valid\n      // non-intercepted entry first.\n\n      // Re-key the entry. The `set` implementation handles removing it from\n      // its previous position in the cache. We don't need to do anything to\n      // update the LRU, because the entry is already in it.\n      // TODO: Treat this as an upsert — should check if an entry already\n      // exists at the new keypath, and if so, whether we should keep that\n      // one instead.\n      const fulfilledVaryPath: RouteVaryPath = getFulfilledRouteVaryPath(\n        pathname,\n        search,\n        nextUrl,\n        couldBeIntercepted\n      )\n      const isRevalidation = false\n      setInCacheMap(routeCacheMap, fulfilledVaryPath, entry, isRevalidation)\n    }\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentOnCacheMiss(\n  route: FulfilledRouteCacheEntry,\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  //\n  // Segment fetches are non-blocking so we don't need to ping the scheduler\n  // on completion.\n\n  // Use the canonical URL to request the segment, not the original URL. These\n  // are usually the same, but the canonical URL will be different if the route\n  // tree response was redirected. To avoid an extra waterfall on every segment\n  // request, we pass the redirected URL instead of the original one.\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = routeKey.nextUrl\n\n  const requestKey = tree.requestKey\n  const normalizedRequestKey =\n    requestKey === ROOT_SEGMENT_REQUEST_KEY\n      ? // The root segment is a special case. To simplify the server-side\n        // handling of these requests, we encode the root segment path as\n        // `_index` instead of as an empty string. This should be treated as\n        // an implementation detail and not as a stable part of the protocol.\n        // It just needs to match the equivalent logic that happens when\n        // prerendering the responses. It should not leak outside of Next.js.\n        ('/_index' as SegmentRequestKey)\n      : requestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  const requestUrl = isOutputExportMode\n    ? // In output: \"export\" mode, we need to add the segment path to the URL.\n      addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey)\n    : url\n  try {\n    const response = await fetchPrefetchResponse(requestUrl, headers)\n    if (\n      !response ||\n      !response.ok ||\n      response.status === 204 || // Cache miss\n      // This checks whether the response was served from the per-segment cache,\n      // rather than the old prefetching flow. If it fails, it implies that PPR\n      // is disabled on this route. Theoretically this should never happen\n      // because we only issue requests for segments once we've verified that\n      // the route supports PPR.\n      (response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' &&\n        // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode) ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // Wrap the original stream in a new stream that never closes. That way the\n    // Flight client doesn't error if there's a hanging promise.\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(size) {\n        setSizeInCacheMap(segmentCacheEntry, size)\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<SegmentPrefetch>)\n    if (serverData.buildId !== getAppBuildId()) {\n      // The server build does not match the client. Treat as a 404. During\n      // an actual navigation, the router will trigger an MPA navigation.\n      // TODO: Consider moving the build ID to a response header so we can check\n      // it before decoding the response, and so there's one way of checking\n      // across all response types.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n    return {\n      value: fulfillSegmentCacheEntry(\n        segmentCacheEntry,\n        serverData.rsc,\n        serverData.loading,\n        // TODO: The server does not currently provide per-segment stale time.\n        // So we use the stale time of the route.\n        route.staleAt,\n        serverData.isPartial\n      ),\n      // Return a promise that resolves when the network connection closes, so\n      // the scheduler can track the number of concurrent network connections.\n      closed: closed.promise,\n    }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentPrefetchesUsingDynamicRequest(\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  dynamicRequestTree: FlightRouterState,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): Promise<PrefetchSubtaskResult<null> | null> {\n  const key = task.key\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = key.nextUrl\n\n  if (\n    spawnedEntries.size === 1 &&\n    spawnedEntries.has(route.metadata.requestKey)\n  ) {\n    // The only thing pending is the head. Instruct the server to\n    // skip over everything else.\n    dynamicRequestTree = MetadataOnlyRequestTree\n  }\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_STATE_TREE_HEADER]:\n      prepareFlightRouterStateForRequest(dynamicRequestTree),\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n  switch (fetchStrategy) {\n    case FetchStrategy.Full: {\n      // We omit the prefetch header from a full prefetch because it's essentially\n      // just a navigation request that happens ahead of time — it should include\n      // all the same data in the response.\n      break\n    }\n    case FetchStrategy.PPRRuntime: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '2'\n      break\n    }\n    case FetchStrategy.LoadingBoundary: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n      break\n    }\n    default: {\n      fetchStrategy satisfies never\n    }\n  }\n\n  try {\n    const response = await fetchPrefetchResponse(url, headers)\n    if (!response || !response.ok || !response.body) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    const renderedSearch = getRenderedSearch(response)\n    if (renderedSearch !== route.renderedSearch) {\n      // The search params that were used to render the target page are\n      // different from the search params in the request URL. This only happens\n      // when there's a dynamic rewrite in between the tree prefetch and the\n      // data prefetch.\n      // TODO: For now, since this is an edge case, we reject the prefetch, but\n      // the proper way to handle this is to evict the stale route tree entry\n      // then fill the cache with the new response.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    let fulfilledEntries: Array<FulfilledSegmentCacheEntry> | null = null\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n        // When processing a dynamic response, we don't know how large each\n        // individual segment is, so approximate by assiging each segment\n        // the average of the total response size.\n        if (fulfilledEntries === null) {\n          // Haven't received enough data yet to know which segments\n          // were included.\n          return\n        }\n        const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length\n        for (const entry of fulfilledEntries) {\n          setSizeInCacheMap(entry, averageSize)\n        }\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<NavigationFlightResponse>)\n\n    const isResponsePartial =\n      fetchStrategy === FetchStrategy.PPRRuntime\n        ? // A runtime prefetch may have holes.\n          serverData.rp?.[0] === true\n        : // Full and LoadingBoundary prefetches cannot have holes.\n          // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n          false\n\n    // Aside from writing the data into the cache, this function also returns\n    // the entries that were fulfilled, so we can streamingly update their sizes\n    // in the LRU as more data comes in.\n    fulfilledEntries = writeDynamicRenderResponseIntoCache(\n      Date.now(),\n      task,\n      fetchStrategy,\n      response as RSCResponse<NavigationFlightResponse>,\n      serverData,\n      isResponsePartial,\n      route,\n      spawnedEntries\n    )\n\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nfunction writeDynamicTreeResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  entry: PendingRouteCacheEntry,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  routeIsPPREnabled: boolean\n) {\n  // Get the URL that was used to render the target page. This may be different\n  // from the URL in the request URL, if the page was rewritten.\n  const renderedSearch = getRenderedSearch(response)\n\n  const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n  if (\n    // A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' ||\n    normalizedFlightDataResult.length !== 1\n  ) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n  const flightData = normalizedFlightDataResult[0]\n  if (!flightData.isRootRender) {\n    // Unexpected response format.\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const flightRouterState = flightData.tree\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n\n  // If the response contains dynamic holes, then we must conservatively assume\n  // that any individual segment might contain dynamic holes, and also the\n  // head. If it did not contain dynamic holes, then we can assume every segment\n  // and the head is completely static.\n  const isResponsePartial =\n    response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n\n  // Convert the server-sent data into the RouteTree format used by the\n  // client cache.\n  //\n  // During this traversal, we accumulate additional data into this\n  // \"accumulator\" object.\n  const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n  const routeTree = convertRootFlightRouterStateToRouteTree(\n    flightRouterState,\n    renderedSearch,\n    acc\n  )\n  const metadataVaryPath = acc.metadataVaryPath\n  if (metadataVaryPath === null) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const fulfilledEntry = fulfillRouteCacheEntry(\n    entry,\n    routeTree,\n    metadataVaryPath,\n    now + staleTimeMs,\n    couldBeIntercepted,\n    canonicalUrl,\n    renderedSearch,\n    routeIsPPREnabled\n  )\n\n  // If the server sent segment data as part of the response, we should write\n  // it into the cache to prevent a second, redundant prefetch request.\n  //\n  // TODO: When `clientSegmentCache` is enabled, the server does not include\n  // segment data when responding to a route tree prefetch request. However,\n  // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n  // the page is fully static), the normal check is bypassed and the server\n  // responds with the full page. This is a temporary situation until we can\n  // remove the \"client-only\" option. Then, we can delete this function call.\n  writeDynamicRenderResponseIntoCache(\n    now,\n    task,\n    fetchStrategy,\n    response,\n    serverData,\n    isResponsePartial,\n    fulfilledEntry,\n    null\n  )\n}\n\nfunction rejectSegmentEntriesIfStillPending(\n  entries: Map<SegmentRequestKey, SegmentCacheEntry>,\n  staleAt: number\n): Array<FulfilledSegmentCacheEntry> {\n  const fulfilledEntries = []\n  for (const entry of entries.values()) {\n    if (entry.status === EntryStatus.Pending) {\n      rejectSegmentCacheEntry(entry, staleAt)\n    } else if (entry.status === EntryStatus.Fulfilled) {\n      fulfilledEntries.push(entry)\n    }\n  }\n  return fulfilledEntries\n}\n\nfunction writeDynamicRenderResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  isResponsePartial: boolean,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry> | null\n): Array<FulfilledSegmentCacheEntry> | null {\n  if (serverData.b !== getAppBuildId()) {\n    // The server build does not match the client. Treat as a 404. During\n    // an actual navigation, the router will trigger an MPA navigation.\n    // TODO: Consider moving the build ID to a response header so we can check\n    // it before decoding the response, and so there's one way of checking\n    // across all response types.\n    if (spawnedEntries !== null) {\n      rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n    }\n    return null\n  }\n\n  const flightDatas = normalizeFlightData(serverData.f)\n  if (typeof flightDatas === 'string') {\n    // This means navigating to this route will result in an MPA navigation.\n    // TODO: We should cache this, too, so that the MPA navigation is immediate.\n    return null\n  }\n\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n  const staleAt = now + staleTimeMs\n\n  for (const flightData of flightDatas) {\n    const seedData = flightData.seedData\n    if (seedData !== null) {\n      // The data sent by the server represents only a subtree of the app. We\n      // need to find the part of the task tree that matches the response.\n      //\n      // segmentPath represents the parent path of subtree. It's a repeating\n      // pattern of parallel route key and segment:\n      //\n      //   [string, Segment, string, Segment, string, Segment, ...]\n      const segmentPath = flightData.segmentPath\n      let tree = route.tree\n      for (let i = 0; i < segmentPath.length; i += 2) {\n        const parallelRouteKey: string = segmentPath[i]\n        if (tree?.slots?.[parallelRouteKey] !== undefined) {\n          tree = tree.slots[parallelRouteKey]\n        } else {\n          if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n          }\n          return null\n        }\n      }\n\n      writeSeedDataIntoCache(\n        now,\n        task,\n        fetchStrategy,\n        route,\n        tree,\n        staleAt,\n        seedData,\n        isResponsePartial,\n        spawnedEntries\n      )\n    }\n\n    const head = flightData.head\n    if (head !== null) {\n      fulfillEntrySpawnedByRuntimePrefetch(\n        now,\n        fetchStrategy,\n        route,\n        head,\n        null,\n        flightData.isHeadPartial,\n        staleAt,\n        route.metadata,\n        spawnedEntries\n      )\n    }\n  }\n  // Any entry that's still pending was intentionally not rendered by the\n  // server, because it was inside the loading boundary. Mark them as rejected\n  // so we know not to fetch them again.\n  // TODO: If PPR is enabled on some routes but not others, then it's possible\n  // that a different page is able to do a per-segment prefetch of one of the\n  // segments we're marking as rejected here. We should mark on the segment\n  // somehow that the reason for the rejection is because of a non-PPR prefetch.\n  // That way a per-segment prefetch knows to disregard the rejection.\n  if (spawnedEntries !== null) {\n    const fulfilledEntries = rejectSegmentEntriesIfStillPending(\n      spawnedEntries,\n      now + 10 * 1000\n    )\n    return fulfilledEntries\n  }\n  return null\n}\n\nfunction writeSeedDataIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  staleAt: number,\n  seedData: CacheNodeSeedData,\n  isResponsePartial: boolean,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // This function is used to write the result of a runtime server request\n  // (CacheNodeSeedData) into the prefetch cache.\n  const rsc = seedData[0]\n  const loading = seedData[2]\n  const isPartial = rsc === null || isResponsePartial\n  fulfillEntrySpawnedByRuntimePrefetch(\n    now,\n    fetchStrategy,\n    route,\n    rsc,\n    loading,\n    isPartial,\n    staleAt,\n    tree,\n    entriesOwnedByCurrentTask\n  )\n\n  // Recursively write the child data into the cache.\n  const slots = tree.slots\n  if (slots !== null) {\n    const seedDataChildren = seedData[1]\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childSeedData: CacheNodeSeedData | null | void =\n        seedDataChildren[parallelRouteKey]\n      if (childSeedData !== null && childSeedData !== undefined) {\n        writeSeedDataIntoCache(\n          now,\n          task,\n          fetchStrategy,\n          route,\n          childTree,\n          staleAt,\n          childSeedData,\n          isResponsePartial,\n          entriesOwnedByCurrentTask\n        )\n      }\n    }\n  }\n}\n\nfunction fulfillEntrySpawnedByRuntimePrefetch(\n  now: number,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n  staleAt: number,\n  tree: RouteTree,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // We should only write into cache entries that are owned by us. Or create\n  // a new one and write into that. We must never write over an entry that was\n  // created by a different task, because that causes data races.\n  const ownedEntry =\n    entriesOwnedByCurrentTask !== null\n      ? entriesOwnedByCurrentTask.get(tree.requestKey)\n      : undefined\n  if (ownedEntry !== undefined) {\n    fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial)\n  } else {\n    // There's no matching entry. Attempt to create a new one.\n    const possiblyNewEntry = readOrCreateSegmentCacheEntry(\n      now,\n      fetchStrategy,\n      route,\n      tree\n    )\n    if (possiblyNewEntry.status === EntryStatus.Empty) {\n      // Confirmed this is a new entry. We can fulfill it.\n      const newEntry = possiblyNewEntry\n      fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(newEntry, fetchStrategy),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n    } else {\n      // There was already an entry in the cache. But we may be able to\n      // replace it with the new one from the server.\n      const newEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(\n          createDetachedSegmentCacheEntry(staleAt),\n          fetchStrategy\n        ),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n      upsertSegmentEntry(\n        now,\n        getSegmentVaryPathForRequest(fetchStrategy, tree),\n        newEntry\n      )\n    }\n  }\n}\n\nasync function fetchPrefetchResponse<T>(\n  url: URL,\n  headers: RequestHeaders\n): Promise<RSCResponse<T> | null> {\n  const fetchPriority = 'low'\n  // When issuing a prefetch request, don't immediately decode the response; we\n  // use the lower level `createFromResponse` API instead because we need to do\n  // some extra processing of the response stream. See\n  // `createPrefetchResponseStream` for more details.\n  const shouldImmediatelyDecode = false\n  const response = await createFetch<T>(\n    url,\n    headers,\n    fetchPriority,\n    shouldImmediatelyDecode\n  )\n  if (!response.ok) {\n    return null\n  }\n\n  // Check the content type\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n  } else {\n    const contentType = response.headers.get('content-type')\n    const isFlightResponse =\n      contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n    if (!isFlightResponse) {\n      return null\n    }\n  }\n  return response\n}\n\nfunction createPrefetchResponseStream(\n  originalFlightStream: ReadableStream<Uint8Array>,\n  onStreamClose: () => void,\n  onResponseSizeUpdate: (size: number) => void\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  //\n  // While processing the original stream, we also incrementally update the size\n  // of the cache entry in the LRU.\n  let totalByteLength = 0\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n\n          // Incrementally update the size of the cache entry in the LRU.\n          // NOTE: Since prefetch responses are delivered in a single chunk,\n          // it's not really necessary to do this streamingly, but I'm doing it\n          // anyway in case this changes in the future.\n          totalByteLength += value.byteLength\n          onResponseSizeUpdate(totalByteLength)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream. We do notify the caller, though.\n        onStreamClose()\n        return\n      }\n    },\n  })\n}\n\nfunction addSegmentPathToUrlInOutputExportMode(\n  url: URL,\n  segmentPath: SegmentRequestKey\n): URL {\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we cannot use a header to encode the segment\n    // path. Instead, we append it to the end of the pathname.\n    const staticUrl = new URL(url)\n    const routeDir = staticUrl.pathname.endsWith('/')\n      ? staticUrl.pathname.slice(0, -1)\n      : staticUrl.pathname\n    const staticExportFilename =\n      convertSegmentPathToStaticExportFilename(segmentPath)\n    staticUrl.pathname = `${routeDir}/${staticExportFilename}`\n    return staticUrl\n  }\n  return url\n}\n\n/**\n * Checks whether the new fetch strategy is likely to provide more content than the old one.\n *\n * Generally, when an app uses dynamic data, a \"more specific\" fetch strategy is expected to provide more content:\n * - `LoadingBoundary` only provides static layouts\n * - `PPR` can provide shells for each segment (even for segments that use dynamic data)\n * - `PPRRuntime` can additionally include content that uses searchParams, params, or cookies\n * - `Full` includes all the content, even if it uses dynamic data\n *\n * However, it's possible that a more specific fetch strategy *won't* give us more content if:\n * - a segment is fully static\n *   (then, `PPR`/`PPRRuntime`/`Full` will all yield equivalent results)\n * - providing searchParams/params/cookies doesn't reveal any more content, e.g. because of an `await connection()`\n *   (then, `PPR` and `PPRRuntime` will yield equivalent results, only `Full` will give us more)\n * Because of this, when comparing two segments, we should also check if the existing segment is partial.\n * If it's not partial, then there's no need to prefetch it again, even using a \"more specific\" strategy.\n * There's currently no way to know if `PPRRuntime` will yield more data that `PPR`, so we have to assume it will.\n *\n * Also note that, in practice, we don't expect to be comparing `LoadingBoundary` to `PPR`/`PPRRuntime`,\n * because a non-PPR-enabled route wouldn't ever use the latter strategies. It might however use `Full`.\n */\nexport function canNewFetchStrategyProvideMoreContent(\n  currentStrategy: FetchStrategy,\n  newStrategy: FetchStrategy\n): boolean {\n  return currentStrategy < newStrategy\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { fetchServerResponse } from '../router-reducer/fetch-server-response'\nimport {\n  startPPRNavigation,\n  listenForDynamicRequest,\n  type Task as PPRNavigationTask,\n} from '../router-reducer/ppr-navigations'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport {\n  EntryStatus,\n  readRouteCacheEntry,\n  readSegmentCacheEntry,\n  waitForSegmentCacheEntry,\n  requestOptimisticRouteCacheEntry,\n  type RouteTree,\n  type FulfilledRouteCacheEntry,\n} from './cache'\nimport { createCacheKey } from './cache-key'\nimport { addSearchParamsIfPageSegment } from '../../../shared/lib/segment'\nimport { NavigationResultTag } from './types'\n\ntype MPANavigationResult = {\n  tag: NavigationResultTag.MPA\n  data: string\n}\n\ntype NoOpNavigationResult = {\n  tag: NavigationResultTag.NoOp\n  data: {\n    canonicalUrl: string\n    shouldScroll: boolean\n  }\n}\n\ntype SuccessfulNavigationResult = {\n  tag: NavigationResultTag.Success\n  data: {\n    flightRouterState: FlightRouterState\n    cacheNode: CacheNode\n    canonicalUrl: string\n    renderedSearch: string\n    scrollableSegments: Array<FlightSegmentPath>\n    shouldScroll: boolean\n    hash: string\n  }\n}\n\ntype AsyncNavigationResult = {\n  tag: NavigationResultTag.Async\n  data: Promise<\n    MPANavigationResult | NoOpNavigationResult | SuccessfulNavigationResult\n  >\n}\n\nexport type NavigationResult =\n  | MPANavigationResult\n  | SuccessfulNavigationResult\n  | NoOpNavigationResult\n  | AsyncNavigationResult\n\n/**\n * Navigate to a new URL, using the Segment Cache to construct a response.\n *\n * To allow for synchronous navigations whenever possible, this is not an async\n * function. It returns a promise only if there's no matching prefetch in\n * the cache. Otherwise it returns an immediate result and uses Suspense/RSC to\n * stream in any missing data.\n */\nexport function navigate(\n  url: URL,\n  currentUrl: URL,\n  currentCacheNode: CacheNode,\n  currentFlightRouterState: FlightRouterState,\n  nextUrl: string | null,\n  shouldScroll: boolean,\n  accumulation: { collectedDebugInfo?: Array<unknown> }\n): NavigationResult {\n  const now = Date.now()\n  const href = url.href\n\n  // We special case navigations to the exact same URL as the current location.\n  // It's a common UI pattern for apps to refresh when you click a link to the\n  // current page. So when this happens, we refresh the dynamic data in the page\n  // segments.\n  //\n  // Note that this does not apply if the any part of the hash or search query\n  // has changed. This might feel a bit weird but it makes more sense when you\n  // consider that the way to trigger this behavior is to click the same link\n  // multiple times.\n  //\n  // TODO: We should probably refresh the *entire* route when this case occurs,\n  // not just the page segments. Essentially treating it the same as a refresh()\n  // triggered by an action, which is the more explicit way of modeling the UI\n  // pattern described above.\n  //\n  // Also note that this only refreshes the dynamic data, not static/ cached\n  // data. If the page segment is fully static and prefetched, the request is\n  // skipped. (This is also how refresh() works.)\n  const isSamePageNavigation =\n    // TODO: This is not the only place we read from the location, but we should\n    // consider storing the current URL in the router state instead of reading\n    // from the location object. In practice I don't think this matters much\n    // since we keep them in sync anyway, but having two sources of truth can\n    // lead to subtle bugs and race conditions.\n    href === window.location.href\n\n  const cacheKey = createCacheKey(href, nextUrl)\n  const route = readRouteCacheEntry(now, cacheKey)\n  if (route !== null && route.status === EntryStatus.Fulfilled) {\n    // We have a matching prefetch.\n    const snapshot = readRenderSnapshotFromCache(now, route, route.tree)\n    const prefetchFlightRouterState = snapshot.flightRouterState\n    const prefetchSeedData = snapshot.seedData\n    const headSnapshot = readHeadSnapshotFromCache(now, route)\n    const prefetchHead = headSnapshot.rsc\n    const isPrefetchHeadPartial = headSnapshot.isPartial\n    // TODO: The \"canonicalUrl\" stored in the cache doesn't include the hash,\n    // because hash entries do not vary by hash fragment. However, the one\n    // we set in the router state *does* include the hash, and it's used to\n    // sync with the actual browser location. To make this less of a refactor\n    // hazard, we should always track the hash separately from the rest of\n    // the URL.\n    const newCanonicalUrl = route.canonicalUrl + url.hash\n    const renderedSearch = route.renderedSearch\n    return navigateUsingPrefetchedRouteTree(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      isSamePageNavigation,\n      currentCacheNode,\n      currentFlightRouterState,\n      prefetchFlightRouterState,\n      prefetchSeedData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      newCanonicalUrl,\n      renderedSearch,\n      shouldScroll,\n      url.hash\n    )\n  }\n\n  // There was no matching route tree in the cache. Let's see if we can\n  // construct an \"optimistic\" route tree.\n  //\n  // Do not construct an optimistic route tree if there was a cache hit, but\n  // the entry has a rejected status, since it may have been rejected due to a\n  // rewrite or redirect based on the search params.\n  //\n  // TODO: There are multiple reasons a prefetch might be rejected; we should\n  // track them explicitly and choose what to do here based on that.\n  if (route === null || route.status !== EntryStatus.Rejected) {\n    const optimisticRoute = requestOptimisticRouteCacheEntry(now, url, nextUrl)\n    if (optimisticRoute !== null) {\n      // We have an optimistic route tree. Proceed with the normal flow.\n      const snapshot = readRenderSnapshotFromCache(\n        now,\n        optimisticRoute,\n        optimisticRoute.tree\n      )\n      const prefetchFlightRouterState = snapshot.flightRouterState\n      const prefetchSeedData = snapshot.seedData\n      const headSnapshot = readHeadSnapshotFromCache(now, optimisticRoute)\n      const prefetchHead = headSnapshot.rsc\n      const isPrefetchHeadPartial = headSnapshot.isPartial\n      const newCanonicalUrl = optimisticRoute.canonicalUrl + url.hash\n      const newRenderedSearch = optimisticRoute.renderedSearch\n      return navigateUsingPrefetchedRouteTree(\n        now,\n        url,\n        currentUrl,\n        nextUrl,\n        isSamePageNavigation,\n        currentCacheNode,\n        currentFlightRouterState,\n        prefetchFlightRouterState,\n        prefetchSeedData,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newCanonicalUrl,\n        newRenderedSearch,\n        shouldScroll,\n        url.hash\n      )\n    }\n  }\n\n  // There's no matching prefetch for this route in the cache.\n  let collectedDebugInfo = accumulation.collectedDebugInfo ?? []\n  if (accumulation.collectedDebugInfo === undefined) {\n    collectedDebugInfo = accumulation.collectedDebugInfo = []\n  }\n  return {\n    tag: NavigationResultTag.Async,\n    data: navigateDynamicallyWithNoPrefetch(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      isSamePageNavigation,\n      currentCacheNode,\n      currentFlightRouterState,\n      shouldScroll,\n      url.hash,\n      collectedDebugInfo\n    ),\n  }\n}\n\nfunction navigateUsingPrefetchedRouteTree(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  isSamePageNavigation: boolean,\n  currentCacheNode: CacheNode,\n  currentFlightRouterState: FlightRouterState,\n  prefetchFlightRouterState: FlightRouterState,\n  prefetchSeedData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  canonicalUrl: string,\n  renderedSearch: string,\n  shouldScroll: boolean,\n  hash: string\n): SuccessfulNavigationResult | NoOpNavigationResult | MPANavigationResult {\n  // Recursively construct a prefetch tree by reading from the Segment Cache. To\n  // maintain compatibility, we output the same data structures as the old\n  // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n  // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n  // read from the Segment Cache directly. It's only structured this way for now\n  // so we can share code with the old prefetching implementation.\n  const scrollableSegments: Array<FlightSegmentPath> = []\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    prefetchFlightRouterState,\n    prefetchSeedData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    scrollableSegments\n  )\n  if (task !== null) {\n    const dynamicRequestTree = task.dynamicRequestTree\n    if (dynamicRequestTree !== null) {\n      const promiseForDynamicServerResponse = fetchServerResponse(\n        new URL(canonicalUrl, url.origin),\n        {\n          flightRouterState: dynamicRequestTree,\n          nextUrl,\n        }\n      )\n      listenForDynamicRequest(task, promiseForDynamicServerResponse)\n    } else {\n      // The prefetched tree does not contain dynamic holes — it's\n      // fully static. We can skip the dynamic request.\n    }\n    return navigationTaskToResult(\n      task,\n      currentCacheNode,\n      canonicalUrl,\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash\n    )\n  }\n  // The server sent back an empty tree patch. There's nothing to update, except\n  // possibly the URL.\n  return {\n    tag: NavigationResultTag.NoOp,\n    data: {\n      canonicalUrl,\n      shouldScroll,\n    },\n  }\n}\n\nfunction navigationTaskToResult(\n  task: PPRNavigationTask,\n  currentCacheNode: CacheNode,\n  canonicalUrl: string,\n  renderedSearch: string,\n  scrollableSegments: Array<FlightSegmentPath>,\n  shouldScroll: boolean,\n  hash: string\n): SuccessfulNavigationResult | MPANavigationResult {\n  const flightRouterState = task.route\n  if (flightRouterState === null) {\n    // When no router state is provided, it signals that we should perform an\n    // MPA navigation.\n    return {\n      tag: NavigationResultTag.MPA,\n      data: canonicalUrl,\n    }\n  }\n  const newCacheNode = task.node\n  return {\n    tag: NavigationResultTag.Success,\n    data: {\n      flightRouterState,\n      cacheNode: newCacheNode !== null ? newCacheNode : currentCacheNode,\n      canonicalUrl,\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash,\n    },\n  }\n}\n\nfunction readRenderSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): { flightRouterState: FlightRouterState; seedData: CacheNodeSeedData } {\n  let childRouterStates: { [parallelRouteKey: string]: FlightRouterState } = {}\n  let childSeedDatas: {\n    [parallelRouteKey: string]: CacheNodeSeedData | null\n  } = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childResult = readRenderSnapshotFromCache(now, route, childTree)\n      childRouterStates[parallelRouteKey] = childResult.flightRouterState\n      childSeedDatas[parallelRouteKey] = childResult.seedData\n    }\n  }\n\n  let rsc: React.ReactNode | null = null\n  let loading: LoadingModuleData | Promise<LoadingModuleData> = null\n  let isPartial: boolean = true\n\n  const segmentEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        // Happy path: a cache hit\n        rsc = segmentEntry.rsc\n        loading = segmentEntry.loading\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        // We haven't received data for this segment yet, but there's already\n        // an in-progress request. Since it's extremely likely to arrive\n        // before the dynamic data response, we might as well use it.\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        loading = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.loading : null\n        )\n        // Since we don't know yet whether the segment is partial or fully\n        // static, we must assume it's partial; we can't skip the\n        // dynamic request.\n        isPartial = true\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n\n  // The navigation implementation expects the search params to be\n  // included in the segment. However, the Segment Cache tracks search\n  // params separately from the rest of the segment key. So we need to\n  // add them back here.\n  //\n  // See corresponding comment in convertFlightRouterStateToTree.\n  //\n  // TODO: What we should do instead is update the navigation diffing\n  // logic to compare search params explicitly. This is a temporary\n  // solution until more of the Segment Cache implementation has settled.\n  const segment = addSearchParamsIfPageSegment(\n    tree.segment,\n    Object.fromEntries(new URLSearchParams(route.renderedSearch))\n  )\n\n  // We don't need this information in a render snapshot, so this can just be a placeholder.\n  const hasRuntimePrefetch = false\n\n  return {\n    flightRouterState: [\n      segment,\n      childRouterStates,\n      null,\n      null,\n      tree.isRootLayout,\n    ],\n    seedData: [rsc, childSeedDatas, loading, isPartial, hasRuntimePrefetch],\n  }\n}\n\nfunction readHeadSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry\n): { rsc: HeadData; isPartial: boolean } {\n  // Same as readRenderSnapshotFromCache, but for the head\n  let rsc: React.ReactNode | null = null\n  let isPartial: boolean = true\n  const segmentEntry = readSegmentCacheEntry(now, route.metadata.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        rsc = segmentEntry.rsc\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        isPartial = true\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n  return { rsc, isPartial }\n}\n\nasync function navigateDynamicallyWithNoPrefetch(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  isSamePageNavigation: boolean,\n  currentCacheNode: CacheNode,\n  currentFlightRouterState: FlightRouterState,\n  shouldScroll: boolean,\n  hash: string,\n  collectedDebugInfo: Array<unknown>\n): Promise<\n  MPANavigationResult | SuccessfulNavigationResult | NoOpNavigationResult\n> {\n  // Runs when a navigation happens but there's no cached prefetch we can use.\n  // Don't bother to wait for a prefetch response; go straight to a full\n  // navigation that contains both static and dynamic data in a single stream.\n  // (This is unlike the old navigation implementation, which instead blocks\n  // the dynamic request until a prefetch request is received.)\n  //\n  // To avoid duplication of logic, we're going to pretend that the tree\n  // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n  // use the same server response to write the actual data into the CacheNode\n  // tree. So it's the same flow as the \"happy path\" (prefetch, then\n  // navigation), except we use a single server response for both stages.\n\n  const promiseForDynamicServerResponse = fetchServerResponse(url, {\n    flightRouterState: currentFlightRouterState,\n    nextUrl,\n  })\n  const result = await promiseForDynamicServerResponse\n  if (typeof result === 'string') {\n    // This is an MPA navigation.\n    const newUrl = result\n    return {\n      tag: NavigationResultTag.MPA,\n      data: newUrl,\n    }\n  }\n\n  const {\n    flightData,\n    canonicalUrl,\n    renderedSearch,\n    debugInfo: debugInfoFromResponse,\n  } = result\n  if (debugInfoFromResponse !== null) {\n    collectedDebugInfo.push(...debugInfoFromResponse)\n  }\n\n  // Since the response format of dynamic requests and prefetches is slightly\n  // different, we'll need to massage the data a bit. Create FlightRouterState\n  // tree that simulates what we'd receive as the result of a prefetch.\n  const prefetchFlightRouterState = simulatePrefetchTreeUsingDynamicTreePatch(\n    currentFlightRouterState,\n    flightData\n  )\n\n  // In our simulated prefetch payload, we pretend that there's no seed data\n  // nor a prefetch head.\n  const prefetchSeedData = null\n  const prefetchHead = null\n  const isPrefetchHeadPartial = true\n\n  // Now we proceed exactly as we would for normal navigation.\n  const scrollableSegments: Array<FlightSegmentPath> = []\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    prefetchFlightRouterState,\n    prefetchSeedData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    scrollableSegments\n  )\n  if (task !== null) {\n    // In this case, we've already sent the dynamic request, so we don't\n    // actually use the request tree created by `startPPRNavigation`,\n    // except to check if it contains dynamic holes.\n    //\n    // This is almost always true, but it could be false if all the segment data\n    // was present in the cache, but the route tree was not. E.g. navigating\n    // to a URL that was not prefetched but rewrites to a different URL\n    // that was.\n    const hasDynamicHoles = task.dynamicRequestTree !== null\n    if (hasDynamicHoles) {\n      listenForDynamicRequest(task, promiseForDynamicServerResponse)\n    } else {\n      // The prefetched tree does not contain dynamic holes — it's\n      // fully static. We don't need to process the server response further.\n    }\n    return navigationTaskToResult(\n      task,\n      currentCacheNode,\n      createHrefFromUrl(canonicalUrl),\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash\n    )\n  }\n  // The server sent back an empty tree patch. There's nothing to update, except\n  // possibly the URL.\n  return {\n    tag: NavigationResultTag.NoOp,\n    data: {\n      canonicalUrl: createHrefFromUrl(canonicalUrl),\n      shouldScroll,\n    },\n  }\n}\n\nfunction simulatePrefetchTreeUsingDynamicTreePatch(\n  currentTree: FlightRouterState,\n  flightData: Array<NormalizedFlightData>\n): FlightRouterState {\n  // Takes the current FlightRouterState and applies the router state patch\n  // received from the server, to create a full FlightRouterState tree that we\n  // can pretend was returned by a prefetch.\n  //\n  // (It sounds similar to what applyRouterStatePatch does, but it doesn't need\n  // to handle stuff like interception routes or diffing since that will be\n  // handled later.)\n  let baseTree = currentTree\n  for (const { segmentPath, tree: treePatch } of flightData) {\n    // If the server sends us multiple tree patches, we only need to clone the\n    // base tree when applying the first patch. After the first patch, we can\n    // apply the remaining patches in place without copying.\n    const canMutateInPlace = baseTree !== currentTree\n    baseTree = simulatePrefetchTreeUsingDynamicTreePatchImpl(\n      baseTree,\n      treePatch,\n      segmentPath,\n      canMutateInPlace,\n      0\n    )\n  }\n\n  return baseTree\n}\n\nfunction simulatePrefetchTreeUsingDynamicTreePatchImpl(\n  baseRouterState: FlightRouterState,\n  patch: FlightRouterState,\n  segmentPath: FlightSegmentPath,\n  canMutateInPlace: boolean,\n  index: number\n) {\n  if (index === segmentPath.length) {\n    // We reached the part of the tree that we need to patch.\n    return patch\n  }\n\n  // segmentPath represents the parent path of subtree. It's a repeating\n  // pattern of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // This path tells us which part of the base tree to apply the tree patch.\n  //\n  // NOTE: In the case of a fully dynamic request with no prefetch, we receive\n  // the FlightRouterState patch in the same request as the dynamic data.\n  // Therefore we don't need to worry about diffing the segment values; we can\n  // assume the server sent us a correct result.\n  const updatedParallelRouteKey: string = segmentPath[index]\n  // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n\n  const baseChildren = baseRouterState[1]\n  const newChildren: { [parallelRouteKey: string]: FlightRouterState } = {}\n  for (const parallelRouteKey in baseChildren) {\n    if (parallelRouteKey === updatedParallelRouteKey) {\n      const childBaseRouterState = baseChildren[parallelRouteKey]\n      newChildren[parallelRouteKey] =\n        simulatePrefetchTreeUsingDynamicTreePatchImpl(\n          childBaseRouterState,\n          patch,\n          segmentPath,\n          canMutateInPlace,\n          // Advance the index by two and keep cloning until we reach\n          // the end of the segment path.\n          index + 2\n        )\n    } else {\n      // This child is not being patched. Copy it over as-is.\n      newChildren[parallelRouteKey] = baseChildren[parallelRouteKey]\n    }\n  }\n\n  if (canMutateInPlace) {\n    // We can mutate the base tree in place, because the base tree is already\n    // a clone.\n    baseRouterState[1] = newChildren\n    return baseRouterState\n  }\n\n  // Clone all the fields except the children.\n  //\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n","import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../shared/lib/app-router-types'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  Mutable,\n  NavigateAction,\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\n\nimport {\n  navigate as navigateUsingSegmentCache,\n  type NavigationResult,\n} from '../../segment-cache/navigation'\nimport { NavigationResultTag } from '../../segment-cache/types'\nimport { getStaleTimeMs } from '../../segment-cache/cache'\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nexport const STATIC_STALETIME_MS = getStaleTimeMs(\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME)\n)\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nexport function generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nfunction handleNavigationResult(\n  url: URL,\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  pendingPush: boolean,\n  result: NavigationResult\n): ReducerState {\n  switch (result.tag) {\n    case NavigationResultTag.MPA: {\n      // Perform an MPA navigation.\n      const newUrl = result.data\n      return handleExternalUrl(state, mutable, newUrl, pendingPush)\n    }\n    case NavigationResultTag.NoOp: {\n      // The server responded with no change to the current page. However, if\n      // the URL changed, we still need to update that.\n      const newCanonicalUrl = result.data.canonicalUrl\n      mutable.canonicalUrl = newCanonicalUrl\n\n      // Check if the only thing that changed was the hash fragment.\n      const oldUrl = new URL(state.canonicalUrl, url)\n      const onlyHashChange =\n        // We don't need to compare the origins, because client-driven\n        // navigations are always same-origin.\n        url.pathname === oldUrl.pathname &&\n        url.search === oldUrl.search &&\n        url.hash !== oldUrl.hash\n      if (onlyHashChange) {\n        // The only updated part of the URL is the hash.\n        mutable.onlyHashChange = true\n        mutable.shouldScroll = result.data.shouldScroll\n        mutable.hashFragment = url.hash\n        // Setting this to an empty array triggers a scroll for all new and\n        // updated segments. See `ScrollAndFocusHandler` for more details.\n        mutable.scrollableSegments = []\n      }\n\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Success: {\n      // Received a new result.\n      mutable.cache = result.data.cacheNode\n      mutable.patchedTree = result.data.flightRouterState\n      mutable.renderedSearch = result.data.renderedSearch\n      mutable.canonicalUrl = result.data.canonicalUrl\n      mutable.scrollableSegments = result.data.scrollableSegments\n      mutable.shouldScroll = result.data.shouldScroll\n      mutable.hashFragment = result.data.hash\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Async: {\n      return result.data.then(\n        (asyncResult) =>\n          handleNavigationResult(url, state, mutable, pendingPush, asyncResult),\n        // If the navigation failed, return the current state.\n        // TODO: This matches the current behavior but we need to do something\n        // better here if the network fails.\n        () => {\n          return state\n        }\n      )\n    }\n    default: {\n      result satisfies never\n      return state\n    }\n  }\n}\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n  const mutable: Mutable = {}\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n\n  mutable.preserveCustomHistoryState = false\n  mutable.pendingPush = pendingPush\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return handleExternalUrl(state, mutable, href, pendingPush)\n  }\n\n  // Temporary glue code between the router reducer and the new navigation\n  // implementation. Eventually we'll rewrite the router reducer to a\n  // state machine.\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const result = navigateUsingSegmentCache(\n    url,\n    currentUrl,\n    state.cache,\n    state.tree,\n    state.nextUrl,\n    shouldScroll,\n    mutable\n  )\n  return handleNavigationResult(url, state, mutable, pendingPush, result)\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  CacheNodeSeedData,\n} from '../../../shared/lib/app-router-types'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\nexport function fillLazyItemsTillLeafWithHead(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode | undefined,\n  routerState: FlightRouterState,\n  cacheNodeSeedData: CacheNodeSeedData | null,\n  head: React.ReactNode\n): void {\n  const isLastSegment = Object.keys(routerState[1]).length === 0\n  if (isLastSegment) {\n    newCache.head = head\n    return\n  }\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const parallelRouteState = routerState[1][key]\n    const segmentForParallelRoute = parallelRouteState[0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n\n    // TODO: We should traverse the cacheNodeSeedData tree instead of the router\n    // state tree. Ideally, they would always be the same shape, but because of\n    // the loading.js pattern, cacheNodeSeedData sometimes only represents a\n    // partial tree. That's why this node is sometimes null. Once PPR lands,\n    // loading.js will no longer have special behavior and we can traverse the\n    // data tree instead.\n    //\n    // We should also consider merging the router state tree and the data tree\n    // in the response format, so that we don't have to send the keys twice.\n    // Then the client can convert them into separate representations.\n    const parallelSeedData =\n      cacheNodeSeedData !== null && cacheNodeSeedData[1][key] !== undefined\n        ? cacheNodeSeedData[1][key]\n        : null\n    if (existingCache) {\n      const existingParallelRoutesCacheNode =\n        existingCache.parallelRoutes.get(key)\n      if (existingParallelRoutesCacheNode) {\n        let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n        const existingCacheNode = parallelRouteCacheNode.get(cacheKey)\n        let newCacheNode: CacheNode\n        if (parallelSeedData !== null) {\n          // New data was sent from the server.\n          const seedNode = parallelSeedData[0]\n          const loading = parallelSeedData[2]\n          newCacheNode = {\n            lazyData: null,\n            rsc: seedNode,\n            // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n            // this path during a navigation, but until PPR is fully implemented\n            // yet it's possible the existing node does have a non-null\n            // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n            // old behavior — no PPR value.\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            loading,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n            navigatedAt,\n          }\n        } else {\n          // No data available for this node. This will trigger a lazy fetch\n          // during render.\n          newCacheNode = {\n            lazyData: null,\n            rsc: null,\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n            loading: null,\n            navigatedAt,\n          }\n        }\n\n        // Overrides the cache key with the new cache node.\n        parallelRouteCacheNode.set(cacheKey, newCacheNode)\n        // Traverse deeper to apply the head / fill lazy items till the head.\n        fillLazyItemsTillLeafWithHead(\n          navigatedAt,\n          newCacheNode,\n          existingCacheNode,\n          parallelRouteState,\n          parallelSeedData ? parallelSeedData : null,\n          head\n        )\n\n        newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n        continue\n      }\n    }\n\n    let newCacheNode: CacheNode\n    if (parallelSeedData !== null) {\n      // New data was sent from the server.\n      const seedNode = parallelSeedData[0]\n      const loading = parallelSeedData[2]\n      newCacheNode = {\n        lazyData: null,\n        rsc: seedNode,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading,\n        navigatedAt,\n      }\n    } else {\n      // No data available for this node. This will trigger a lazy fetch\n      // during render.\n      newCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt,\n      }\n    }\n\n    const existingParallelRoutes = newCache.parallelRoutes.get(key)\n    if (existingParallelRoutes) {\n      existingParallelRoutes.set(cacheKey, newCacheNode)\n    } else {\n      newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))\n    }\n\n    fillLazyItemsTillLeafWithHead(\n      navigatedAt,\n      newCacheNode,\n      undefined,\n      parallelRouteState,\n      parallelSeedData,\n      head\n    )\n  }\n}\n","import type {\n  CacheNode,\n  FlightRouterState,\n} from '../../../shared/lib/app-router-types'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\n/**\n * Invalidate cache one level down from the router state.\n */\nexport function invalidateCacheByRouterState(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  routerState: FlightRouterState\n): void {\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const segmentForParallelRoute = routerState[1][key][0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n    const existingParallelRoutesCacheNode =\n      existingCache.parallelRoutes.get(key)\n    if (existingParallelRoutesCacheNode) {\n      let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n      parallelRouteCacheNode.delete(cacheKey)\n      newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n    }\n  }\n}\n","import type { CacheNode, Segment } from '../../../shared/lib/app-router-types'\nimport { invalidateCacheByRouterState } from './invalidate-cache-by-router-state'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\n\n/**\n * Common logic for filling cache with new sub tree data.\n */\nfunction fillCacheHelper(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  fillLazyItems: boolean\n): void {\n  const {\n    segmentPath,\n    seedData: cacheNodeSeedData,\n    tree: treePatch,\n    head,\n  } = flightData\n  let newCacheNode = newCache\n  let existingCacheNode = existingCache\n\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n\n    // segmentPath is a repeating tuple of parallelRouteKey and segment\n    // we know we've hit the last entry we've reached our final pair\n    const isLastEntry = i === segmentPath.length - 2\n    const cacheKey = createRouterCacheKey(segment)\n\n    const existingChildSegmentMap =\n      existingCacheNode.parallelRoutes.get(parallelRouteKey)\n\n    if (!existingChildSegmentMap) {\n      // Bailout because the existing cache does not have the path to the leaf node\n      // Will trigger lazy fetch in layout-router because of missing segment\n      continue\n    }\n\n    let childSegmentMap = newCacheNode.parallelRoutes.get(parallelRouteKey)\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n      childSegmentMap = new Map(existingChildSegmentMap)\n      newCacheNode.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n    }\n\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n    let childCacheNode = childSegmentMap.get(cacheKey)\n\n    if (isLastEntry) {\n      if (\n        cacheNodeSeedData &&\n        (!childCacheNode ||\n          !childCacheNode.lazyData ||\n          childCacheNode === existingChildCacheNode)\n      ) {\n        const rsc = cacheNodeSeedData[0]\n        const loading = cacheNodeSeedData[2]\n\n        childCacheNode = {\n          lazyData: null,\n          // When `fillLazyItems` is false, we only want to fill the RSC data for the layout,\n          // not the page segment.\n          rsc: fillLazyItems || segment !== PAGE_SEGMENT_KEY ? rsc : null,\n          prefetchRsc: null,\n          head: null,\n          prefetchHead: null,\n          loading,\n          parallelRoutes:\n            fillLazyItems && existingChildCacheNode\n              ? new Map(existingChildCacheNode.parallelRoutes)\n              : new Map(),\n          navigatedAt,\n        }\n\n        if (existingChildCacheNode && fillLazyItems) {\n          invalidateCacheByRouterState(\n            childCacheNode,\n            existingChildCacheNode,\n            treePatch\n          )\n        }\n        if (fillLazyItems) {\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            childCacheNode,\n            existingChildCacheNode,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n        }\n\n        childSegmentMap.set(cacheKey, childCacheNode)\n      }\n      continue\n    }\n\n    if (!childCacheNode || !existingChildCacheNode) {\n      // Bailout because the existing cache does not have the path to the leaf node\n      // Will trigger lazy fetch in layout-router because of missing segment\n      continue\n    }\n\n    if (childCacheNode === existingChildCacheNode) {\n      childCacheNode = {\n        lazyData: childCacheNode.lazyData,\n        rsc: childCacheNode.rsc,\n        prefetchRsc: childCacheNode.prefetchRsc,\n        head: childCacheNode.head,\n        prefetchHead: childCacheNode.prefetchHead,\n        parallelRoutes: new Map(childCacheNode.parallelRoutes),\n        loading: childCacheNode.loading,\n      } as CacheNode\n      childSegmentMap.set(cacheKey, childCacheNode)\n    }\n\n    // Move deeper into the cache nodes\n    newCacheNode = childCacheNode\n    existingCacheNode = existingChildCacheNode\n  }\n}\n\n/**\n * Fill cache with rsc based on flightDataPath\n */\nexport function fillCacheWithNewSubTreeData(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData\n): void {\n  fillCacheHelper(navigatedAt, newCache, existingCache, flightData, true)\n}\n\nexport function fillCacheWithNewSubTreeDataButOnlyLoading(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData\n): void {\n  fillCacheHelper(navigatedAt, newCache, existingCache, flightData, false)\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { fillCacheWithNewSubTreeData } from './fill-cache-with-new-subtree-data'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\n\nexport function applyFlightData(\n  navigatedAt: number,\n  existingCache: CacheNode,\n  cache: CacheNode,\n  flightData: NormalizedFlightData\n): boolean {\n  // The one before last item is the router state tree patch\n  const { tree: treePatch, seedData, head, isRootRender } = flightData\n\n  // Handles case where prefetch only returns the router tree patch without rendered components.\n  if (seedData === null) {\n    return false\n  }\n\n  if (isRootRender) {\n    const rsc = seedData[0]\n    const loading = seedData[2]\n    cache.loading = loading\n    cache.rsc = rsc\n    // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n    // this path during a navigation, but until PPR is fully implemented\n    // yet it's possible the existing node does have a non-null\n    // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n    // old behavior — no PPR value.\n    cache.prefetchRsc = null\n    fillLazyItemsTillLeafWithHead(\n      navigatedAt,\n      cache,\n      existingCache,\n      treePatch,\n      seedData,\n      head\n    )\n  } else {\n    // Copy rsc for the root node of the cache.\n    cache.rsc = existingCache.rsc\n    // This is a PPR-only field. Unlike the previous branch, since we're\n    // just cloning the existing cache node, we might as well keep the\n    // PPR value, if it exists.\n    cache.prefetchRsc = existingCache.prefetchRsc\n    cache.parallelRoutes = new Map(existingCache.parallelRoutes)\n    cache.loading = existingCache.loading\n    // Create a copy of the existing cache with the rsc applied.\n    fillCacheWithNewSubTreeData(navigatedAt, cache, existingCache, flightData)\n  }\n\n  return true\n}\n","import type {\n  FlightRouterState,\n  CacheNode,\n} from '../../../shared/lib/app-router-types'\nimport type { AppRouterState } from './router-reducer-types'\nimport { applyFlightData } from './apply-flight-data'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\ninterface RefreshInactiveParallelSegments {\n  navigatedAt: number\n  state: AppRouterState\n  updatedTree: FlightRouterState\n  updatedCache: CacheNode\n  includeNextUrl: boolean\n  canonicalUrl: string\n}\n\n/**\n * Refreshes inactive segments that are still in the current FlightRouterState.\n * A segment is considered \"inactive\" when the server response indicates it didn't match to a page component.\n * This happens during a soft-navigation, where the server will want to patch in the segment\n * with the \"default\" component, but we explicitly ignore the server in this case\n * and keep the existing state for that segment. New data for inactive segments are inherently\n * not part of the server response when we patch the tree, because they were associated with a response\n * from an earlier navigation/request. For each segment, once it becomes \"active\", we encode the URL that provided\n * the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch\n * and patch the new data into the tree.\n */\nexport async function refreshInactiveParallelSegments(\n  options: RefreshInactiveParallelSegments\n) {\n  const fetchedSegments = new Set<string>()\n  await refreshInactiveParallelSegmentsImpl({\n    ...options,\n    rootTree: options.updatedTree,\n    fetchedSegments,\n  })\n}\n\nasync function refreshInactiveParallelSegmentsImpl({\n  navigatedAt,\n  state,\n  updatedTree,\n  updatedCache,\n  includeNextUrl,\n  fetchedSegments,\n  rootTree = updatedTree,\n  canonicalUrl,\n}: RefreshInactiveParallelSegments & {\n  fetchedSegments: Set<string>\n  rootTree: FlightRouterState\n}) {\n  const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree\n  const fetchPromises = []\n\n  if (\n    refetchPath &&\n    refetchPath !== canonicalUrl &&\n    refetchMarker === 'refresh' &&\n    // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)\n  ) {\n    fetchedSegments.add(refetchPath) // Mark this URL as fetched\n\n    // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n    // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n    const fetchPromise = fetchServerResponse(\n      new URL(refetchPath, location.origin),\n      {\n        // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n        // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n        flightRouterState: [rootTree[0], rootTree[1], rootTree[2], 'refetch'],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n      }\n    ).then((result) => {\n      if (typeof result !== 'string') {\n        const { flightData } = result\n        for (const flightDataPath of flightData) {\n          // we only pass the new cache as this function is called after clearing the router cache\n          // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n          // just been created & has been written to, but hasn't been \"committed\" yet.\n          applyFlightData(\n            navigatedAt,\n            updatedCache,\n            updatedCache,\n            flightDataPath\n          )\n        }\n      } else {\n        // When result is a string, it suggests that the server response should have triggered an MPA navigation\n        // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n        // when refreshing on-screen data, so handling this has been ommitted.\n      }\n    })\n\n    fetchPromises.push(fetchPromise)\n  }\n\n  for (const key in parallelRoutes) {\n    const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n      navigatedAt,\n      state,\n      updatedTree: parallelRoutes[key],\n      updatedCache,\n      includeNextUrl,\n      fetchedSegments,\n      rootTree,\n      canonicalUrl,\n    })\n\n    fetchPromises.push(parallelFetchPromise)\n  }\n\n  await Promise.all(fetchPromises)\n}\n\n/**\n * Walks the current parallel segments to determine if they are \"active\".\n * An active parallel route will have a `__PAGE__` segment in the FlightRouterState.\n * As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.\n * We add a special marker here so that we know how to refresh its data when the router is revalidated.\n */\nexport function addRefreshMarkerToActiveParallelSegments(\n  tree: FlightRouterState,\n  path: string\n) {\n  const [segment, parallelRoutes, , refetchMarker] = tree\n  // a page segment might also contain concatenated search params, so we do a partial match on the key\n  if (segment.includes(PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n    tree[2] = path\n    tree[3] = 'refresh'\n  }\n\n  for (const key in parallelRoutes) {\n    addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path)\n  }\n}\n","import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { matchSegment } from '../match-segments'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\n\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */\nfunction applyPatch(\n  initialTree: FlightRouterState,\n  patchTree: FlightRouterState\n): FlightRouterState {\n  const [initialSegment, initialParallelRoutes] = initialTree\n  const [patchSegment, patchParallelRoutes] = patchTree\n\n  // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree\n  // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n  if (\n    patchSegment === DEFAULT_SEGMENT_KEY &&\n    initialSegment !== DEFAULT_SEGMENT_KEY\n  ) {\n    return initialTree\n  }\n\n  if (matchSegment(initialSegment, patchSegment)) {\n    const newParallelRoutes: FlightRouterState[1] = {}\n    for (const key in initialParallelRoutes) {\n      const isInPatchTreeParallelRoutes =\n        typeof patchParallelRoutes[key] !== 'undefined'\n      if (isInPatchTreeParallelRoutes) {\n        newParallelRoutes[key] = applyPatch(\n          initialParallelRoutes[key],\n          patchParallelRoutes[key]\n        )\n      } else {\n        newParallelRoutes[key] = initialParallelRoutes[key]\n      }\n    }\n\n    for (const key in patchParallelRoutes) {\n      if (newParallelRoutes[key]) {\n        continue\n      }\n\n      newParallelRoutes[key] = patchParallelRoutes[key]\n    }\n\n    const tree: FlightRouterState = [initialSegment, newParallelRoutes]\n\n    // Copy over the existing tree\n    if (initialTree[2]) {\n      tree[2] = initialTree[2]\n    }\n\n    if (initialTree[3]) {\n      tree[3] = initialTree[3]\n    }\n\n    if (initialTree[4]) {\n      tree[4] = initialTree[4]\n    }\n\n    return tree\n  }\n\n  return patchTree\n}\n\n/**\n * Apply the router state from the Flight response, but skip patching default segments.\n * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.\n * Creates a new router state tree.\n */\nexport function applyRouterStatePatchToTree(\n  flightSegmentPath: FlightSegmentPath,\n  flightRouterState: FlightRouterState,\n  treePatch: FlightRouterState,\n  path: string\n): FlightRouterState | null {\n  const [segment, parallelRoutes, url, refetch, isRootLayout] =\n    flightRouterState\n\n  // Root refresh\n  if (flightSegmentPath.length === 1) {\n    const tree: FlightRouterState = applyPatch(flightRouterState, treePatch)\n\n    addRefreshMarkerToActiveParallelSegments(tree, path)\n\n    return tree\n  }\n\n  const [currentSegment, parallelRouteKey] = flightSegmentPath\n\n  // Tree path returned from the server should always match up with the current tree in the browser\n  if (!matchSegment(currentSegment, segment)) {\n    return null\n  }\n\n  const lastSegment = flightSegmentPath.length === 2\n\n  let parallelRoutePatch\n  if (lastSegment) {\n    parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch)\n  } else {\n    parallelRoutePatch = applyRouterStatePatchToTree(\n      getNextFlightSegmentPath(flightSegmentPath),\n      parallelRoutes[parallelRouteKey],\n      treePatch,\n      path\n    )\n\n    if (parallelRoutePatch === null) {\n      return null\n    }\n  }\n\n  const tree: FlightRouterState = [\n    flightSegmentPath[0],\n    {\n      ...parallelRoutes,\n      [parallelRouteKey]: parallelRoutePatch,\n    },\n    url,\n    refetch,\n  ]\n\n  // Current segment is the root layout\n  if (isRootLayout) {\n    tree[4] = true\n  }\n\n  addRefreshMarkerToActiveParallelSegments(tree, path)\n\n  return tree\n}\n","import { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\nimport type { FlightRouterState } from '../../shared/lib/app-router-types'\n\nconst ANNOUNCER_TYPE = 'next-route-announcer'\nconst ANNOUNCER_ID = '__next-route-announcer__'\n\nfunction getAnnouncerNode() {\n  const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0]\n  if (existingAnnouncer?.shadowRoot?.childNodes[0]) {\n    return existingAnnouncer.shadowRoot.childNodes[0] as HTMLElement\n  } else {\n    const container = document.createElement(ANNOUNCER_TYPE)\n    container.style.cssText = 'position:absolute'\n    const announcer = document.createElement('div')\n    announcer.ariaLive = 'assertive'\n    announcer.id = ANNOUNCER_ID\n    announcer.role = 'alert'\n    announcer.style.cssText =\n      'position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal'\n\n    // Use shadow DOM here to avoid any potential CSS bleed\n    const shadow = container.attachShadow({ mode: 'open' })\n    shadow.appendChild(announcer)\n    document.body.appendChild(container)\n    return announcer\n  }\n}\n\nexport function AppRouterAnnouncer({ tree }: { tree: FlightRouterState }) {\n  const [portalNode, setPortalNode] = useState<HTMLElement | null>(null)\n\n  useEffect(() => {\n    const announcer = getAnnouncerNode()\n    setPortalNode(announcer)\n    return () => {\n      const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0]\n      if (container?.isConnected) {\n        document.body.removeChild(container)\n      }\n    }\n  }, [])\n\n  const [routeAnnouncement, setRouteAnnouncement] = useState('')\n  const previousTitle = useRef<string | undefined>(undefined)\n\n  useEffect(() => {\n    let currentTitle = ''\n    if (document.title) {\n      currentTitle = document.title\n    } else {\n      const pageHeader = document.querySelector('h1')\n      if (pageHeader) {\n        currentTitle = pageHeader.innerText || pageHeader.textContent || ''\n      }\n    }\n\n    // Only announce the title change, but not for the first load because screen\n    // readers do that automatically.\n    if (\n      previousTitle.current !== undefined &&\n      previousTitle.current !== currentTitle\n    ) {\n      setRouteAnnouncement(currentTitle)\n    }\n    previousTitle.current = currentTitle\n  }, [tree])\n\n  return portalNode ? createPortal(routeAnnouncement, portalNode) : null\n}\n","import type {\n  FlightRouterState,\n  CacheNode,\n} from '../../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport { createRouterCacheKey } from '../create-router-cache-key'\n\nexport function findHeadInCache(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1]\n): [CacheNode, string, string] | null {\n  return findHeadInCacheImpl(cache, parallelRoutes, '', '')\n}\n\nfunction findHeadInCacheImpl(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1],\n  keyPrefix: string,\n  keyPrefixWithoutSearchParams: string\n): [CacheNode, string, string] | null {\n  const isLastItem = Object.keys(parallelRoutes).length === 0\n  if (isLastItem) {\n    // Returns the entire Cache Node of the segment whose head we will render.\n    return [cache, keyPrefix, keyPrefixWithoutSearchParams]\n  }\n\n  // First try the 'children' parallel route if it exists\n  // when starting from the \"root\", this corresponds with the main page component\n  const parallelRoutesKeys = Object.keys(parallelRoutes).filter(\n    (key) => key !== 'children'\n  )\n\n  // if we are at the root, we need to check the children slot first\n  if ('children' in parallelRoutes) {\n    parallelRoutesKeys.unshift('children')\n  }\n\n  for (const key of parallelRoutesKeys) {\n    const [segment, childParallelRoutes] = parallelRoutes[key]\n    // If the parallel is not matched and using the default segment,\n    // skip searching the head from it.\n    if (segment === DEFAULT_SEGMENT_KEY) {\n      continue\n    }\n    const childSegmentMap = cache.parallelRoutes.get(key)\n    if (!childSegmentMap) {\n      continue\n    }\n\n    const cacheKey = createRouterCacheKey(segment)\n    const cacheKeyWithoutSearchParams = createRouterCacheKey(segment, true)\n\n    const cacheNode = childSegmentMap.get(cacheKey)\n    if (!cacheNode) {\n      continue\n    }\n\n    const item = findHeadInCacheImpl(\n      cacheNode,\n      childParallelRoutes,\n      keyPrefix + '/' + cacheKey,\n      keyPrefix + '/' + cacheKeyWithoutSearchParams\n    )\n\n    if (item) {\n      return item\n    }\n  }\n\n  return null\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Checks if a given path starts with a given prefix. It ensures it matches\n * exactly without containing extra chars. e.g. prefix /docs should replace\n * for /docs, /docs/, /docs/a but not /docsss\n * @param path The path to check.\n * @param prefix The prefix to check against.\n */\nexport function pathHasPrefix(path: string, prefix: string) {\n  if (typeof path !== 'string') {\n    return false\n  }\n\n  const { pathname } = parsePath(path)\n  return pathname === prefix || pathname.startsWith(prefix + '/')\n}\n","import { pathHasPrefix } from '../shared/lib/router/utils/path-has-prefix'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function hasBasePath(path: string): boolean {\n  return pathHasPrefix(path, basePath)\n}\n","import { hasBasePath } from './has-base-path'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function removeBasePath(path: string): string {\n  if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {\n    if (!hasBasePath(path)) {\n      return path\n    }\n  }\n\n  // Can't trim the basePath if it has zero length!\n  if (basePath.length === 0) return path\n\n  path = path.slice(basePath.length)\n  if (!path.startsWith('/')) path = `/${path}`\n  return path\n}\n","'use client'\n\nimport { Component, createRef, type ReactNode } from 'react'\n\ninterface ErrorBoundaryProps {\n  children: ReactNode\n}\n\ninterface ErrorBoundaryState {\n  hasError: boolean\n}\n\nfunction getDomNodeAttributes(node: HTMLElement): Record<string, string> {\n  const result: Record<string, string> = {}\n  for (let i = 0; i < node.attributes.length; i++) {\n    const attr = node.attributes[i]\n    result[attr.name] = attr.value\n  }\n  return result\n}\n\nexport class GracefulDegradeBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  private rootHtml: string\n  private htmlAttributes: Record<string, string>\n  private htmlRef: React.RefObject<HTMLHtmlElement | null>\n\n  constructor(props: ErrorBoundaryProps) {\n    super(props)\n    this.state = { hasError: false }\n    this.rootHtml = ''\n    this.htmlAttributes = {}\n    this.htmlRef = createRef<HTMLHtmlElement>()\n  }\n\n  static getDerivedStateFromError(_: unknown): ErrorBoundaryState {\n    return { hasError: true }\n  }\n\n  componentDidMount() {\n    const htmlNode = this.htmlRef.current\n    if (this.state.hasError && htmlNode) {\n      // Reapply the cached HTML attributes to the root element\n      Object.entries(this.htmlAttributes).forEach(([key, value]) => {\n        htmlNode.setAttribute(key, value)\n      })\n    }\n  }\n\n  render() {\n    const { hasError } = this.state\n    // Cache the root HTML content on the first render\n    if (typeof window !== 'undefined' && !this.rootHtml) {\n      this.rootHtml = document.documentElement.innerHTML\n      this.htmlAttributes = getDomNodeAttributes(document.documentElement)\n    }\n\n    if (hasError) {\n      // Render the current HTML content without hydration\n      return (\n        <html\n          ref={this.htmlRef}\n          suppressHydrationWarning\n          dangerouslySetInnerHTML={{\n            __html: this.rootHtml,\n          }}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport default GracefulDegradeBoundary\n","'use client'\n\nimport React, { type JSX } from 'react'\nimport GracefulDegradeBoundary from './graceful-degrade-boundary'\nimport { ErrorBoundary, type ErrorBoundaryProps } from '../error-boundary'\nimport { isBot } from '../../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport default function RootErrorBoundary({\n  children,\n  errorComponent,\n  errorStyles,\n  errorScripts,\n}: ErrorBoundaryProps & { children: React.ReactNode }): JSX.Element {\n  if (isBotUserAgent) {\n    // Preserve existing DOM/HTML for bots to avoid replacing content with an error UI\n    // and to keep the original SSR output intact.\n    return <GracefulDegradeBoundary>{children}</GracefulDegradeBoundary>\n  }\n\n  return (\n    <ErrorBoundary\n      errorComponent={errorComponent}\n      errorStyles={errorStyles}\n      errorScripts={errorScripts}\n    >\n      {children}\n    </ErrorBoundary>\n  )\n}\n","import React, {\n  useEffect,\n  useMemo,\n  startTransition,\n  useInsertionEffect,\n  useDeferredValue,\n} from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type { CacheNode } from '../../shared/lib/app-router-types'\nimport { ACTION_RESTORE } from './router-reducer/router-reducer-types'\nimport type {\n  AppHistoryState,\n  AppRouterState,\n} from './router-reducer/router-reducer-types'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n  NavigationPromisesContext,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { dispatchAppRouterAction, useActionQueue } from './use-action-queue'\nimport { AppRouterAnnouncer } from './app-router-announcer'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { findHeadInCache } from './router-reducer/reducers/find-head-in-cache'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { removeBasePath } from '../remove-base-path'\nimport { hasBasePath } from '../has-base-path'\nimport { getSelectedParams } from './router-reducer/compute-changed-path'\nimport { useNavFailureHandler } from './nav-failure-handler'\nimport {\n  dispatchTraverseAction,\n  publicAppRouterInstance,\n  type AppRouterActionQueue,\n  type GlobalErrorState,\n} from './app-router-instance'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { isRedirectError, RedirectType } from './redirect-error'\nimport { pingVisibleLinks } from './links'\nimport RootErrorBoundary from './errors/root-error-boundary'\nimport DefaultGlobalError from './builtin/global-error'\nimport { RootLayoutBoundary } from '../../lib/framework/boundary-components'\nimport type { StaticIndicatorState } from '../dev/hot-reloader/app/hot-reloader-app'\n\nconst globalMutable: {\n  pendingMpaPath?: string\n} = {}\n\nfunction HistoryUpdater({\n  appRouterState,\n}: {\n  appRouterState: AppRouterState\n}) {\n  useInsertionEffect(() => {\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      // clear pending URL as navigation is no longer\n      // in flight\n      window.next.__pendingUrl = undefined\n    }\n\n    const { tree, pushRef, canonicalUrl, renderedSearch } = appRouterState\n\n    const appHistoryState: AppHistoryState = {\n      tree,\n      renderedSearch,\n    }\n\n    const historyState = {\n      ...(pushRef.preserveCustomHistoryState ? window.history.state : {}),\n      // Identifier is shortened intentionally.\n      // __NA is used to identify if the history entry can be handled by the app-router.\n      // __N is used to identify if the history entry can be handled by the old router.\n      __NA: true,\n      __PRIVATE_NEXTJS_INTERNALS_TREE: appHistoryState,\n    }\n    if (\n      pushRef.pendingPush &&\n      // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n      // This mirrors the browser behavior for normal navigation.\n      createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl\n    ) {\n      // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n      pushRef.pendingPush = false\n      window.history.pushState(historyState, '', canonicalUrl)\n    } else {\n      window.history.replaceState(historyState, '', canonicalUrl)\n    }\n  }, [appRouterState])\n\n  useEffect(() => {\n    // The Next-Url and the base tree may affect the result of a prefetch\n    // task. Re-prefetch all visible links with the updated values. In most\n    // cases, this will not result in any new network requests, only if\n    // the prefetch result actually varies on one of these inputs.\n    pingVisibleLinks(appRouterState.nextUrl, appRouterState.tree)\n  }, [appRouterState.nextUrl, appRouterState.tree])\n\n  return null\n}\n\nexport function createEmptyCacheNode(): CacheNode {\n  return {\n    lazyData: null,\n    rsc: null,\n    prefetchRsc: null,\n    head: null,\n    prefetchHead: null,\n    parallelRoutes: new Map(),\n    loading: null,\n    navigatedAt: -1,\n  }\n}\n\nfunction copyNextJsInternalHistoryState(data: any) {\n  if (data == null) data = {}\n  const currentState = window.history.state\n  const __NA = currentState?.__NA\n  if (__NA) {\n    data.__NA = __NA\n  }\n  const __PRIVATE_NEXTJS_INTERNALS_TREE =\n    currentState?.__PRIVATE_NEXTJS_INTERNALS_TREE\n  if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n    data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE\n  }\n\n  return data\n}\n\nfunction Head({\n  headCacheNode,\n}: {\n  headCacheNode: CacheNode | null\n}): React.ReactNode {\n  // If this segment has a `prefetchHead`, it's the statically prefetched data.\n  // We should use that on initial render instead of `head`. Then we'll switch\n  // to `head` when the dynamic response streams in.\n  const head = headCacheNode !== null ? headCacheNode.head : null\n  const prefetchHead =\n    headCacheNode !== null ? headCacheNode.prefetchHead : null\n\n  // If no prefetch data is available, then we go straight to rendering `head`.\n  const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  return useDeferredValue(head, resolvedPrefetchRsc)\n}\n\n/**\n * The global router that wraps the application components.\n */\nfunction Router({\n  actionQueue,\n  globalError,\n  webSocket,\n  staticIndicatorState,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalError: GlobalErrorState\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}) {\n  const state = useActionQueue(actionQueue)\n  const { canonicalUrl } = state\n  // Add memoized pathname/query for useSearchParams and usePathname.\n  const { searchParams, pathname } = useMemo(() => {\n    const url = new URL(\n      canonicalUrl,\n      typeof window === 'undefined' ? 'http://n' : window.location.href\n    )\n\n    return {\n      // This is turned into a readonly class in `useSearchParams`\n      searchParams: url.searchParams,\n      pathname: hasBasePath(url.pathname)\n        ? removeBasePath(url.pathname)\n        : url.pathname,\n    }\n  }, [canonicalUrl])\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { cache, tree } = state\n\n    // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      // Add `window.nd` for debugging purposes.\n      // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n      // @ts-ignore this is for debugging\n      window.nd = {\n        router: publicAppRouterInstance,\n        cache,\n        tree,\n      }\n    }, [cache, tree])\n  }\n\n  useEffect(() => {\n    // If the app is restored from bfcache, it's possible that\n    // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n    // would trigger the mpa navigation logic again from the lines below.\n    // This will restore the router to the initial state in the event that the app is restored from bfcache.\n    function handlePageShow(event: PageTransitionEvent) {\n      if (\n        !event.persisted ||\n        !window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n      ) {\n        return\n      }\n\n      // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n      // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n      // of the last MPA navigation.\n      globalMutable.pendingMpaPath = undefined\n\n      dispatchAppRouterAction({\n        type: ACTION_RESTORE,\n        url: new URL(window.location.href),\n        historyState: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE,\n      })\n    }\n\n    window.addEventListener('pageshow', handlePageShow)\n\n    return () => {\n      window.removeEventListener('pageshow', handlePageShow)\n    }\n  }, [])\n\n  useEffect(() => {\n    // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n    // are caught and handled by the router.\n    function handleUnhandledRedirect(\n      event: ErrorEvent | PromiseRejectionEvent\n    ) {\n      const error = 'reason' in event ? event.reason : event.error\n      if (isRedirectError(error)) {\n        event.preventDefault()\n        const url = getURLFromRedirectError(error)\n        const redirectType = getRedirectTypeFromError(error)\n        // TODO: This should access the router methods directly, rather than\n        // go through the public interface.\n        if (redirectType === RedirectType.push) {\n          publicAppRouterInstance.push(url, {})\n        } else {\n          publicAppRouterInstance.replace(url, {})\n        }\n      }\n    }\n    window.addEventListener('error', handleUnhandledRedirect)\n    window.addEventListener('unhandledrejection', handleUnhandledRedirect)\n\n    return () => {\n      window.removeEventListener('error', handleUnhandledRedirect)\n      window.removeEventListener('unhandledrejection', handleUnhandledRedirect)\n    }\n  }, [])\n\n  // When mpaNavigation flag is set do a hard navigation to the new url.\n  // Infinitely suspend because we don't actually want to rerender any child\n  // components with the new URL and any entangled state updates shouldn't\n  // commit either (eg: useTransition isPending should stay true until the page\n  // unloads).\n  //\n  // This is a side effect in render. Don't try this at home, kids. It's\n  // probably safe because we know this is a singleton component and it's never\n  // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n  // but that's... fine?)\n  const { pushRef } = state\n  if (pushRef.mpaNavigation) {\n    // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n    if (globalMutable.pendingMpaPath !== canonicalUrl) {\n      const location = window.location\n      if (pushRef.pendingPush) {\n        location.assign(canonicalUrl)\n      } else {\n        location.replace(canonicalUrl)\n      }\n\n      globalMutable.pendingMpaPath = canonicalUrl\n    }\n    // TODO-APP: Should we listen to navigateerror here to catch failed\n    // navigations somehow? And should we call window.stop() if a SPA navigation\n    // should interrupt an MPA one?\n    // NOTE: This is intentionally using `throw` instead of `use` because we're\n    // inside an externally mutable condition (pushRef.mpaNavigation), which\n    // violates the rules of hooks.\n    throw unresolvedThenable\n  }\n\n  useEffect(() => {\n    const originalPushState = window.history.pushState.bind(window.history)\n    const originalReplaceState = window.history.replaceState.bind(\n      window.history\n    )\n\n    // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n    const applyUrlFromHistoryPushReplace = (\n      url: string | URL | null | undefined\n    ) => {\n      const href = window.location.href\n      const appHistoryState: AppHistoryState | undefined =\n        window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_RESTORE,\n          url: new URL(url ?? href, href),\n          historyState: appHistoryState,\n        })\n      })\n    }\n\n    /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.pushState = function pushState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalPushState(data, _unused, url)\n      }\n\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n\n      return originalPushState(data, _unused, url)\n    }\n\n    /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.replaceState = function replaceState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalReplaceState(data, _unused, url)\n      }\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n      return originalReplaceState(data, _unused, url)\n    }\n\n    /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */\n    const onPopState = (event: PopStateEvent) => {\n      if (!event.state) {\n        // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n        return\n      }\n\n      // This case happens when the history entry was pushed by the `pages` router.\n      if (!event.state.__NA) {\n        window.location.reload()\n        return\n      }\n\n      // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n      // Without startTransition works if the cache is there for this path\n      startTransition(() => {\n        dispatchTraverseAction(\n          window.location.href,\n          event.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n        )\n      })\n    }\n\n    // Register popstate event to call onPopstate.\n    window.addEventListener('popstate', onPopState)\n    return () => {\n      window.history.pushState = originalPushState\n      window.history.replaceState = originalReplaceState\n      window.removeEventListener('popstate', onPopState)\n    }\n  }, [])\n\n  const { cache, tree, nextUrl, focusAndScrollRef, previousNextUrl } = state\n\n  const matchingHead = useMemo(() => {\n    return findHeadInCache(cache, tree[1])\n  }, [cache, tree])\n\n  // Add memoized pathParams for useParams.\n  const pathParams = useMemo(() => {\n    return getSelectedParams(tree)\n  }, [tree])\n\n  // Create instrumented promises for navigation hooks (dev-only)\n  // These are specially instrumented promises to show in the Suspense DevTools\n  // Promises are cached outside of render to survive suspense retries.\n  let instrumentedNavigationPromises: NavigationPromises | null = null\n  if (process.env.NODE_ENV !== 'production') {\n    const { createRootNavigationPromises } =\n      require('./navigation-devtools') as typeof import('./navigation-devtools')\n\n    instrumentedNavigationPromises = createRootNavigationPromises(\n      tree,\n      pathname,\n      searchParams,\n      pathParams\n    )\n  }\n\n  const layoutRouterContext = useMemo(() => {\n    return {\n      parentTree: tree,\n      parentCacheNode: cache,\n      parentSegmentPath: null,\n      parentParams: {},\n      // This is the <Activity> \"name\" that shows up in the Suspense DevTools.\n      // It represents the root of the app.\n      debugNameContext: '/',\n      // Root node always has `url`\n      // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n      url: canonicalUrl,\n      // Root segment is always active\n      isActive: true,\n    }\n  }, [tree, cache, canonicalUrl])\n\n  const globalLayoutRouterContext = useMemo(() => {\n    return {\n      tree,\n      focusAndScrollRef,\n      nextUrl,\n      previousNextUrl,\n    }\n  }, [tree, focusAndScrollRef, nextUrl, previousNextUrl])\n\n  let head\n  if (matchingHead !== null) {\n    // The head is wrapped in an extra component so we can use\n    // `useDeferredValue` to swap between the prefetched and final versions of\n    // the head. (This is what LayoutRouter does for segment data, too.)\n    //\n    // The `key` is used to remount the component whenever the head moves to\n    // a different segment.\n    const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead\n\n    head = (\n      <Head\n        key={\n          // Necessary for PPR: omit search params from the key to match prerendered keys\n          typeof window === 'undefined' ? headKeyWithoutSearchParams : headKey\n        }\n        headCacheNode={headCacheNode}\n      />\n    )\n  } else {\n    head = null\n  }\n\n  let content = (\n    <RedirectBoundary>\n      {head}\n      {/* RootLayoutBoundary enables detection of Suspense boundaries around the root layout.\n          When users wrap their layout in <Suspense>, this creates the component stack pattern\n          \"Suspense -> RootLayoutBoundary\" which dynamic-rendering.ts uses to allow dynamic rendering. */}\n      <RootLayoutBoundary>{cache.rsc}</RootLayoutBoundary>\n      <AppRouterAnnouncer tree={tree} />\n    </RedirectBoundary>\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    // In development, we apply few error boundaries and hot-reloader:\n    // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n    // - HotReloader:\n    //  - hot-reload the app when the code changes\n    //  - render dev overlay\n    //  - catch runtime errors and display global-error when necessary\n    if (typeof window !== 'undefined') {\n      const { DevRootHTTPAccessFallbackBoundary } =\n        require('./dev-root-http-access-fallback-boundary') as typeof import('./dev-root-http-access-fallback-boundary')\n      content = (\n        <DevRootHTTPAccessFallbackBoundary>\n          {content}\n        </DevRootHTTPAccessFallbackBoundary>\n      )\n    }\n    const HotReloader: typeof import('../dev/hot-reloader/app/hot-reloader-app').default =\n      (\n        require('../dev/hot-reloader/app/hot-reloader-app') as typeof import('../dev/hot-reloader/app/hot-reloader-app')\n      ).default\n\n    content = (\n      <HotReloader\n        globalError={globalError}\n        webSocket={webSocket}\n        staticIndicatorState={staticIndicatorState}\n      >\n        {content}\n      </HotReloader>\n    )\n  } else {\n    content = (\n      <RootErrorBoundary\n        errorComponent={globalError[0]}\n        errorStyles={globalError[1]}\n      >\n        {content}\n      </RootErrorBoundary>\n    )\n  }\n\n  return (\n    <>\n      <HistoryUpdater appRouterState={state} />\n      <RuntimeStyles />\n      <NavigationPromisesContext.Provider\n        value={instrumentedNavigationPromises}\n      >\n        <PathParamsContext.Provider value={pathParams}>\n          <PathnameContext.Provider value={pathname}>\n            <SearchParamsContext.Provider value={searchParams}>\n              <GlobalLayoutRouterContext.Provider\n                value={globalLayoutRouterContext}\n              >\n                {/* TODO: We should be able to remove this context. useRouter\n                    should import from app-router-instance instead. It's only\n                    necessary because useRouter is shared between Pages and\n                    App Router. We should fork that module, then remove this\n                    context provider. */}\n                <AppRouterContext.Provider value={publicAppRouterInstance}>\n                  <LayoutRouterContext.Provider value={layoutRouterContext}>\n                    {content}\n                  </LayoutRouterContext.Provider>\n                </AppRouterContext.Provider>\n              </GlobalLayoutRouterContext.Provider>\n            </SearchParamsContext.Provider>\n          </PathnameContext.Provider>\n        </PathParamsContext.Provider>\n      </NavigationPromisesContext.Provider>\n    </>\n  )\n}\n\nexport default function AppRouter({\n  actionQueue,\n  globalErrorState,\n  webSocket,\n  staticIndicatorState,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalErrorState: GlobalErrorState\n  webSocket?: WebSocket\n  staticIndicatorState?: StaticIndicatorState\n}) {\n  useNavFailureHandler()\n\n  const router = (\n    <Router\n      actionQueue={actionQueue}\n      globalError={globalErrorState}\n      webSocket={webSocket}\n      staticIndicatorState={staticIndicatorState}\n    />\n  )\n\n  // At the very top level, use the default GlobalError component as the final fallback.\n  // When the app router itself fails, which means the framework itself fails, we show the default error.\n  return (\n    <RootErrorBoundary errorComponent={DefaultGlobalError}>\n      {router}\n    </RootErrorBoundary>\n  )\n}\n\nconst runtimeStyles = new Set<string>()\nlet runtimeStyleChanged = new Set<() => void>()\n\nglobalThis._N_E_STYLE_LOAD = function (href: string) {\n  let len = runtimeStyles.size\n  runtimeStyles.add(href)\n  if (runtimeStyles.size !== len) {\n    runtimeStyleChanged.forEach((cb) => cb())\n  }\n  // TODO figure out how to get a promise here\n  // But maybe it's not necessary as react would block rendering until it's loaded\n  return Promise.resolve()\n}\n\nfunction RuntimeStyles() {\n  const [, forceUpdate] = React.useState(0)\n  const renderedStylesSize = runtimeStyles.size\n  useEffect(() => {\n    const changed = () => forceUpdate((c) => c + 1)\n    runtimeStyleChanged.add(changed)\n    if (renderedStylesSize !== runtimeStyles.size) {\n      changed()\n    }\n    return () => {\n      runtimeStyleChanged.delete(changed)\n    }\n  }, [renderedStylesSize, forceUpdate])\n\n  const dplId = process.env.NEXT_DEPLOYMENT_ID\n    ? `?dpl=${process.env.NEXT_DEPLOYMENT_ID}`\n    : ''\n  return [...runtimeStyles].map((href, i) => (\n    <link\n      key={i}\n      rel=\"stylesheet\"\n      href={`${href}${dplId}`}\n      // @ts-ignore\n      precedence=\"next\"\n      // TODO figure out crossOrigin and nonce\n      // crossOrigin={TODO}\n      // nonce={TODO}\n    />\n  ))\n}\n","import { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyFlightData } from '../apply-flight-data'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-types'\nimport { createEmptyCacheNode } from '../../app-router'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  const { serverResponse, navigatedAt } = action\n\n  const mutable: Mutable = {}\n\n  mutable.preserveCustomHistoryState = false\n\n  // Handle case when navigating to page in `pages` from `app`\n  if (typeof serverResponse === 'string') {\n    return handleExternalUrl(\n      state,\n      mutable,\n      serverResponse,\n      state.pushRef.pendingPush\n    )\n  }\n\n  const { flightData, canonicalUrl, renderedSearch } = serverResponse\n\n  let currentTree = state.tree\n  let currentCache = state.cache\n\n  for (const normalizedFlightData of flightData) {\n    const { segmentPath: flightSegmentPath, tree: treePatch } =\n      normalizedFlightData\n\n    const newTree = applyRouterStatePatchToTree(\n      // TODO-APP: remove ''\n      ['', ...flightSegmentPath],\n      currentTree,\n      treePatch,\n      state.canonicalUrl\n    )\n\n    // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.\n    // In other words, the server responded with a tree that doesn't match what the client is currently rendering.\n    // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.\n    // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing\n    // the entire page to reload.\n    if (newTree === null) {\n      return state\n    }\n\n    if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n      return handleExternalUrl(\n        state,\n        mutable,\n        state.canonicalUrl,\n        state.pushRef.pendingPush\n      )\n    }\n\n    mutable.canonicalUrl = createHrefFromUrl(canonicalUrl)\n\n    const cache: CacheNode = createEmptyCacheNode()\n    applyFlightData(navigatedAt, currentCache, cache, normalizedFlightData)\n\n    mutable.patchedTree = newTree\n    mutable.renderedSearch = renderedSearch\n    mutable.cache = cache\n\n    currentCache = cache\n    currentTree = newTree\n  }\n\n  return handleMutable(state, mutable)\n}\n","import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport { updateCacheNodeOnPopstateRestoration } from '../ppr-navigations'\nimport type { FlightRouterState } from '../../../../shared/lib/app-router-types'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  const { url, historyState } = action\n  const href = createHrefFromUrl(url)\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  let treeToRestore: FlightRouterState | undefined\n  let renderedSearch: string | undefined\n  if (historyState) {\n    treeToRestore = historyState.tree\n    renderedSearch = historyState.renderedSearch\n  } else {\n    treeToRestore = state.tree\n    renderedSearch = state.renderedSearch\n  }\n\n  const oldCache = state.cache\n  const newCache = process.env.__NEXT_PPR\n    ? // When PPR is enabled, we update the cache to drop the prefetch\n      // data for any segment whose dynamic data was already received. This\n      // prevents an unnecessary flash back to PPR state during a\n      // back/forward navigation.\n      updateCacheNodeOnPopstateRestoration(oldCache, treeToRestore)\n    : oldCache\n\n  return {\n    // Set canonical url\n    canonicalUrl: href,\n    renderedSearch,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: newCache,\n    // Restore provided tree\n    tree: treeToRestore,\n    nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n}\n","import type { FlightRouterState } from '../../../shared/lib/app-router-types'\nimport { handleExternalUrl } from './reducers/navigate-reducer'\nimport type {\n  ReadonlyReducerState,\n  ReducerActions,\n} from './router-reducer-types'\n\n/**\n * Handles the case where the client router attempted to patch the tree but, due to a mismatch, the patch failed.\n * This will perform an MPA navigation to return the router to a valid state.\n */\nexport function handleSegmentMismatch(\n  state: ReadonlyReducerState,\n  action: ReducerActions,\n  treePatch: FlightRouterState\n) {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\n      'Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\\n\\n' +\n        'Reason: Segment mismatch\\n' +\n        `Last Action: ${action.type}\\n\\n` +\n        `Current Tree: ${JSON.stringify(state.tree)}\\n\\n` +\n        `Tree Patch Payload: ${JSON.stringify(treePatch)}`\n    )\n  }\n\n  return handleExternalUrl(state, {}, state.canonicalUrl, true)\n}\n","import {\n  fetchServerResponse,\n  type FetchServerResponseResult,\n} from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n  RefreshAction,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-types'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport { revalidateEntireCache } from '../../segment-cache/cache'\n\nexport function refreshReducer(\n  state: ReadonlyReducerState,\n  action: RefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [\n      currentTree[0],\n      currentTree[1],\n      currentTree[2],\n      'refetch',\n    ],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n  })\n\n  const navigatedAt = Date.now()\n  return cache.lazyData.then(\n    async (result: FetchServerResponseResult) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof result === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          result,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const { flightData, canonicalUrl, renderedSearch } = result\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        mutable.canonicalUrl = createHrefFromUrl(canonicalUrl)\n\n        // Handles case where prefetch only returns the router tree patch without rendered components.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[0]\n          const loading = cacheNodeSeedData[2]\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = loading\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            cache,\n            // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n          revalidateEntireCache(state.nextUrl, newTree)\n        }\n\n        await refreshInactiveParallelSegments({\n          navigatedAt,\n          state,\n          updatedTree: newTree,\n          updatedCache: cache,\n          includeNextUrl,\n          canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n        })\n\n        mutable.cache = cache\n        mutable.patchedTree = newTree\n        mutable.renderedSearch = renderedSearch\n\n        currentTree = newTree\n      }\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n","import {\n  fetchServerResponse,\n  type FetchServerResponseResult,\n} from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  HmrRefreshAction,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport type { CacheNode } from '../../../../shared/lib/app-router-types'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\n\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(\n  state: ReadonlyReducerState,\n  action: HmrRefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  const navigatedAt = Date.now()\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [state.tree[0], state.tree[1], state.tree[2], 'refetch'],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n    isHmrRefresh: true,\n  })\n\n  return cache.lazyData.then(\n    (result: FetchServerResponseResult) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof result === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          result,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const { flightData, canonicalUrl, renderedSearch } = result\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      let currentTree = state.tree\n      let currentCache = state.cache\n\n      for (const normalizedFlightData of flightData) {\n        const { tree: treePatch, isRootRender } = normalizedFlightData\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const applied = applyFlightData(\n          navigatedAt,\n          currentCache,\n          cache,\n          normalizedFlightData\n        )\n\n        if (applied) {\n          mutable.cache = cache\n          currentCache = cache\n        }\n\n        mutable.patchedTree = newTree\n        mutable.renderedSearch = renderedSearch\n        mutable.canonicalUrl = createHrefFromUrl(canonicalUrl)\n\n        currentTree = newTree\n      }\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n\nfunction hmrRefreshReducerNoop(\n  state: ReadonlyReducerState,\n  _action: HmrRefreshAction\n): ReducerState {\n  return state\n}\n\nexport const hmrRefreshReducer =\n  process.env.NODE_ENV === 'production'\n    ? hmrRefreshReducerNoop\n    : hmrRefreshReducerImpl\n","import { addBasePath } from './add-base-path'\n\n/**\n * Function to correctly assign location to URL\n *\n * The method will add basePath, and will also correctly add location (including if it is a relative path)\n * @param location Location that should be added to the url\n * @param url Base URL to which the location should be assigned\n */\nexport function assignLocation(location: string, url: URL): URL {\n  if (location.startsWith('.')) {\n    const urlBase = url.origin + url.pathname\n    return new URL(\n      // In order for a relative path to be added to the current url correctly, the current url must end with a slash\n      // new URL('./relative', 'https://example.com/subdir').href -> 'https://example.com/relative'\n      // new URL('./relative', 'https://example.com/subdir/').href -> 'https://example.com/subdir/relative'\n      (urlBase.endsWith('/') ? urlBase : urlBase + '/') + location\n    )\n  }\n\n  return new URL(addBasePath(location), url.href)\n}\n","export interface ServerReferenceInfo {\n  type: 'server-action' | 'use-cache'\n  usedArgs: [boolean, boolean, boolean, boolean, boolean, boolean]\n  hasRestArgs: boolean\n}\n\n/**\n * Extracts info about the server reference for the given server reference ID by\n * parsing the first byte of the hex-encoded ID.\n *\n * ```\n * Bit positions: [7]      [6] [5] [4] [3] [2] [1]  [0]\n * Bits:          typeBit  argMask                  restArgs\n * ```\n *\n * If the `typeBit` is `1` the server reference represents a `\"use cache\"`\n * function, otherwise a server action.\n *\n * The `argMask` encodes whether the function uses the argument at the\n * respective position.\n *\n * The `restArgs` bit indicates whether the function uses a rest parameter. It's\n * also set to 1 if the function has more than 6 args.\n *\n * @param id hex-encoded server reference ID\n */\nexport function extractInfoFromServerReferenceId(\n  id: string\n): ServerReferenceInfo {\n  const infoByte = parseInt(id.slice(0, 2), 16)\n  const typeBit = (infoByte >> 7) & 0x1\n  const argMask = (infoByte >> 1) & 0x3f\n  const restArgs = infoByte & 0x1\n  const usedArgs = Array(6)\n\n  for (let index = 0; index < 6; index++) {\n    const bitPosition = 5 - index\n    const bit = (argMask >> bitPosition) & 0x1\n    usedArgs[index] = bit === 1\n  }\n\n  return {\n    type: typeBit === 1 ? 'use-cache' : 'server-action',\n    usedArgs: usedArgs as [\n      boolean,\n      boolean,\n      boolean,\n      boolean,\n      boolean,\n      boolean,\n    ],\n    hasRestArgs: restArgs === 1,\n  }\n}\n\n/**\n * Creates a sparse array containing only the used arguments based on the\n * provided action info.\n */\nexport function omitUnusedArgs(\n  args: unknown[],\n  info: ServerReferenceInfo\n): unknown[] {\n  const filteredArgs = new Array(args.length)\n\n  for (let index = 0; index < args.length; index++) {\n    if (\n      (index < 6 && info.usedArgs[index]) ||\n      // This assumes that the server reference info byte has the restArgs bit\n      // set to 1 if there are more than 6 args.\n      (index >= 6 && info.hasRestArgs)\n    ) {\n      filteredArgs[index] = args[index]\n    }\n  }\n\n  return filteredArgs\n}\n","import type {\n  ActionFlightResponse,\n  ActionResult,\n} from '../../../../shared/lib/app-router-types'\nimport { callServer } from '../../../app-call-server'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\nimport {\n  ACTION_HEADER,\n  NEXT_ACTION_NOT_FOUND_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../../app-router-headers'\nimport { UnrecognizedActionError } from '../../unrecognized-action-error'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromFetch as createFromFetchBrowser,\n  createTemporaryReferenceSet,\n  encodeReply,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  ServerActionAction,\n  ServerActionMutable,\n} from '../router-reducer-types'\nimport { assignLocation } from '../../../assign-location'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type { CacheNode } from '../../../../shared/lib/app-router-types'\nimport { handleMutable } from '../handle-mutable'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../../flight-data-helpers'\nimport { getRedirectError } from '../../redirect'\nimport { RedirectType } from '../../redirect-error'\nimport { removeBasePath } from '../../../remove-base-path'\nimport { hasBasePath } from '../../../has-base-path'\nimport {\n  extractInfoFromServerReferenceId,\n  omitUnusedArgs,\n} from '../../../../shared/lib/server-reference-info'\nimport { revalidateEntireCache } from '../../segment-cache/cache'\n\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../../dev/debug-channel') as typeof import('../../../dev/debug-channel')\n  ).createDebugChannel\n}\n\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  redirectType: RedirectType | undefined\n  actionResult: ActionResult | undefined\n  actionFlightData: NormalizedFlightData[] | string | undefined\n  isPrerender: boolean\n  revalidatedParts: {\n    tag: boolean\n    cookie: boolean\n    paths: string[]\n  }\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const temporaryReferences = createTemporaryReferenceSet()\n  const info = extractInfoFromServerReferenceId(actionId)\n\n  // TODO: Currently, we're only omitting unused args for the experimental \"use\n  // cache\" functions. Once the server reference info byte feature is stable, we\n  // should apply this to server actions as well.\n  const usedArgs =\n    info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs\n\n  const body = await encodeReply(usedArgs, { temporaryReferences })\n\n  const headers: Record<string, string> = {\n    Accept: RSC_CONTENT_TYPE_HEADER,\n    [ACTION_HEADER]: actionId,\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      state.tree\n    ),\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const res = await fetch(state.canonicalUrl, { method: 'POST', headers, body })\n\n  // Handle server actions that the server didn't recognize.\n  const unrecognizedActionHeader = res.headers.get(NEXT_ACTION_NOT_FOUND_HEADER)\n  if (unrecognizedActionHeader === '1') {\n    throw new UnrecognizedActionError(\n      `Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n\n  const redirectHeader = res.headers.get('x-action-redirect')\n  const [location, _redirectType] = redirectHeader?.split(';') || []\n  let redirectType: RedirectType | undefined\n  switch (_redirectType) {\n    case 'push':\n      redirectType = RedirectType.push\n      break\n    case 'replace':\n      redirectType = RedirectType.replace\n      break\n    default:\n      redirectType = undefined\n  }\n\n  const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)\n  let revalidatedParts: FetchServerActionResult['revalidatedParts']\n  try {\n    const revalidatedHeader = JSON.parse(\n      res.headers.get('x-action-revalidated') || '[[],0,0]'\n    )\n    revalidatedParts = {\n      paths: revalidatedHeader[0] || [],\n      tag: !!revalidatedHeader[1],\n      cookie: revalidatedHeader[2],\n    }\n  } catch (e) {\n    revalidatedParts = NO_REVALIDATED_PARTS\n  }\n\n  const redirectLocation = location\n    ? assignLocation(\n        location,\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  const contentType = res.headers.get('content-type')\n  const isRscResponse = !!(\n    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n  )\n\n  // Handle invalid server action responses.\n  // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n  // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n  if (!isRscResponse && !redirectLocation) {\n    // The server can respond with a text/plain error message, but we'll fallback to something generic\n    // if there isn't one.\n    const message =\n      res.status >= 400 && contentType === 'text/plain'\n        ? await res.text()\n        : 'An unexpected response was received from the server.'\n\n    throw new Error(message)\n  }\n\n  let actionResult: FetchServerActionResult['actionResult']\n  let actionFlightData: FetchServerActionResult['actionFlightData']\n\n  if (isRscResponse) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      {\n        callServer,\n        findSourceMapURL,\n        temporaryReferences,\n        debugChannel: createDebugChannel && createDebugChannel(headers),\n      }\n    )\n\n    // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n    actionResult = redirectLocation ? undefined : response.a\n    actionFlightData = normalizeFlightData(response.f)\n  } else {\n    // An external redirect doesn't contain RSC data.\n    actionResult = undefined\n    actionFlightData = undefined\n  }\n\n  return {\n    actionResult,\n    actionFlightData,\n    redirectLocation,\n    redirectType,\n    revalidatedParts,\n    isPrerender,\n  }\n}\n\nconst NO_REVALIDATED_PARTS = {\n  paths: [],\n  tag: false,\n  cookie: false,\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n  const mutable: ServerActionMutable = {}\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    // We always send the last next-url, not the current when\n    // performing a dynamic request. This is because we update\n    // the next-url after a navigation, but we want the same\n    // interception route to be matched that used the last\n    // next-url.\n    (state.previousNextUrl || state.nextUrl) &&\n    hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.previousNextUrl || state.nextUrl\n      : null\n\n  const navigatedAt = Date.now()\n\n  return fetchServerAction(state, nextUrl, action).then(\n    async ({\n      actionResult,\n      actionFlightData: flightData,\n      redirectLocation,\n      redirectType,\n      revalidatedParts,\n    }) => {\n      let redirectHref: string | undefined\n\n      // honor the redirect type instead of defaulting to push in case of server actions.\n      if (redirectLocation) {\n        if (redirectType === RedirectType.replace) {\n          state.pushRef.pendingPush = false\n          mutable.pendingPush = false\n        } else {\n          state.pushRef.pendingPush = true\n          mutable.pendingPush = true\n        }\n\n        redirectHref = createHrefFromUrl(redirectLocation, false)\n        mutable.canonicalUrl = redirectHref\n      }\n\n      if (!flightData) {\n        resolve(actionResult)\n\n        // If there is a redirect but no flight data we need to do a mpaNavigation.\n        if (redirectLocation) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectLocation.href,\n            state.pushRef.pendingPush\n          )\n        }\n        return state\n      }\n\n      if (typeof flightData === 'string') {\n        // Handle case when navigating to page in `pages` from `app`\n        resolve(actionResult)\n\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const actionRevalidated =\n        revalidatedParts.paths.length > 0 ||\n        revalidatedParts.tag ||\n        revalidatedParts.cookie\n\n      // Store whether this action triggered any revalidation\n      // The action queue will use this information to potentially\n      // trigger a refresh action if the action was discarded\n      // (ie, due to a navigation, before the action completed)\n      if (actionRevalidated) {\n        action.didRevalidate = true\n      }\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('SERVER ACTION APPLY FAILED')\n          resolve(actionResult)\n\n          return state\n        }\n\n        // Given the path can only have two items the items are only the router state and rsc for the root.\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          redirectHref ? redirectHref : state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          resolve(actionResult)\n\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          resolve(actionResult)\n\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectHref || state.canonicalUrl,\n            state.pushRef.pendingPush\n          )\n        }\n\n        // The server sent back RSC data for the server action, so we need to apply it to the cache.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[0]\n          const cache: CacheNode = createEmptyCacheNode()\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = cacheNodeSeedData[2]\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            cache,\n            // Existing cache is not passed in as server actions have to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n\n          mutable.cache = cache\n          revalidateEntireCache(state.nextUrl, newTree)\n          if (actionRevalidated) {\n            await refreshInactiveParallelSegments({\n              navigatedAt,\n              state,\n              updatedTree: newTree,\n              updatedCache: cache,\n              includeNextUrl: Boolean(nextUrl),\n              canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n            })\n          }\n        }\n\n        mutable.patchedTree = newTree\n        currentTree = newTree\n      }\n\n      if (redirectLocation && redirectHref) {\n        // If the action triggered a redirect, the action promise will be rejected with\n        // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n        // action result to resolve the promise with. This will effectively reset the state of\n        // the component that called the action as the error boundary will remount the tree.\n        // The status code doesn't matter here as the action handler will have already sent\n        // a response with the correct status code.\n        const redirectError = getRedirectError(\n          hasBasePath(redirectHref)\n            ? removeBasePath(redirectHref)\n            : redirectHref,\n          redirectType || RedirectType.push\n        )\n        // We mark the error as handled because we don't want the redirect to be tried later by\n        // the RedirectBoundary, in case the user goes back and `Activity` triggers the redirect\n        // again, as it's run within an effect.\n        // We don't actually need the RedirectBoundary to do a router.push because we already\n        // have all the necessary RSC data to render the new page within a single roundtrip.\n        ;(redirectError as any).handled = true\n        reject(redirectError)\n      } else {\n        resolve(actionResult)\n      }\n\n      return handleMutable(state, mutable)\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n","import {\n  ACTION_NAVIGATE,\n  ACTION_SERVER_PATCH,\n  ACTION_RESTORE,\n  ACTION_REFRESH,\n  ACTION_HMR_REFRESH,\n  ACTION_SERVER_ACTION,\n} from './router-reducer-types'\nimport type {\n  ReducerActions,\n  ReducerState,\n  ReadonlyReducerState,\n} from './router-reducer-types'\nimport { navigateReducer } from './reducers/navigate-reducer'\nimport { serverPatchReducer } from './reducers/server-patch-reducer'\nimport { restoreReducer } from './reducers/restore-reducer'\nimport { refreshReducer } from './reducers/refresh-reducer'\nimport { hmrRefreshReducer } from './reducers/hmr-refresh-reducer'\nimport { serverActionReducer } from './reducers/server-action-reducer'\n\n/**\n * Reducer that handles the app-router state updates.\n */\nfunction clientReducer(\n  state: ReadonlyReducerState,\n  action: ReducerActions\n): ReducerState {\n  switch (action.type) {\n    case ACTION_NAVIGATE: {\n      return navigateReducer(state, action)\n    }\n    case ACTION_SERVER_PATCH: {\n      return serverPatchReducer(state, action)\n    }\n    case ACTION_RESTORE: {\n      return restoreReducer(state, action)\n    }\n    case ACTION_REFRESH: {\n      return refreshReducer(state, action)\n    }\n    case ACTION_HMR_REFRESH: {\n      return hmrRefreshReducer(state, action)\n    }\n    case ACTION_SERVER_ACTION: {\n      return serverActionReducer(state, action)\n    }\n    // This case should never be hit as dispatch is strongly typed.\n    default:\n      throw new Error('Unknown action')\n  }\n}\n\nfunction serverReducer(\n  state: ReadonlyReducerState,\n  _action: ReducerActions\n): ReducerState {\n  return state\n}\n\n// we don't run the client reducer on the server, so we use a noop function for better tree shaking\nexport const reducer =\n  typeof window === 'undefined' ? serverReducer : clientReducer\n","import type { FlightRouterState } from '../../../shared/lib/app-router-types'\nimport { createPrefetchURL } from '../app-router-utils'\nimport { createCacheKey } from './cache-key'\nimport { schedulePrefetchTask } from './scheduler'\nimport { PrefetchPriority, type PrefetchTaskFetchStrategy } from './types'\n\n/**\n * Entrypoint for prefetching a URL into the Segment Cache.\n * @param href - The URL to prefetch. Typically this will come from a <Link>,\n * or router.prefetch. It must be validated before we attempt to prefetch it.\n * @param nextUrl - A special header used by the server for interception routes.\n * Roughly corresponds to the current URL.\n * @param treeAtTimeOfPrefetch - The FlightRouterState at the time the prefetch\n * was requested. This is only used when PPR is disabled.\n * @param fetchStrategy - Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n * @param onInvalidate - A callback that will be called when the prefetch cache\n * When called, it signals to the listener that the data associated with the\n * prefetch may have been invalidated from the cache. This is not a live\n * subscription — it's called at most once per `prefetch` call. The only\n * supported use case is to trigger a new prefetch inside the listener, if\n * desired. It also may be called even in cases where the associated data is\n * still cached. Prefetching is a poll-based (pull) operation, not an event-\n * based (push) one. Rather than subscribe to specific cache entries, you\n * occasionally poll the prefetch cache to check if anything is missing.\n */\nexport function prefetch(\n  href: string,\n  nextUrl: string | null,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  onInvalidate: null | (() => void)\n) {\n  const url = createPrefetchURL(href)\n  if (url === null) {\n    // This href should not be prefetched.\n    return\n  }\n  const cacheKey = createCacheKey(url.href, nextUrl)\n  schedulePrefetchTask(\n    cacheKey,\n    treeAtTimeOfPrefetch,\n    fetchStrategy,\n    PrefetchPriority.Default,\n    onInvalidate\n  )\n}\n","import {\n  type AppRouterState,\n  type ReducerActions,\n  type ReducerState,\n  ACTION_REFRESH,\n  ACTION_SERVER_ACTION,\n  ACTION_NAVIGATE,\n  ACTION_RESTORE,\n  type NavigateAction,\n  ACTION_HMR_REFRESH,\n  PrefetchKind,\n  type AppHistoryState,\n} from './router-reducer/router-reducer-types'\nimport { reducer } from './router-reducer/router-reducer'\nimport { startTransition } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n} from './segment-cache/types'\nimport { prefetch as prefetchWithSegmentCache } from './segment-cache/prefetch'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { addBasePath } from '../add-base-path'\nimport { isExternalURL } from './app-router-utils'\nimport type {\n  AppRouterInstance,\n  NavigateOptions,\n  PrefetchOptions,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { setLinkForCurrentNavigation, type LinkInstance } from './links'\nimport type { ClientInstrumentationHooks } from '../app-index'\nimport type { GlobalErrorComponent } from './builtin/global-error'\n\nexport type DispatchStatePromise = React.Dispatch<ReducerState>\n\nexport type AppRouterActionQueue = {\n  state: AppRouterState\n  dispatch: (payload: ReducerActions, setState: DispatchStatePromise) => void\n  action: (state: AppRouterState, action: ReducerActions) => ReducerState\n\n  onRouterTransitionStart:\n    | ((url: string, type: 'push' | 'replace' | 'traverse') => void)\n    | null\n\n  pending: ActionQueueNode | null\n  needsRefresh?: boolean\n  last: ActionQueueNode | null\n}\n\nexport type GlobalErrorState = [\n  GlobalError: GlobalErrorComponent,\n  styles: React.ReactNode,\n]\n\nexport type ActionQueueNode = {\n  payload: ReducerActions\n  next: ActionQueueNode | null\n  resolve: (value: ReducerState) => void\n  reject: (err: Error) => void\n  discarded?: boolean\n}\n\nfunction runRemainingActions(\n  actionQueue: AppRouterActionQueue,\n  setState: DispatchStatePromise\n) {\n  if (actionQueue.pending !== null) {\n    actionQueue.pending = actionQueue.pending.next\n    if (actionQueue.pending !== null) {\n      runAction({\n        actionQueue,\n        action: actionQueue.pending,\n        setState,\n      })\n    }\n  } else {\n    // Check for refresh when pending is already null\n    // This handles the case where a discarded server action completes\n    // after the navigation has already finished and the queue is empty\n    if (actionQueue.needsRefresh) {\n      actionQueue.needsRefresh = false\n      actionQueue.dispatch(\n        {\n          type: ACTION_REFRESH,\n          origin: window.location.origin,\n        },\n        setState\n      )\n    }\n  }\n}\n\nasync function runAction({\n  actionQueue,\n  action,\n  setState,\n}: {\n  actionQueue: AppRouterActionQueue\n  action: ActionQueueNode\n  setState: DispatchStatePromise\n}) {\n  const prevState = actionQueue.state\n\n  actionQueue.pending = action\n\n  const payload = action.payload\n  const actionResult = actionQueue.action(prevState, payload)\n\n  function handleResult(nextState: AppRouterState) {\n    // if we discarded this action, the state should also be discarded\n    if (action.discarded) {\n      // Check if the discarded server action revalidated data\n      if (\n        action.payload.type === ACTION_SERVER_ACTION &&\n        action.payload.didRevalidate\n      ) {\n        // The server action was discarded but it revalidated data,\n        // mark that we need to refresh after all actions complete\n        actionQueue.needsRefresh = true\n      }\n      // Still need to run remaining actions even for discarded actions\n      // to potentially trigger the refresh\n      runRemainingActions(actionQueue, setState)\n      return\n    }\n\n    actionQueue.state = nextState\n\n    runRemainingActions(actionQueue, setState)\n    action.resolve(nextState)\n  }\n\n  // if the action is a promise, set up a callback to resolve it\n  if (isThenable(actionResult)) {\n    actionResult.then(handleResult, (err) => {\n      runRemainingActions(actionQueue, setState)\n      action.reject(err)\n    })\n  } else {\n    handleResult(actionResult)\n  }\n}\n\nfunction dispatchAction(\n  actionQueue: AppRouterActionQueue,\n  payload: ReducerActions,\n  setState: DispatchStatePromise\n) {\n  let resolvers: {\n    resolve: (value: ReducerState) => void\n    reject: (reason: any) => void\n  } = { resolve: setState, reject: () => {} }\n\n  // most of the action types are async with the exception of restore\n  // it's important that restore is handled quickly since it's fired on the popstate event\n  // and we don't want to add any delay on a back/forward nav\n  // this only creates a promise for the async actions\n  if (payload.type !== ACTION_RESTORE) {\n    // Create the promise and assign the resolvers to the object.\n    const deferredPromise = new Promise<AppRouterState>((resolve, reject) => {\n      resolvers = { resolve, reject }\n    })\n\n    startTransition(() => {\n      // we immediately notify React of the pending promise -- the resolver is attached to the action node\n      // and will be called when the associated action promise resolves\n      setState(deferredPromise)\n    })\n  }\n\n  const newAction: ActionQueueNode = {\n    payload,\n    next: null,\n    resolve: resolvers.resolve,\n    reject: resolvers.reject,\n  }\n\n  // Check if the queue is empty\n  if (actionQueue.pending === null) {\n    // The queue is empty, so add the action and start it immediately\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else if (\n    payload.type === ACTION_NAVIGATE ||\n    payload.type === ACTION_RESTORE\n  ) {\n    // Navigations (including back/forward) take priority over any pending actions.\n    // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n    actionQueue.pending.discarded = true\n\n    // The rest of the current queue should still execute after this navigation.\n    // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n    newAction.next = actionQueue.pending.next\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else {\n    // The queue is not empty, so add the action to the end of the queue\n    // It will be started by runRemainingActions after the previous action finishes\n    if (actionQueue.last !== null) {\n      actionQueue.last.next = newAction\n    }\n    actionQueue.last = newAction\n  }\n}\n\nlet globalActionQueue: AppRouterActionQueue | null = null\n\nexport function createMutableActionQueue(\n  initialState: AppRouterState,\n  instrumentationHooks: ClientInstrumentationHooks | null\n): AppRouterActionQueue {\n  const actionQueue: AppRouterActionQueue = {\n    state: initialState,\n    dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =>\n      dispatchAction(actionQueue, payload, setState),\n    action: async (state: AppRouterState, action: ReducerActions) => {\n      const result = reducer(state, action)\n      return result\n    },\n    pending: null,\n    last: null,\n    onRouterTransitionStart:\n      instrumentationHooks !== null &&\n      typeof instrumentationHooks.onRouterTransitionStart === 'function'\n        ? // This profiling hook will be called at the start of every navigation.\n          instrumentationHooks.onRouterTransitionStart\n        : null,\n  }\n\n  if (typeof window !== 'undefined') {\n    // The action queue is lazily created on hydration, but after that point\n    // it doesn't change. So we can store it in a global rather than pass\n    // it around everywhere via props/context.\n    if (globalActionQueue !== null) {\n      throw new Error(\n        'Internal Next.js Error: createMutableActionQueue was called more ' +\n          'than once'\n      )\n    }\n    globalActionQueue = actionQueue\n  }\n\n  return actionQueue\n}\n\nexport function getCurrentAppRouterState(): AppRouterState | null {\n  return globalActionQueue !== null ? globalActionQueue.state : null\n}\n\nfunction getAppRouterActionQueue(): AppRouterActionQueue {\n  if (globalActionQueue === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  return globalActionQueue\n}\n\nfunction getProfilingHookForOnNavigationStart() {\n  if (globalActionQueue !== null) {\n    return globalActionQueue.onRouterTransitionStart\n  }\n  return null\n}\n\nexport function dispatchNavigateAction(\n  href: string,\n  navigateType: NavigateAction['navigateType'],\n  shouldScroll: boolean,\n  linkInstanceRef: LinkInstance | null\n): void {\n  // TODO: This stuff could just go into the reducer. Leaving as-is for now\n  // since we're about to rewrite all the router reducer stuff anyway.\n  const url = new URL(addBasePath(href), location.href)\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    window.next.__pendingUrl = url\n  }\n\n  setLinkForCurrentNavigation(linkInstanceRef)\n\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, navigateType)\n  }\n\n  dispatchAppRouterAction({\n    type: ACTION_NAVIGATE,\n    url,\n    isExternalUrl: isExternalURL(url),\n    locationSearch: location.search,\n    shouldScroll,\n    navigateType,\n  })\n}\n\nexport function dispatchTraverseAction(\n  href: string,\n  historyState: AppHistoryState | undefined\n) {\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, 'traverse')\n  }\n  dispatchAppRouterAction({\n    type: ACTION_RESTORE,\n    url: new URL(href),\n    historyState,\n  })\n}\n\n/**\n * The app router that is exposed through `useRouter`. These are public API\n * methods. Internal Next.js code should call the lower level methods directly\n * (although there's lots of existing code that doesn't do that).\n */\nexport const publicAppRouterInstance: AppRouterInstance = {\n  back: () => window.history.back(),\n  forward: () => window.history.forward(),\n  prefetch:\n    // Unlike the old implementation, the Segment Cache doesn't store its\n    // data in the router reducer state; it writes into a global mutable\n    // cache. So we don't need to dispatch an action.\n    (href: string, options?: PrefetchOptions) => {\n      const actionQueue = getAppRouterActionQueue()\n      const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n\n      // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n      // This will be possible when we update its API to not take a PrefetchKind.\n      let fetchStrategy: PrefetchTaskFetchStrategy\n      switch (prefetchKind) {\n        case PrefetchKind.AUTO: {\n          // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n          fetchStrategy = FetchStrategy.PPR\n          break\n        }\n        case PrefetchKind.FULL: {\n          fetchStrategy = FetchStrategy.Full\n          break\n        }\n        case PrefetchKind.TEMPORARY: {\n          // This concept doesn't exist in the segment cache implementation.\n          return\n        }\n        default: {\n          prefetchKind satisfies never\n          // Despite typescript thinking that this can't happen,\n          // we might get an unexpected value from user code.\n          // We don't know what they want, but we know they want a prefetch,\n          // so use the default.\n          fetchStrategy = FetchStrategy.PPR\n        }\n      }\n\n      prefetchWithSegmentCache(\n        href,\n        actionQueue.state.nextUrl,\n        actionQueue.state.tree,\n        fetchStrategy,\n        options?.onInvalidate ?? null\n      )\n    },\n  replace: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null)\n    })\n  },\n  push: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'push', options?.scroll ?? true, null)\n    })\n  },\n  refresh: () => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_REFRESH,\n        origin: window.location.origin,\n      })\n    })\n  },\n  hmrRefresh: () => {\n    if (process.env.NODE_ENV !== 'development') {\n      throw new Error(\n        'hmrRefresh can only be used in development mode. Please use refresh instead.'\n      )\n    } else {\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_HMR_REFRESH,\n          origin: window.location.origin,\n        })\n      })\n    }\n  },\n}\n\n// Exists for debugging purposes. Don't use in application code.\nif (typeof window !== 'undefined' && window.next) {\n  window.next.router = publicAppRouterInstance\n}\n"],"names":["computeChangedPath","extractPathFromFlightRouterState","getSelectedParams","removeLeadingSlash","segment","slice","segmentToPathname","normalizeSegments","segments","reduce","acc","isGroupSegment","flightRouterState","Array","isArray","DEFAULT_SEGMENT_KEY","INTERCEPTION_ROUTE_MARKERS","some","m","startsWith","undefined","PAGE_SEGMENT_KEY","parallelRoutes","childrenPath","children","push","key","value","Object","entries","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","matchSegment","parallelRouterKey","changedPath","split","currentTree","params","parallelRoute","values","isDynamicParameter","segmentValue","isCatchAll","handleMutable","isNotUndefined","state","mutable","shouldScroll","previousNextUrl","nextUrl","patchedTree","tree","canonicalUrl","renderedSearch","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","scrollableSegments","onlyHashChange","hashFragment","decodeURIComponent","segmentPaths","cache","debugInfo","collectedDebugInfo","isNavigatingToNewRootLayout","nextTree","currentTreeSegment","nextTreeSegment","currentTreeChild","nextTreeChild","abortTask","listenForDynamicRequest","startPPRNavigation","updateCacheNodeOnPopstateRestoration","MPA_NAVIGATION_TASK","route","node","dynamicRequestTree","navigatedAt","oldUrl","oldCacheNode","oldRouterState","newRouterState","prefetchData","prefetchHead","isPrefetchHeadPartial","isSamePageNavigation","scrollableSegmentsResult","segmentPath","updateCacheNodeOnNavigation","didFindRootLayout","oldRouterStateChildren","newRouterStateChildren","prefetchDataChildren","isRootLayout","oldParallelRoutes","prefetchParallelRoutes","Map","patchedRouterStateChildren","taskChildren","needsDynamicRequest","dynamicRequestTreeChildren","parallelRouteKey","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","get","prefetchDataChild","newSegmentChild","newSegmentPathChild","concat","newSegmentKeyChild","createRouterCacheKey","oldSegmentChild","oldCacheNodeChild","taskChild","reuseActiveSegmentInDefaultSlot","beginRenderingNewRouteTree","keys","length","set","newCacheNodeChild","newSegmentMapChild","taskChildRoute","dynamicRequestTreeChild","newCacheNode","lazyData","rsc","prefetchRsc","head","loading","patchRouterStateWithNewChildren","existingCacheNode","possiblyPartialPrefetchHead","createCacheNodeOnNavigation","routerState","routerStateChildren","isLeafSegment","cacheNodeNavigatedAt","DYNAMIC_STALETIME_MS","isPrefetchRscPartial","spawnPendingTask","existingCacheNodeChildren","cacheNodeChildren","routerStateChild","existingSegmentMapChild","segmentChild","segmentPathChild","segmentKeyChild","existingCacheNodeChild","baseRouterState","newChildren","clone","newTask","createPendingCacheNode","reusedRouterState","oldRefreshMarker","createHrefFromUrl","task","responsePromise","then","result","flightData","normalizedFlightData","serverRouterState","seedData","dynamicData","dynamicHead","writeDynamicDataIntoPendingTask","error","rootTask","i","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","size","maybePrefetchRsc","createDeferredRsc","cacheNode","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","abortPendingCacheNode","dynamicSegmentData","isDeferredRsc","resolve","dynamicLoading","reject","newParallelRoutes","shouldUsePrefetch","status","DEFERRED","Symbol","tag","pendingRsc","Promise","res","rej","responseDebugInfo","fulfilledRsc","rejectedRsc","reason","_debugInfo","HasLoadingBoundary","FetchStrategy","NavigationResultTag","PrefetchPriority","deleteFromLru","lruPut","updateLruSize","didScheduleCleanup","lruSize","maxLruSize","prev","next","ensureCleanupIsScheduled","tail","newNodeSize","prevNodeSize","deleted","requestCleanupCallback","cleanup","ninetyPercentMax","deleteFromCacheMap","requestIdleCallback","cb","setTimeout","Fallback","createCacheMap","getFromCacheMap","isValueExpired","setInCacheMap","setSizeInCacheMap","Revalidation","cacheMap","parent","map","getOrInitialize","isRevalidation","entry","remainingKeys","previousKey","existingEntry","newEntry","now","currentCacheVersion","rootEntry","getEntryWithFallbackImpl","staleAt","version","lazilyEvictIfNeeded","deleteMapEntry","fallbackEntry","setMapEntryValue","dropRef","emptyEntry","fillEmptyReference","oldEntry","ref","fullEntry","parentMap","delete","revalidatingEntry","appendLayoutVaryPath","clonePageVaryPathWithNewSearchParams","finalizeLayoutVaryPath","finalizeMetadataVaryPath","finalizePageVaryPath","getFulfilledRouteVaryPath","getRouteVaryPath","getSegmentVaryPathForRequest","pathname","search","varyPath","couldBeIntercepted","parentPath","cacheKey","varyPathPart","requestKey","layoutVaryPath","pageVaryPath","pageRequestKey","HEAD_REQUEST_KEY","fetchStrategy","originalVaryPath","isPage","doesVaryOnSearchParams","Full","PPRRuntime","searchParamsVaryPath","pathParamsVaryPath","patchedVaryPath","newSearch","clonedVaryPath","createCacheKey","originalHref","originalUrl","URL","cancelPrefetchTask","isPrefetchTaskDirty","pingPrefetchTask","reschedulePrefetchTask","schedulePrefetchTask","startRevalidationCooldown","scheduleMicrotask","queueMicrotask","fn","catch","taskHeap","inProgressRequests","sortIdCounter","didScheduleMicrotask","mostRecentlyHoveredLink","REVALIDATION_COOLDOWN_MS","revalidationCooldownTimeoutHandle","clearTimeout","ensureWorkIsScheduled","treeAtTimeOfPrefetch","priority","onInvalidate","cacheVersion","getCurrentCacheVersion","phase","hasBackgroundWork","spawnedRuntimePrefetches","sortId","isCanceled","_heapIndex","trackMostRecentlyHoveredLink","heapPush","heapDelete","Intent","heapResift","Background","Default","processQueueInMicrotask","hasNetworkBandwidth","spawnPrefetchSubtask","prefetchSubtask","onPrefetchConnectionClosed","closed","Date","heapPeek","exitStatus","pingRoute","heapPop","background","readOrCreateRouteCacheEntry","pingRootRouteTree","url","location","origin","keyWithoutSearch","href","routeWithoutSearch","EntryStatus","Empty","Pending","fetchRouteOnCacheMiss","Fulfilled","Rejected","blockedTasks","Set","add","PPR","isPPREnabled","LoadingBoundary","pingStaticHead","pingSharedPartOfCacheComponentsTree","spawnedEntries","pingRuntimeHead","requestTree","pingRuntimePrefetches","fetchSegmentPrefetchesUsingDynamicRequest","diffRouteTreeAgainstCurrent","pingStaticSegmentData","readOrCreateSegmentCacheEntry","metadata","pingRouteTreeAndIncludeDynamicData","oldTree","newTree","oldTreeChildren","newTreeChildren","slots","newTreeChild","newTreeChildSegment","oldTreeChild","oldTreeChildSegment","childExitStatus","doesCurrentSegmentMatchCachedSegment","pingNewPartOfCacheComponentsTree","hasRuntimePrefetch","childTree","requestTreeChildren","requestTreeChild","subtreeHasLoadingBoundary","hasLoadingBoundary","SubtreeHasNoLoadingBoundary","pingPPRDisabledRouteTreeUpToLoadingBoundary","convertRouteTreeToFlightRouterState","refetchMarkerContext","refetchMarker","upgradeToPendingSegment","segmentHasLoadingBoundary","SegmentHasLoadingBoundary","isInsideRefetchingParent","spawnedSegment","isPartial","canNewFetchStrategyProvideMoreContent","pingFullSegmentRevalidation","has","routeKey","fetchSegmentOnCacheMiss","pingPPRSegmentRevalidation","revalidatingSegment","readOrCreateRevalidatingSegmentEntry","upsertSegmentOnCompletion","pendingSegment","waitForSegmentCacheEntry","nonEmptyRevalidatingSegment","emptySegment","overwriteRevalidatingSegmentCacheEntry","noop","promise","fulfilled","upsertSegmentEntry","currentSegment","cachedSegment","addSearchParamsIfPageSegment","fromEntries","URLSearchParams","compareQueuePriority","a","b","priorityDiff","phaseDiff","heap","index","heapSiftUp","first","last","pop","heapSiftDown","parentIndex","halfLength","leftIndex","left","rightIndex","right","parsePath","path","hashIndex","indexOf","queryIndex","hasQuery","substring","query","hash","addPathPrefix","prefix","removeTrailingSlash","replace","normalizePathTrailingSlash","process","env","__NEXT_MANUAL_TRAILING_SLASH","__NEXT_TRAILING_SLASH","test","endsWith","addBasePath","basePath","__NEXT_ROUTER_BASEPATH","required","__NEXT_MANUAL_CLIENT_BASE_PATH","createPrefetchURL","isExternalURL","window","isBot","navigator","userAgent","_","Error","NODE_ENV","IDLE_LINK_STATUS","PENDING_LINK_STATUS","mountFormInstance","mountLinkInstance","onLinkVisibilityChanged","onNavigationIntent","pingVisibleLinks","setLinkForCurrentNavigation","unmountLinkForCurrentNavigation","unmountPrefetchableInstance","linkForMostRecentNavigation","pending","link","startTransition","setOptimisticLinkStatus","prefetchable","WeakMap","prefetchableAndVisible","observer","IntersectionObserver","handleIntersect","rootMargin","observeVisibility","element","instance","existingInstance","observe","coercePrefetchableUrl","require","reportErrorFn","reportError","console","router","prefetchEnabled","prefetchURL","isVisible","prefetchTask","prefetchHref","unobserve","intersectionRatio","target","rescheduleLinkPrefetch","unstable_upgradeToDynamicPrefetch","__NEXT_DYNAMIC_ON_HOVER","existingPrefetchTask","getCurrentAppRouterState","appRouterState","scheduleSegmentPrefetchTask","DOC_PREFETCH_RANGE_HEADER_VALUE","doesExportedHtmlMatchBuildId","insertBuildIdComment","DOCTYPE_PREFIX","MAX_BUILD_ID_LENGTH","escapeBuildId","buildId","truncated","originalHtml","includes","partialHtmlDocument","createDetachedSegmentCacheEntry","getStaleTimeMs","pingInvalidationListeners","readRouteCacheEntry","readSegmentCacheEntry","requestOptimisticRouteCacheEntry","revalidateEntireCache","staleTimeSeconds","Math","max","isOutputExportMode","__NEXT_CONFIG_OUTPUT","MetadataOnlyRequestTree","routeCacheMap","segmentCacheMap","invalidationListeners","attachInvalidationListener","notifyInvalidationListener","tasks","readRevalidatingSegmentCacheEntry","pendingEntry","promiseWithResolvers","createPromiseWithResolvers","Infinity","requestedUrl","requestedSearch","urlWithoutSearchParams","routeWithNoSearchParams","createPrefetchRequestKey","canonicalUrlForRouteWithNoSearchParams","optimisticCanonicalSearch","optimisticRenderedSearch","optimisticUrl","optimisticCanonicalUrl","optimisticRouteTree","createOptimisticRouteTree","optimisticMetadataTree","optimisticEntry","newRenderedSearch","clonedSlots","originalSlots","varyPathForRequest","candidateEntry","rejectedEntry","pingBlockedTasks","fulfillRouteCacheEntry","metadataVaryPath","fulfilledEntry","fulfillSegmentCacheEntry","segmentCacheEntry","rejectRouteCacheEntry","rejectSegmentCacheEntry","convertRootTreePrefetchToRouteTree","rootTree","renderedPathname","pathnameParts","filter","p","rootSegment","ROOT_SEGMENT_REQUEST_KEY","convertTreePrefetchToRouteTree","prefetch","partialVaryPath","pathnamePartsIndex","prefetchSlots","childPrefetch","childParamName","name","childParamType","paramType","childServerSentParamKey","paramKey","childDoesAppearInURL","childSegment","childPartialVaryPath","childParamValue","parseDynamicParamFromURLPart","childParamKey","getCacheKeyForDynamicParam","doesStaticSegmentAppearInURL","childPathnamePartsIndex","childRequestKeyPart","createSegmentRequestKeyPart","childRequestKey","appendSegmentRequestKeyPart","convertRootFlightRouterStateToRouteTree","convertFlightRouterStateToRouteTree","parentPartialVaryPath","originalSegment","paramCacheKey","childRouterState","routeTree","headers","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_URL","response","urlAfterRedirects","htmlResponse","fetch","Range","partialHtml","text","getAppBuildId","redirected","fetchPrefetchResponse","addSegmentPathToUrlInOutputExportMode","ok","body","varyHeader","routeIsPPREnabled","NEXT_DID_POSTPONE_HEADER","prefetchStream","createPrefetchResponseStream","onResponseSizeUpdate","serverData","createFromNextReadableStream","getRenderedPathname","getRenderedSearch","staleTimeMs","staleTime","writeDynamicTreeResponseIntoCache","fulfilledVaryPath","normalizedRequestKey","requestUrl","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","rejectSegmentEntriesIfStillPending","fulfilledEntries","totalBytesReceivedSoFar","averageSize","isResponsePartial","rp","writeDynamicRenderResponseIntoCache","normalizedFlightDataResult","normalizeFlightData","f","isRootRender","parseInt","NEXT_ROUTER_STALE_TIME_HEADER","isNaN","STATIC_STALETIME_MS","flightDatas","writeSeedDataIntoCache","fulfillEntrySpawnedByRuntimePrefetch","isHeadPartial","entriesOwnedByCurrentTask","seedDataChildren","childSeedData","ownedEntry","possiblyNewEntry","fetchPriority","shouldImmediatelyDecode","createFetch","contentType","isFlightResponse","RSC_CONTENT_TYPE_HEADER","originalFlightStream","onStreamClose","totalByteLength","reader","getReader","ReadableStream","pull","controller","done","read","enqueue","byteLength","staticUrl","routeDir","staticExportFilename","convertSegmentPathToStaticExportFilename","currentStrategy","newStrategy","navigate","currentUrl","currentCacheNode","currentFlightRouterState","accumulation","snapshot","readRenderSnapshotFromCache","prefetchFlightRouterState","prefetchSeedData","headSnapshot","readHeadSnapshotFromCache","newCanonicalUrl","navigateUsingPrefetchedRouteTree","optimisticRoute","Async","data","navigateDynamicallyWithNoPrefetch","promiseForDynamicServerResponse","fetchServerResponse","navigationTaskToResult","NoOp","MPA","Success","childRouterStates","childSeedDatas","childResult","segmentEntry","promiseForFulfilledEntry","newUrl","debugInfoFromResponse","simulatePrefetchTreeUsingDynamicTreePatch","hasDynamicHoles","baseTree","treePatch","canMutateInPlace","simulatePrefetchTreeUsingDynamicTreePatchImpl","patch","updatedParallelRouteKey","baseChildren","childBaseRouterState","generateSegmentsFromPatch","handleExternalUrl","navigateReducer","Number","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","flightRouterPatch","handleNavigationResult","asyncResult","action","isExternalUrl","navigateType","toString","document","getElementById","navigateUsingSegmentCache","fillLazyItemsTillLeafWithHead","newCache","existingCache","cacheNodeSeedData","isLastSegment","parallelRouteState","segmentForParallelRoute","parallelSeedData","existingParallelRoutesCacheNode","parallelRouteCacheNode","seedNode","existingParallelRoutes","invalidateCacheByRouterState","fillCacheWithNewSubTreeData","fillCacheWithNewSubTreeDataButOnlyLoading","fillCacheHelper","fillLazyItems","isLastEntry","existingChildSegmentMap","childSegmentMap","existingChildCacheNode","childCacheNode","applyFlightData","addRefreshMarkerToActiveParallelSegments","refreshInactiveParallelSegments","options","fetchedSegments","refreshInactiveParallelSegmentsImpl","updatedTree","updatedCache","includeNextUrl","refetchPath","fetchPromises","fetchPromise","flightDataPath","parallelFetchPromise","all","applyRouterStatePatchToTree","applyPatch","initialTree","patchTree","initialSegment","initialParallelRoutes","patchSegment","patchParallelRoutes","isInPatchTreeParallelRoutes","flightSegmentPath","refetch","lastSegment","parallelRoutePatch","getNextFlightSegmentPath","AppRouterAnnouncer","ANNOUNCER_TYPE","ANNOUNCER_ID","getAnnouncerNode","existingAnnouncer","getElementsByName","shadowRoot","childNodes","container","createElement","style","cssText","announcer","ariaLive","id","role","shadow","attachShadow","mode","appendChild","portalNode","setPortalNode","useState","useEffect","getElementsByTagName","isConnected","removeChild","routeAnnouncement","setRouteAnnouncement","previousTitle","useRef","currentTitle","title","pageHeader","querySelector","innerText","textContent","current","createPortal","findHeadInCache","findHeadInCacheImpl","keyPrefix","keyPrefixWithoutSearchParams","isLastItem","parallelRoutesKeys","unshift","childParallelRoutes","cacheKeyWithoutSearchParams","item","pathHasPrefix","hasBasePath","removeBasePath","GracefulDegradeBoundary","getDomNodeAttributes","attributes","attr","Component","constructor","props","hasError","rootHtml","htmlAttributes","htmlRef","createRef","getDerivedStateFromError","componentDidMount","htmlNode","forEach","setAttribute","render","documentElement","innerHTML","html","suppressHydrationWarning","dangerouslySetInnerHTML","__html","RootErrorBoundary","isBotUserAgent","errorComponent","errorStyles","errorScripts","ErrorBoundary","createEmptyCacheNode","AppRouter","globalMutable","HistoryUpdater","useInsertionEffect","__NEXT_APP_NAV_FAIL_HANDLING","__pendingUrl","appHistoryState","historyState","history","__NA","__PRIVATE_NEXTJS_INTERNALS_TREE","pushState","replaceState","copyNextJsInternalHistoryState","currentState","Head","headCacheNode","resolvedPrefetchRsc","useDeferredValue","Router","actionQueue","globalError","webSocket","staticIndicatorState","useActionQueue","searchParams","useMemo","nd","publicAppRouterInstance","handlePageShow","event","persisted","pendingMpaPath","dispatchAppRouterAction","type","ACTION_RESTORE","addEventListener","removeEventListener","handleUnhandledRedirect","isRedirectError","preventDefault","getURLFromRedirectError","redirectType","getRedirectTypeFromError","RedirectType","assign","unresolvedThenable","originalPushState","bind","originalReplaceState","applyUrlFromHistoryPushReplace","_unused","_N","onPopState","reload","dispatchTraverseAction","matchingHead","pathParams","instrumentedNavigationPromises","createRootNavigationPromises","layoutRouterContext","parentTree","parentCacheNode","parentSegmentPath","parentParams","debugNameContext","isActive","globalLayoutRouterContext","headKey","headKeyWithoutSearchParams","content","RedirectBoundary","RootLayoutBoundary","DevRootHTTPAccessFallbackBoundary","HotReloader","default","RuntimeStyles","NavigationPromisesContext","Provider","PathParamsContext","PathnameContext","SearchParamsContext","GlobalLayoutRouterContext","AppRouterContext","LayoutRouterContext","globalErrorState","useNavFailureHandler","DefaultGlobalError","runtimeStyles","runtimeStyleChanged","globalThis","_N_E_STYLE_LOAD","len","forceUpdate","React","renderedStylesSize","changed","c","dplId","NEXT_DEPLOYMENT_ID","rel","precedence","serverPatchReducer","serverResponse","currentCache","restoreReducer","treeToRestore","oldCache","__NEXT_PPR","handleSegmentMismatch","warn","JSON","stringify","refreshReducer","hasInterceptionRouteInCurrentTree","log","hmrRefreshReducer","hmrRefreshReducerImpl","isHmrRefresh","applied","hmrRefreshReducerNoop","_action","assignLocation","urlBase","extractInfoFromServerReferenceId","omitUnusedArgs","infoByte","typeBit","argMask","restArgs","usedArgs","bitPosition","bit","hasRestArgs","args","info","filteredArgs","serverActionReducer","createFromFetch","createFromFetchBrowser","createDebugChannel","__NEXT_REACT_DEBUG_CHANNEL","fetchServerAction","actionId","actionArgs","temporaryReferences","createTemporaryReferenceSet","encodeReply","Accept","ACTION_HEADER","self","__next_r","NEXT_HTML_REQUEST_ID_HEADER","NEXT_REQUEST_ID_HEADER","crypto","getRandomValues","Uint32Array","method","unrecognizedActionHeader","NEXT_ACTION_NOT_FOUND_HEADER","UnrecognizedActionError","redirectHeader","_redirectType","isPrerender","NEXT_IS_PRERENDER_HEADER","revalidatedParts","revalidatedHeader","parse","paths","cookie","e","NO_REVALIDATED_PARTS","redirectLocation","isRscResponse","message","actionResult","actionFlightData","callServer","findSourceMapURL","debugChannel","redirectHref","actionRevalidated","didRevalidate","Boolean","redirectError","getRedirectError","handled","reducer","clientReducer","ACTION_NAVIGATE","ACTION_SERVER_PATCH","ACTION_REFRESH","ACTION_HMR_REFRESH","ACTION_SERVER_ACTION","serverReducer","createMutableActionQueue","dispatchNavigateAction","runRemainingActions","setState","runAction","needsRefresh","dispatch","prevState","payload","handleResult","nextState","discarded","isThenable","err","dispatchAction","resolvers","deferredPromise","newAction","globalActionQueue","initialState","instrumentationHooks","onRouterTransitionStart","getAppRouterActionQueue","getProfilingHookForOnNavigationStart","linkInstanceRef","locationSearch","back","forward","prefetchKind","kind","PrefetchKind","AUTO","FULL","TEMPORARY","prefetchWithSegmentCache","scroll","refresh","hmrRefresh"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46]}